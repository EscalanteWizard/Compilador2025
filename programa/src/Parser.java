
//----------------------------------------------------
// The following code was generated by CUP v0.11b 20160615 (GIT 4ac7450)
//----------------------------------------------------

import java_cup.runtime.*;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.Map;
import java.util.Deque;
import java.util.ArrayDeque;
import java.util.List;
import java.util.ArrayList;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.regex.Pattern;
import java.util.regex.Matcher;
import java_cup.runtime.XMLElement;

/** CUP v0.11b 20160615 (GIT 4ac7450) generated parser.
  */
@SuppressWarnings({"rawtypes"})
public class Parser extends java_cup.runtime.lr_parser {

 public final Class getSymbolContainer() {
    return sym.class;
}

  /** Default constructor. */
  @Deprecated
  public Parser() {super();}

  /** Constructor which sets the default scanner. */
  @Deprecated
  public Parser(java_cup.runtime.Scanner s) {super(s);}

  /** Constructor which sets the default scanner. */
  public Parser(java_cup.runtime.Scanner s, java_cup.runtime.SymbolFactory sf) {super(s,sf);}

  /** Production table. */
  protected static final short _production_table[][] = 
    unpackFromStrings(new String[] {
    "\000\316\000\002\002\004\000\002\075\002\000\002\003" +
    "\004\000\002\047\004\000\002\047\003\000\002\047\004" +
    "\000\002\047\003\000\002\047\005\000\002\047\004\000" +
    "\002\047\005\000\002\047\004\000\002\047\005\000\002" +
    "\047\004\000\002\047\005\000\002\047\004\000\002\047" +
    "\004\000\002\047\003\000\002\047\004\000\002\047\003" +
    "\000\002\047\005\000\002\047\004\000\002\047\004\000" +
    "\002\047\003\000\002\047\004\000\002\006\005\000\002" +
    "\006\004\000\002\006\005\000\002\006\005\000\002\006" +
    "\004\000\002\006\004\000\002\006\004\000\002\006\004" +
    "\000\002\006\005\000\002\006\005\000\002\006\004\000" +
    "\002\006\004\000\002\006\004\000\002\006\005\000\002" +
    "\006\005\000\002\006\004\000\002\006\004\000\002\006" +
    "\004\000\002\006\005\000\002\006\005\000\002\006\006" +
    "\000\002\006\005\000\002\006\004\000\002\006\004\000" +
    "\002\006\004\000\002\006\003\000\002\006\003\000\002" +
    "\006\003\000\002\006\003\000\002\006\004\000\002\006" +
    "\004\000\002\006\003\000\002\006\003\000\002\006\003" +
    "\000\002\006\004\000\002\006\004\000\002\006\004\000" +
    "\002\006\003\000\002\006\003\000\002\006\003\000\002" +
    "\006\004\000\002\006\004\000\002\006\005\000\002\006" +
    "\004\000\002\006\003\000\002\006\003\000\002\006\003" +
    "\000\002\065\005\000\002\065\004\000\002\066\004\000" +
    "\002\066\003\000\002\024\003\000\002\024\003\000\002" +
    "\007\003\000\002\007\005\000\002\007\005\000\002\011" +
    "\003\000\002\011\005\000\002\011\005\000\002\011\005" +
    "\000\002\011\005\000\002\010\003\000\002\010\004\000" +
    "\002\010\003\000\002\010\003\000\002\010\003\000\002" +
    "\010\004\000\002\010\004\000\002\010\006\000\002\010" +
    "\003\000\002\010\006\000\002\010\005\000\002\010\003" +
    "\000\002\010\003\000\002\036\007\000\002\041\003\000" +
    "\002\042\005\000\002\042\005\000\002\042\003\000\002" +
    "\043\004\000\002\043\004\000\002\072\004\000\002\072" +
    "\002\000\002\073\004\000\002\073\002\000\002\074\004" +
    "\000\002\074\004\000\002\074\004\000\002\074\004\000" +
    "\002\074\004\000\002\074\004\000\002\067\003\000\002" +
    "\067\003\000\002\067\003\000\002\067\003\000\002\067" +
    "\003\000\002\005\006\000\002\005\006\000\002\005\005" +
    "\000\002\004\005\000\002\025\007\000\002\051\006\000" +
    "\002\052\004\000\002\053\004\000\002\040\004\000\002" +
    "\040\004\000\002\040\004\000\002\040\004\000\002\040" +
    "\004\000\002\040\004\000\002\076\002\000\002\012\010" +
    "\000\002\055\005\000\002\055\004\000\002\055\002\000" +
    "\002\056\003\000\002\056\002\000\002\057\003\000\002" +
    "\057\005\000\002\060\004\000\002\060\004\000\002\060" +
    "\004\000\002\060\004\000\002\060\004\000\002\015\004" +
    "\000\002\016\003\000\002\016\002\000\002\061\003\000" +
    "\002\061\002\000\002\062\003\000\002\062\005\000\002" +
    "\077\002\000\002\013\010\000\002\037\003\000\002\100" +
    "\002\000\002\031\011\000\002\027\004\000\002\027\003" +
    "\000\002\101\002\000\002\030\010\000\002\102\002\000" +
    "\002\030\010\000\002\035\003\000\002\103\002\000\002" +
    "\104\002\000\002\032\016\000\002\017\003\000\002\017" +
    "\003\000\002\033\007\000\002\033\002\000\002\105\002" +
    "\000\002\034\015\000\002\106\002\000\002\034\015\000" +
    "\002\063\005\000\002\063\005\000\002\064\003\000\002" +
    "\020\010\000\002\020\010\000\002\050\011\000\002\050" +
    "\011\000\002\026\010\000\002\026\012\000\002\021\010" +
    "\000\002\021\007\000\002\023\005\000\002\023\003\000" +
    "\002\070\005\000\002\070\004\000\002\071\005\000\002" +
    "\071\003\000\002\022\004\000\002\054\004\000\002\044" +
    "\006\000\002\045\005\000\002\045\005\000\002\045\005" +
    "\000\002\045\005\000\002\045\005\000\002\046\004\000" +
    "\002\046\003\000\002\014\006" });

  /** Access to production table. */
  public short[][] production_table() {return _production_table;}

  /** Parse-action table. */
  protected static final short[][] _action_table = 
    unpackFromStrings(new String[] {
    "\000\u017b\000\030\003\000\020\000\040\000\041\000\042" +
    "\000\043\000\044\000\045\000\047\000\050\000\052\000" +
    "\001\002\000\030\003\025\020\032\040\012\041\017\042" +
    "\013\043\031\044\016\045\033\047\030\050\027\052\022" +
    "\001\002\000\004\002\006\001\002\000\004\002\001\001" +
    "\002\000\006\016\uff77\101\271\001\002\000\032\002\uffeb" +
    "\003\025\020\032\040\012\041\017\042\013\043\031\044" +
    "\016\045\033\047\030\050\027\052\022\001\002\000\004" +
    "\105\u0176\001\002\000\004\004\u0152\001\002\000\004\004" +
    "\u015f\001\002\000\006\016\uff77\101\271\001\002\000\032" +
    "\002\uffef\003\025\020\032\040\012\041\017\042\013\043" +
    "\031\044\016\045\033\047\030\050\027\052\022\001\002" +
    "\000\004\004\267\001\002\000\004\004\266\001\002\000" +
    "\004\002\uffff\001\002\000\010\004\253\026\251\105\254" +
    "\001\002\000\006\016\uff64\101\uff64\001\002\000\032\002" +
    "\ufffb\003\025\020\032\040\012\041\017\042\013\043\031" +
    "\044\016\045\033\047\030\050\027\052\022\001\002\000" +
    "\032\002\ufffd\003\025\020\032\040\012\041\017\042\013" +
    "\043\031\044\016\045\033\047\030\050\027\052\022\001" +
    "\002\000\030\003\025\020\032\040\012\041\017\042\013" +
    "\043\031\044\016\045\033\047\030\050\027\052\022\001" +
    "\002\000\004\105\243\001\002\000\014\040\221\041\220" +
    "\042\217\043\216\044\214\001\002\000\010\040\201\042" +
    "\200\050\177\001\002\000\004\004\176\001\002\000\006" +
    "\021\172\022\171\001\002\000\004\004\170\001\002\000" +
    "\004\105\166\001\002\000\032\002\ufff1\003\025\020\032" +
    "\040\012\041\017\042\013\043\031\044\016\045\033\047" +
    "\030\050\027\052\022\001\002\000\010\004\040\026\037" +
    "\105\042\001\002\000\004\077\161\001\002\000\004\026" +
    "\044\001\002\000\100\002\uff3d\003\uff3d\004\uff3d\006\uff3d" +
    "\015\uff3d\017\uff3d\020\uff3d\025\uff3d\026\uff3d\037\uff3d\040" +
    "\uff3d\041\uff3d\042\uff3d\043\uff3d\044\uff3d\045\uff3d\047\uff3d" +
    "\050\uff3d\052\uff3d\053\uff3d\054\uff3d\056\uff3d\057\uff3d\061" +
    "\uff3d\063\uff3d\071\uff3d\072\uff3d\073\uff3d\074\uff3d\101\uff3d" +
    "\104\uff3d\001\002\000\032\002\ufff9\003\025\020\032\040" +
    "\012\041\017\042\013\043\031\044\016\045\033\047\030" +
    "\050\027\052\022\001\002\000\004\002\ufffa\001\002\000" +
    "\004\077\045\001\002\000\024\004\061\006\047\015\052" +
    "\025\054\041\064\053\051\054\057\101\062\104\055\001" +
    "\002\000\064\005\uffa4\006\uffa4\011\uffa4\012\uffa4\013\uffa4" +
    "\014\uffa4\017\uffa4\024\uffa4\027\uffa4\030\uffa4\031\uffa4\032" +
    "\uffa4\033\uffa4\034\uffa4\035\uffa4\036\uffa4\063\uffa4\065\uffa4" +
    "\066\uffa4\067\uffa4\070\uffa4\100\uffa4\102\uffa4\103\uffa4\105" +
    "\uffa4\001\002\000\010\015\052\041\064\101\156\001\002" +
    "\000\064\005\uffb4\006\uffb4\011\124\012\123\013\121\014" +
    "\122\017\uffb4\024\uffb4\027\uffb4\030\uffb4\031\uffb4\032\uffb4" +
    "\033\uffb4\034\uffb4\035\uffb4\036\uffb4\063\uffb4\065\uffb4\066" +
    "\uffb4\067\uffb4\070\uffb4\100\uffb4\102\uffb4\103\uffb4\105\uffb4" +
    "\001\002\000\064\005\uffa1\006\uffa1\011\uffa1\012\uffa1\013" +
    "\uffa1\014\uffa1\017\uffa1\024\uffa1\027\uffa1\030\uffa1\031\uffa1" +
    "\032\uffa1\033\uffa1\034\uffa1\035\uffa1\036\uffa1\063\uffa1\065" +
    "\uffa1\066\uffa1\067\uffa1\070\uffa1\100\uffa1\102\uffa1\103\uffa1" +
    "\105\uffa1\001\002\000\064\005\uffb6\006\uffb6\011\uffb6\012" +
    "\uffb6\013\uffb6\014\uffb6\017\uffb6\024\uffb6\027\uffb6\030\uffb6" +
    "\031\uffb6\032\uffb6\033\uffb6\034\uffb6\035\uffb6\036\uffb6\063" +
    "\uffb6\065\uffb6\066\uffb6\067\uffb6\070\uffb6\100\uffb6\102\uffb6" +
    "\103\uffb6\105\uffb6\001\002\000\012\005\102\006\100\024" +
    "\153\100\uff43\001\002\000\064\005\uffaa\006\uffaa\011\uffaa" +
    "\012\uffaa\013\uffaa\014\uffaa\017\uffaa\024\uffaa\027\uffaa\030" +
    "\uffaa\031\uffaa\032\uffaa\033\uffaa\034\uffaa\035\uffaa\036\uffaa" +
    "\063\uffaa\065\uffaa\066\uffaa\067\uffaa\070\uffaa\100\uffaa\102" +
    "\uffaa\103\uffaa\105\uffaa\001\002\000\064\005\uffa9\006\uffa9" +
    "\011\uffa9\012\uffa9\013\uffa9\014\uffa9\017\uffa9\024\uffa9\027" +
    "\uffa9\030\uffa9\031\uffa9\032\uffa9\033\uffa9\034\uffa9\035\uffa9" +
    "\036\uffa9\063\uffa9\065\uffa9\066\uffa9\067\uffa9\070\uffa9\100" +
    "\uffa9\102\uffa9\103\uffa9\105\uffa9\001\002\000\004\100\151" +
    "\001\002\000\064\005\uffa0\006\uffa0\011\uffa0\012\uffa0\013" +
    "\uffa0\014\uffa0\017\uffa0\024\uffa0\027\uffa0\030\uffa0\031\uffa0" +
    "\032\uffa0\033\uffa0\034\uffa0\035\uffa0\036\uffa0\063\uffa0\065" +
    "\uffa0\066\uffa0\067\uffa0\070\uffa0\100\uffa0\102\uffa0\103\uffa0" +
    "\105\uffa0\001\002\000\064\005\uffb1\006\uffb1\011\uffb1\012" +
    "\uffb1\013\uffb1\014\uffb1\017\uffb1\024\uffb1\027\uffb1\030\uffb1" +
    "\031\uffb1\032\uffb1\033\uffb1\034\uffb1\035\uffb1\036\uffb1\063" +
    "\uffb1\065\uffb1\066\uffb1\067\uffb1\070\uffb1\100\uffb1\102\uffb1" +
    "\103\uffb1\105\uffb1\001\002\000\074\005\uffa8\006\uffa8\007" +
    "\135\010\137\011\uffa8\012\uffa8\013\uffa8\014\uffa8\017\uffa8" +
    "\024\uffa8\027\uffa8\030\uffa8\031\uffa8\032\uffa8\033\uffa8\034" +
    "\uffa8\035\uffa8\036\uffa8\063\uffa8\065\uffa8\066\uffa8\067\uffa8" +
    "\070\uffa8\077\140\100\uffa8\101\136\102\uffa8\103\uffa8\105" +
    "\uffa8\001\002\000\026\004\061\006\047\015\052\025\054" +
    "\037\067\041\064\053\051\054\057\101\062\104\055\001" +
    "\002\000\064\005\uffac\006\uffac\011\uffac\012\uffac\013\uffac" +
    "\014\uffac\017\uffac\024\uffac\027\uffac\030\uffac\031\uffac\032" +
    "\uffac\033\uffac\034\uffac\035\uffac\036\uffac\063\uffac\065\uffac" +
    "\066\uffac\067\uffac\070\uffac\100\uffac\102\uffac\103\uffac\105" +
    "\uffac\001\002\000\064\005\uffb5\006\uffb5\011\uffb5\012\uffb5" +
    "\013\uffb5\014\uffb5\017\uffb5\024\uffb5\027\uffb5\030\uffb5\031" +
    "\uffb5\032\uffb5\033\uffb5\034\uffb5\035\uffb5\036\uffb5\063\uffb5" +
    "\065\uffb5\066\uffb5\067\uffb5\070\uffb5\100\uffb5\102\uffb5\103" +
    "\uffb5\105\uffb5\001\002\000\004\102\134\001\002\000\052" +
    "\005\102\006\100\017\uff97\024\uff97\027\101\030\077\031" +
    "\103\032\105\033\106\034\107\035\uff97\036\uff97\063\uff97" +
    "\065\uff97\066\uff97\067\uff97\070\uff97\102\uff97\103\uff97\105" +
    "\uff97\001\002\000\026\004\061\006\047\015\052\025\054" +
    "\037\067\041\064\053\051\054\057\101\062\104\055\001" +
    "\002\000\032\017\uff9b\024\uff9b\035\uff9b\036\uff9b\063\uff9b" +
    "\065\uff9b\066\uff9b\067\uff9b\070\uff9b\102\uff9b\103\uff9b\105" +
    "\uff9b\001\002\000\032\017\uff9e\024\uff9e\035\072\036\073" +
    "\063\uff9e\065\uff9e\066\uff9e\067\uff9e\070\uff9e\102\uff9e\103" +
    "\uff9e\105\uff9e\001\002\000\026\004\061\006\047\015\052" +
    "\025\054\037\067\041\064\053\051\054\057\101\062\104" +
    "\055\001\002\000\026\004\061\006\047\015\052\025\054" +
    "\037\067\041\064\053\051\054\057\101\062\104\055\001" +
    "\002\000\032\017\uff9c\024\uff9c\035\uff9c\036\uff9c\063\uff9c" +
    "\065\uff9c\066\uff9c\067\uff9c\070\uff9c\102\uff9c\103\uff9c\105" +
    "\uff9c\001\002\000\032\017\uff9d\024\uff9d\035\uff9d\036\uff9d" +
    "\063\uff9d\065\uff9d\066\uff9d\067\uff9d\070\uff9d\102\uff9d\103" +
    "\uff9d\105\uff9d\001\002\000\032\017\uff99\024\uff99\035\uff99" +
    "\036\uff99\063\uff99\065\uff99\066\uff99\067\uff99\070\uff99\102" +
    "\uff99\103\uff99\105\uff99\001\002\000\024\004\061\006\047" +
    "\015\052\025\054\041\064\053\051\054\057\101\062\104" +
    "\055\001\002\000\024\004\061\006\047\015\052\025\054" +
    "\041\064\053\051\054\057\101\062\104\055\001\002\000" +
    "\024\004\061\006\047\015\052\025\054\041\064\053\051" +
    "\054\057\101\062\104\055\001\002\000\024\004\061\006" +
    "\047\015\052\025\054\041\064\053\051\054\057\101\062" +
    "\104\055\001\002\000\024\004\061\006\047\015\052\025" +
    "\054\041\064\053\051\054\057\101\062\104\055\001\002" +
    "\000\046\017\uff95\024\uff95\027\101\030\077\031\103\032" +
    "\105\033\106\034\107\035\uff95\036\uff95\063\uff95\065\uff95" +
    "\066\uff95\067\uff95\070\uff95\102\uff95\103\uff95\105\uff95\001" +
    "\002\000\024\004\061\006\047\015\052\025\054\041\064" +
    "\053\051\054\057\101\062\104\055\001\002\000\024\004" +
    "\061\006\047\015\052\025\054\041\064\053\051\054\057" +
    "\101\062\104\055\001\002\000\024\004\061\006\047\015" +
    "\052\025\054\041\064\053\051\054\057\101\062\104\055" +
    "\001\002\000\032\017\uff9a\024\uff9a\035\uff9a\036\uff9a\063" +
    "\uff9a\065\uff9a\066\uff9a\067\uff9a\070\uff9a\102\uff9a\103\uff9a" +
    "\105\uff9a\001\002\000\052\005\102\006\100\017\uff90\024" +
    "\uff90\027\uff90\030\uff90\031\uff90\032\uff90\033\uff90\034\uff90" +
    "\035\uff90\036\uff90\063\uff90\065\uff90\066\uff90\067\uff90\070" +
    "\uff90\102\uff90\103\uff90\105\uff90\001\002\000\052\005\102" +
    "\006\100\017\uff8f\024\uff8f\027\uff8f\030\uff8f\031\uff8f\032" +
    "\uff8f\033\uff8f\034\uff8f\035\uff8f\036\uff8f\063\uff8f\065\uff8f" +
    "\066\uff8f\067\uff8f\070\uff8f\102\uff8f\103\uff8f\105\uff8f\001" +
    "\002\000\052\005\102\006\100\017\uff93\024\uff93\027\uff93" +
    "\030\uff93\031\uff93\032\uff93\033\uff93\034\uff93\035\uff93\036" +
    "\uff93\063\uff93\065\uff93\066\uff93\067\uff93\070\uff93\102\uff93" +
    "\103\uff93\105\uff93\001\002\000\046\017\uff95\024\uff95\027" +
    "\101\030\077\031\103\032\105\033\106\034\107\035\uff95" +
    "\036\uff95\063\uff95\065\uff95\066\uff95\067\uff95\070\uff95\102" +
    "\uff95\103\uff95\105\uff95\001\002\000\032\017\uff98\024\uff98" +
    "\035\uff98\036\uff98\063\uff98\065\uff98\066\uff98\067\uff98\070" +
    "\uff98\102\uff98\103\uff98\105\uff98\001\002\000\032\017\uff96" +
    "\024\uff96\035\uff96\036\uff96\063\uff96\065\uff96\066\uff96\067" +
    "\uff96\070\uff96\102\uff96\103\uff96\105\uff96\001\002\000\052" +
    "\005\102\006\100\017\uff92\024\uff92\027\uff92\030\uff92\031" +
    "\uff92\032\uff92\033\uff92\034\uff92\035\uff92\036\uff92\063\uff92" +
    "\065\uff92\066\uff92\067\uff92\070\uff92\102\uff92\103\uff92\105" +
    "\uff92\001\002\000\064\005\uffb3\006\uffb3\011\124\012\123" +
    "\013\121\014\122\017\uffb3\024\uffb3\027\uffb3\030\uffb3\031" +
    "\uffb3\032\uffb3\033\uffb3\034\uffb3\035\uffb3\036\uffb3\063\uffb3" +
    "\065\uffb3\066\uffb3\067\uffb3\070\uffb3\100\uffb3\102\uffb3\103" +
    "\uffb3\105\uffb3\001\002\000\024\004\061\006\047\015\052" +
    "\025\054\041\064\053\051\054\057\101\062\104\055\001" +
    "\002\000\024\004\061\006\047\015\052\025\054\041\064" +
    "\053\051\054\057\101\062\104\055\001\002\000\024\004" +
    "\061\006\047\015\052\025\054\041\064\053\051\054\057" +
    "\101\062\104\055\001\002\000\024\004\061\006\047\015" +
    "\052\025\054\041\064\053\051\054\057\101\062\104\055" +
    "\001\002\000\064\005\uffb0\006\uffb0\011\uffb0\012\uffb0\013" +
    "\uffb0\014\uffb0\017\uffb0\024\uffb0\027\uffb0\030\uffb0\031\uffb0" +
    "\032\uffb0\033\uffb0\034\uffb0\035\uffb0\036\uffb0\063\uffb0\065" +
    "\uffb0\066\uffb0\067\uffb0\070\uffb0\100\uffb0\102\uffb0\103\uffb0" +
    "\105\uffb0\001\002\000\064\005\uffaf\006\uffaf\011\uffaf\012" +
    "\uffaf\013\uffaf\014\uffaf\017\uffaf\024\uffaf\027\uffaf\030\uffaf" +
    "\031\uffaf\032\uffaf\033\uffaf\034\uffaf\035\uffaf\036\uffaf\063" +
    "\uffaf\065\uffaf\066\uffaf\067\uffaf\070\uffaf\100\uffaf\102\uffaf" +
    "\103\uffaf\105\uffaf\001\002\000\064\005\uffae\006\uffae\011" +
    "\uffae\012\uffae\013\uffae\014\uffae\017\uffae\024\uffae\027\uffae" +
    "\030\uffae\031\uffae\032\uffae\033\uffae\034\uffae\035\uffae\036" +
    "\uffae\063\uffae\065\uffae\066\uffae\067\uffae\070\uffae\100\uffae" +
    "\102\uffae\103\uffae\105\uffae\001\002\000\064\005\uffad\006" +
    "\uffad\011\uffad\012\uffad\013\uffad\014\uffad\017\uffad\024\uffad" +
    "\027\uffad\030\uffad\031\uffad\032\uffad\033\uffad\034\uffad\035" +
    "\uffad\036\uffad\063\uffad\065\uffad\066\uffad\067\uffad\070\uffad" +
    "\100\uffad\102\uffad\103\uffad\105\uffad\001\002\000\052\005" +
    "\102\006\100\017\uff94\024\uff94\027\uff94\030\uff94\031\uff94" +
    "\032\uff94\033\uff94\034\uff94\035\uff94\036\uff94\063\uff94\065" +
    "\uff94\066\uff94\067\uff94\070\uff94\102\uff94\103\uff94\105\uff94" +
    "\001\002\000\064\005\uffb2\006\uffb2\011\124\012\123\013" +
    "\121\014\122\017\uffb2\024\uffb2\027\uffb2\030\uffb2\031\uffb2" +
    "\032\uffb2\033\uffb2\034\uffb2\035\uffb2\036\uffb2\063\uffb2\065" +
    "\uffb2\066\uffb2\067\uffb2\070\uffb2\100\uffb2\102\uffb2\103\uffb2" +
    "\105\uffb2\001\002\000\052\005\102\006\100\017\uff91\024" +
    "\uff91\027\uff91\030\uff91\031\uff91\032\uff91\033\uff91\034\uff91" +
    "\035\uff91\036\uff91\063\uff91\065\uff91\066\uff91\067\uff91\070" +
    "\uff91\102\uff91\103\uff91\105\uff91\001\002\000\064\005\uffa2" +
    "\006\uffa2\011\uffa2\012\uffa2\013\uffa2\014\uffa2\017\uffa2\024" +
    "\uffa2\027\uffa2\030\uffa2\031\uffa2\032\uffa2\033\uffa2\034\uffa2" +
    "\035\uffa2\036\uffa2\063\uffa2\065\uffa2\066\uffa2\067\uffa2\070" +
    "\uffa2\100\uffa2\102\uffa2\103\uffa2\105\uffa2\001\002\000\064" +
    "\005\uffa7\006\uffa7\011\uffa7\012\uffa7\013\uffa7\014\uffa7\017" +
    "\uffa7\024\uffa7\027\uffa7\030\uffa7\031\uffa7\032\uffa7\033\uffa7" +
    "\034\uffa7\035\uffa7\036\uffa7\063\uffa7\065\uffa7\066\uffa7\067" +
    "\uffa7\070\uffa7\100\uffa7\102\uffa7\103\uffa7\105\uffa7\001\002" +
    "\000\030\004\061\006\047\015\052\025\054\037\067\041" +
    "\064\053\051\054\057\101\062\102\uff69\104\055\001\002" +
    "\000\064\005\uffa6\006\uffa6\011\uffa6\012\uffa6\013\uffa6\014" +
    "\uffa6\017\uffa6\024\uffa6\027\uffa6\030\uffa6\031\uffa6\032\uffa6" +
    "\033\uffa6\034\uffa6\035\uffa6\036\uffa6\063\uffa6\065\uffa6\066" +
    "\uffa6\067\uffa6\070\uffa6\100\uffa6\102\uffa6\103\uffa6\105\uffa6" +
    "\001\002\000\024\004\061\006\047\015\052\025\054\041" +
    "\064\053\051\054\057\101\062\104\055\001\002\000\010" +
    "\005\102\006\100\100\142\001\002\000\066\005\uff3c\006" +
    "\uff3c\011\uff3c\012\uff3c\013\uff3c\014\uff3c\017\uff3c\024\uff3c" +
    "\026\uff3c\027\uff3c\030\uff3c\031\uff3c\032\uff3c\033\uff3c\034" +
    "\uff3c\035\uff3c\036\uff3c\063\uff3c\065\uff3c\066\uff3c\067\uff3c" +
    "\070\uff3c\100\uff3c\102\uff3c\103\uff3c\105\uff3c\001\002\000" +
    "\006\024\147\102\uff68\001\002\000\004\102\uff6a\001\002" +
    "\000\004\102\146\001\002\000\064\005\uffa5\006\uffa5\011" +
    "\uffa5\012\uffa5\013\uffa5\014\uffa5\017\uffa5\024\uffa5\027\uffa5" +
    "\030\uffa5\031\uffa5\032\uffa5\033\uffa5\034\uffa5\035\uffa5\036" +
    "\uffa5\063\uffa5\065\uffa5\066\uffa5\067\uffa5\070\uffa5\100\uffa5" +
    "\102\uffa5\103\uffa5\105\uffa5\001\002\000\026\004\061\006" +
    "\047\015\052\025\054\037\067\041\064\053\051\054\057" +
    "\101\062\104\055\001\002\000\004\102\uff67\001\002\000" +
    "\004\105\152\001\002\000\100\002\uff46\003\uff46\004\uff46" +
    "\006\uff46\015\uff46\017\uff46\020\uff46\025\uff46\026\uff46\037" +
    "\uff46\040\uff46\041\uff46\042\uff46\043\uff46\044\uff46\045\uff46" +
    "\047\uff46\050\uff46\052\uff46\053\uff46\054\uff46\056\uff46\057" +
    "\uff46\061\uff46\063\uff46\071\uff46\072\uff46\073\uff46\074\uff46" +
    "\101\uff46\104\uff46\001\002\000\024\004\061\006\047\015" +
    "\052\025\054\041\064\053\051\054\057\101\062\104\055" +
    "\001\002\000\004\100\uff44\001\002\000\064\005\uffab\006" +
    "\uffab\011\uffab\012\uffab\013\uffab\014\uffab\017\uffab\024\uffab" +
    "\027\uffab\030\uffab\031\uffab\032\uffab\033\uffab\034\uffab\035" +
    "\uffab\036\uffab\063\uffab\065\uffab\066\uffab\067\uffab\070\uffab" +
    "\100\uffab\102\uffab\103\uffab\105\uffab\001\002\000\026\004" +
    "\061\006\047\015\052\025\054\037\067\041\064\053\051" +
    "\054\057\101\062\104\055\001\002\000\004\102\160\001" +
    "\002\000\064\005\uffa3\006\uffa3\011\uffa3\012\uffa3\013\uffa3" +
    "\014\uffa3\017\uffa3\024\uffa3\027\uffa3\030\uffa3\031\uffa3\032" +
    "\uffa3\033\uffa3\034\uffa3\035\uffa3\036\uffa3\063\uffa3\065\uffa3" +
    "\066\uffa3\067\uffa3\070\uffa3\100\uffa3\102\uffa3\103\uffa3\105" +
    "\uffa3\001\002\000\024\004\061\006\047\015\052\025\054" +
    "\041\064\053\051\054\057\101\062\104\055\001\002\000" +
    "\004\100\163\001\002\000\004\105\164\001\002\000\100" +
    "\002\uff45\003\uff45\004\uff45\006\uff45\015\uff45\017\uff45\020" +
    "\uff45\025\uff45\026\uff45\037\uff45\040\uff45\041\uff45\042\uff45" +
    "\043\uff45\044\uff45\045\uff45\047\uff45\050\uff45\052\uff45\053" +
    "\uff45\054\uff45\056\uff45\057\uff45\061\uff45\063\uff45\071\uff45" +
    "\072\uff45\073\uff45\074\uff45\101\uff45\104\uff45\001\002\000" +
    "\004\002\ufff2\001\002\000\032\002\uffed\003\025\020\032" +
    "\040\012\041\017\042\013\043\031\044\016\045\033\047" +
    "\030\050\027\052\022\001\002\000\004\002\uffee\001\002" +
    "\000\006\016\uff7c\101\uff7c\001\002\000\006\021\uffb7\022" +
    "\uffb7\001\002\000\100\002\uffb9\003\uffb9\004\uffb9\006\uffb9" +
    "\015\uffb9\017\uffb9\020\uffb9\025\uffb9\026\uffb9\037\uffb9\040" +
    "\uffb9\041\uffb9\042\uffb9\043\uffb9\044\uffb9\045\uffb9\047\uffb9" +
    "\050\uffb9\052\uffb9\053\uffb9\054\uffb9\056\uffb9\057\uffb9\061" +
    "\uffb9\063\uffb9\071\uffb9\072\uffb9\073\uffb9\074\uffb9\101\uffb9" +
    "\104\uffb9\001\002\000\006\021\175\022\174\001\002\000" +
    "\006\021\uffb8\022\uffb8\001\002\000\100\002\uffba\003\uffba" +
    "\004\uffba\006\uffba\015\uffba\017\uffba\020\uffba\025\uffba\026" +
    "\uffba\037\uffba\040\uffba\041\uffba\042\uffba\043\uffba\044\uffba" +
    "\045\uffba\047\uffba\050\uffba\052\uffba\053\uffba\054\uffba\056" +
    "\uffba\057\uffba\061\uffba\063\uffba\071\uffba\072\uffba\073\uffba" +
    "\074\uffba\101\uffba\104\uffba\001\002\000\006\016\uff7f\101" +
    "\uff7f\001\002\000\014\040\221\041\220\042\217\043\216" +
    "\044\214\001\002\000\004\046\207\001\002\000\004\046" +
    "\202\001\002\000\004\004\203\001\002\000\004\077\204" +
    "\001\002\000\004\015\205\001\002\000\004\100\206\001" +
    "\002\000\010\004\uff4a\026\uff4a\105\uff4a\001\002\000\004" +
    "\004\210\001\002\000\004\077\211\001\002\000\004\015" +
    "\212\001\002\000\004\100\213\001\002\000\010\004\uff49" +
    "\026\uff49\105\uff49\001\002\000\004\004\uff8a\001\002\000" +
    "\004\004\222\001\002\000\004\004\uff8b\001\002\000\004" +
    "\004\uff8d\001\002\000\004\004\uff8c\001\002\000\004\004" +
    "\uff8e\001\002\000\010\004\uff84\026\uff84\105\uff84\001\002" +
    "\000\004\004\224\001\002\000\012\004\uff86\026\225\077" +
    "\226\105\uff86\001\002\000\026\004\061\006\047\015\052" +
    "\025\054\037\067\041\064\053\051\054\057\101\062\104" +
    "\055\001\002\000\004\015\227\001\002\000\004\100\230" +
    "\001\002\000\006\026\231\105\uff48\001\002\000\004\016" +
    "\233\001\002\000\004\105\uff47\001\002\000\030\004\061" +
    "\006\047\015\052\017\235\025\054\037\067\041\064\053" +
    "\051\054\057\101\062\104\055\001\002\000\006\017\uff3f" +
    "\024\240\001\002\000\004\105\uff41\001\002\000\004\017" +
    "\237\001\002\000\004\105\uff42\001\002\000\026\004\061" +
    "\006\047\015\052\025\054\037\067\041\064\053\051\054" +
    "\057\101\062\104\055\001\002\000\004\017\uff40\001\002" +
    "\000\004\105\uff85\001\002\000\032\002\ufff3\003\025\020" +
    "\032\040\012\041\017\042\013\043\031\044\016\045\033" +
    "\047\030\050\027\052\022\001\002\000\004\002\ufff4\001" +
    "\002\000\004\002\uffea\001\002\000\004\002\ufffe\001\002" +
    "\000\004\002\ufffc\001\002\000\100\002\uff82\003\uff82\004" +
    "\uff82\006\uff82\015\uff82\017\uff82\020\uff82\025\uff82\026\uff82" +
    "\037\uff82\040\uff82\041\uff82\042\uff82\043\uff82\044\uff82\045" +
    "\uff82\047\uff82\050\uff82\052\uff82\053\uff82\054\uff82\056\uff82" +
    "\057\uff82\061\uff82\063\uff82\071\uff82\072\uff82\073\uff82\074" +
    "\uff82\101\uff82\104\uff82\001\002\000\026\004\061\006\047" +
    "\015\052\025\054\037\067\041\064\053\051\054\057\101" +
    "\062\104\055\001\002\000\004\026\261\001\002\000\006" +
    "\026\256\077\140\001\002\000\032\002\ufff7\003\025\020" +
    "\032\040\012\041\017\042\013\043\031\044\016\045\033" +
    "\047\030\050\027\052\022\001\002\000\004\002\ufff8\001" +
    "\002\000\026\004\061\006\047\015\052\025\054\037\067" +
    "\041\064\053\051\054\057\101\062\104\055\001\002\000" +
    "\004\105\260\001\002\000\100\002\uff89\003\uff89\004\uff89" +
    "\006\uff89\015\uff89\017\uff89\020\uff89\025\uff89\026\uff89\037" +
    "\uff89\040\uff89\041\uff89\042\uff89\043\uff89\044\uff89\045\uff89" +
    "\047\uff89\050\uff89\052\uff89\053\uff89\054\uff89\056\uff89\057" +
    "\uff89\061\uff89\063\uff89\071\uff89\072\uff89\073\uff89\074\uff89" +
    "\101\uff89\104\uff89\001\002\000\026\004\061\006\047\015" +
    "\052\025\054\037\067\041\064\053\051\054\057\101\062" +
    "\104\055\001\002\000\004\105\263\001\002\000\100\002" +
    "\uff88\003\uff88\004\uff88\006\uff88\015\uff88\017\uff88\020\uff88" +
    "\025\uff88\026\uff88\037\uff88\040\uff88\041\uff88\042\uff88\043" +
    "\uff88\044\uff88\045\uff88\047\uff88\050\uff88\052\uff88\053\uff88" +
    "\054\uff88\056\uff88\057\uff88\061\uff88\063\uff88\071\uff88\072" +
    "\uff88\073\uff88\074\uff88\101\uff88\104\uff88\001\002\000\004" +
    "\105\265\001\002\000\100\002\uff87\003\uff87\004\uff87\006" +
    "\uff87\015\uff87\017\uff87\020\uff87\025\uff87\026\uff87\037\uff87" +
    "\040\uff87\041\uff87\042\uff87\043\uff87\044\uff87\045\uff87\047" +
    "\uff87\050\uff87\052\uff87\053\uff87\054\uff87\056\uff87\057\uff87" +
    "\061\uff87\063\uff87\071\uff87\072\uff87\073\uff87\074\uff87\101" +
    "\uff87\104\uff87\001\002\000\006\016\uff7d\101\uff7d\001\002" +
    "\000\006\016\uff7e\101\uff7e\001\002\000\004\002\ufff0\001" +
    "\002\000\020\016\uff75\040\u0166\041\u016d\042\u016c\043\u0168" +
    "\044\u0169\102\u016a\001\002\000\004\016\uff66\001\002\000" +
    "\004\016\275\001\002\000\072\003\322\004\341\006\047" +
    "\015\052\020\032\025\054\026\251\037\067\040\304\041" +
    "\332\042\300\043\031\044\016\045\033\047\030\050\027" +
    "\052\022\053\051\054\057\056\307\057\313\061\315\071" +
    "\324\072\316\073\302\074\301\101\062\104\055\001\002" +
    "\000\074\003\uff6b\004\uff6b\006\uff6b\015\uff6b\020\uff6b\025" +
    "\uff6b\026\uff6b\037\uff6b\040\uff6b\041\uff6b\042\uff6b\043\uff6b" +
    "\044\uff6b\045\uff6b\047\uff6b\050\uff6b\052\uff6b\053\uff6b\054" +
    "\uff6b\056\uff6b\057\uff6b\061\uff6b\071\uff6b\072\uff6b\073\uff6b" +
    "\074\uff6b\101\uff6b\102\276\104\uff6b\001\002\000\072\003" +
    "\uff6c\004\uff6c\006\uff6c\015\uff6c\020\uff6c\025\uff6c\026\uff6c" +
    "\037\uff6c\040\uff6c\041\uff6c\042\uff6c\043\uff6c\044\uff6c\045" +
    "\uff6c\047\uff6c\050\uff6c\052\uff6c\053\uff6c\054\uff6c\056\uff6c" +
    "\057\uff6c\061\uff6c\071\uff6c\072\uff6c\073\uff6c\074\uff6c\101" +
    "\uff6c\104\uff6c\001\002\000\072\003\uff6d\004\uff6d\006\uff6d" +
    "\015\uff6d\020\uff6d\025\uff6d\026\uff6d\037\uff6d\040\uff6d\041" +
    "\uff6d\042\uff6d\043\uff6d\044\uff6d\045\uff6d\047\uff6d\050\uff6d" +
    "\052\uff6d\053\uff6d\054\uff6d\056\uff6d\057\uff6d\061\uff6d\071" +
    "\uff6d\072\uff6d\073\uff6d\074\uff6d\101\uff6d\104\uff6d\001\002" +
    "\000\006\004\u015f\046\u0160\001\002\000\004\101\u015c\001" +
    "\002\000\004\101\u0158\001\002\000\074\004\uffcd\006\uffcd" +
    "\015\uffcd\017\uffcd\020\uffcd\025\uffcd\026\uffcd\037\uffcd\040" +
    "\uffcd\041\uffcd\042\uffcd\043\uffcd\044\uffcd\045\uffcd\047\uffcd" +
    "\050\uffcd\052\uffcd\053\uffcd\054\uffcd\056\uffcd\057\uffcd\061" +
    "\uffcd\063\uffcd\071\uffcd\072\uffcd\073\uffcd\074\uffcd\101\uffcd" +
    "\104\uffcd\001\002\000\006\004\u0152\046\u0153\001\002\000" +
    "\074\004\uffc8\006\uffc8\015\uffc8\017\uffc8\020\uffc8\025\uffc8" +
    "\026\uffc8\037\uffc8\040\uffc8\041\uffc8\042\uffc8\043\uffc8\044" +
    "\uffc8\045\uffc8\047\uffc8\050\uffc8\052\uffc8\053\uffc8\054\uffc8" +
    "\056\uffc8\057\uffc8\061\uffc8\063\uffc8\071\uffc8\072\uffc8\073" +
    "\uffc8\074\uffc8\101\uffc8\104\uffc8\001\002\000\074\004\uffc3" +
    "\006\uffc3\015\uffc3\017\uffc3\020\uffc3\025\uffc3\026\uffc3\037" +
    "\uffc3\040\uffc3\041\uffc3\042\uffc3\043\uffc3\044\uffc3\045\uffc3" +
    "\047\uffc3\050\uffc3\052\uffc3\053\uffc3\054\uffc3\056\uffc3\057" +
    "\uffc3\061\uffc3\063\uffc3\071\uffc3\072\uffc3\073\uffc3\074\uffc3" +
    "\101\uffc3\104\uffc3\001\002\000\004\004\u013c\001\002\000" +
    "\074\004\uffcf\006\uffcf\015\uffcf\017\uffcf\020\uffcf\025\uffcf" +
    "\026\uffcf\037\uffcf\040\uffcf\041\uffcf\042\uffcf\043\uffcf\044" +
    "\uffcf\045\uffcf\047\uffcf\050\uffcf\052\uffcf\053\uffcf\054\uffcf" +
    "\056\uffcf\057\uffcf\061\uffcf\063\uffcf\071\uffcf\072\uffcf\073" +
    "\uffcf\074\uffcf\101\uffcf\104\uffcf\001\002\000\010\004\040" +
    "\026\037\105\u0139\001\002\000\004\105\u0138\001\002\000" +
    "\004\060\u0123\001\002\000\072\004\341\006\047\015\052" +
    "\017\u0122\020\032\025\054\026\251\037\067\040\304\041" +
    "\332\042\300\043\031\044\016\045\033\047\030\050\027" +
    "\052\022\053\051\054\057\056\307\057\313\061\315\071" +
    "\u010a\072\u0106\073\302\074\301\101\062\104\055\001\002" +
    "\000\072\003\uff5a\004\uff5a\006\uff5a\015\uff5a\020\uff5a\025" +
    "\uff5a\026\uff5a\037\uff5a\040\uff5a\041\uff5a\042\uff5a\043\uff5a" +
    "\044\uff5a\045\uff5a\047\uff5a\050\uff5a\052\uff5a\053\uff5a\054" +
    "\uff5a\056\uff5a\057\uff5a\061\uff5a\071\uff5a\072\uff5a\073\uff5a" +
    "\074\uff5a\101\uff5a\104\uff5a\001\002\000\030\004\061\006" +
    "\047\015\052\025\054\037\067\041\064\053\051\054\057" +
    "\101\062\104\055\105\352\001\002\000\074\004\uffc2\006" +
    "\uffc2\015\uffc2\017\uffc2\020\uffc2\025\uffc2\026\uffc2\037\uffc2" +
    "\040\uffc2\041\uffc2\042\uffc2\043\uffc2\044\uffc2\045\uffc2\047" +
    "\uffc2\050\uffc2\052\uffc2\053\uffc2\054\uffc2\056\uffc2\057\uffc2" +
    "\061\uffc2\063\uffc2\071\uffc2\072\uffc2\073\uffc2\074\uffc2\101" +
    "\uffc2\104\uffc2\001\002\000\074\004\uffc9\006\uffc9\015\uffc9" +
    "\017\uffc9\020\uffc9\025\uffc9\026\uffc9\037\uffc9\040\uffc9\041" +
    "\uffc9\042\uffc9\043\uffc9\044\uffc9\045\uffc9\047\uffc9\050\uffc9" +
    "\052\uffc9\053\uffc9\054\uffc9\056\uffc9\057\uffc9\061\uffc9\063" +
    "\uffc9\071\uffc9\072\uffc9\073\uffc9\074\uffc9\101\uffc9\104\uffc9" +
    "\001\002\000\074\004\uffca\006\uffca\015\uffca\017\uffca\020" +
    "\uffca\025\uffca\026\uffca\037\uffca\040\uffca\041\uffca\042\uffca" +
    "\043\uffca\044\uffca\045\uffca\047\uffca\050\uffca\052\uffca\053" +
    "\uffca\054\uffca\056\uffca\057\uffca\061\uffca\063\uffca\071\uffca" +
    "\072\uffca\073\uffca\074\uffca\101\uffca\104\uffca\001\002\000" +
    "\074\004\uffbb\006\uffbb\015\uffbb\017\uffbb\020\uffbb\025\uffbb" +
    "\026\uffbb\037\uffbb\040\uffbb\041\uffbb\042\uffbb\043\uffbb\044" +
    "\uffbb\045\uffbb\047\uffbb\050\uffbb\052\uffbb\053\uffbb\054\uffbb" +
    "\056\uffbb\057\uffbb\061\uffbb\063\uffbb\071\uffbb\072\uffbb\073" +
    "\uffbb\074\uffbb\101\uffbb\104\uffbb\001\002\000\010\004\253" +
    "\026\251\105\351\001\002\000\004\105\347\001\002\000" +
    "\004\105\346\001\002\000\074\004\uffbd\006\uffbd\015\uffbd" +
    "\017\uffbd\020\uffbd\025\uffbd\026\uffbd\037\uffbd\040\uffbd\041" +
    "\uffbd\042\uffbd\043\uffbd\044\uffbd\045\uffbd\047\uffbd\050\uffbd" +
    "\052\uffbd\053\uffbd\054\uffbd\056\uffbd\057\uffbd\061\uffbd\063" +
    "\uffbd\071\uffbd\072\uffbd\073\uffbd\074\uffbd\101\uffbd\104\uffbd" +
    "\001\002\000\074\004\uffce\006\uffce\015\uffce\017\uffce\020" +
    "\uffce\025\uffce\026\uffce\037\uffce\040\uffce\041\uffce\042\uffce" +
    "\043\uffce\044\uffce\045\uffce\047\uffce\050\uffce\052\uffce\053" +
    "\uffce\054\uffce\056\uffce\057\uffce\061\uffce\063\uffce\071\uffce" +
    "\072\uffce\073\uffce\074\uffce\101\uffce\104\uffce\001\002\000" +
    "\044\005\uffa4\006\uffa4\011\uffa4\012\uffa4\013\uffa4\014\uffa4" +
    "\026\261\027\uffa4\030\uffa4\031\uffa4\032\uffa4\033\uffa4\034" +
    "\uffa4\035\uffa4\036\uffa4\063\uffa4\105\uffa4\001\002\000\074" +
    "\004\uffd0\006\uffd0\015\uffd0\017\uffd0\020\uffd0\025\uffd0\026" +
    "\uffd0\037\uffd0\040\uffd0\041\uffd0\042\uffd0\043\uffd0\044\uffd0" +
    "\045\uffd0\047\uffd0\050\uffd0\052\uffd0\053\uffd0\054\uffd0\056" +
    "\uffd0\057\uffd0\061\uffd0\063\uffd0\071\uffd0\072\uffd0\073\uffd0" +
    "\074\uffd0\101\uffd0\104\uffd0\001\002\000\044\004\266\005" +
    "\uffb5\006\uffb5\011\uffb5\012\uffb5\013\uffb5\014\uffb5\027\uffb5" +
    "\030\uffb5\031\uffb5\032\uffb5\033\uffb5\034\uffb5\035\uffb5\036" +
    "\uffb5\063\uffb5\105\uffb5\001\002\000\010\004\253\026\251" +
    "\105\345\001\002\000\010\004\040\026\037\105\344\001" +
    "\002\000\074\004\uffbc\006\uffbc\015\uffbc\017\uffbc\020\uffbc" +
    "\025\uffbc\026\uffbc\037\uffbc\040\uffbc\041\uffbc\042\uffbc\043" +
    "\uffbc\044\uffbc\045\uffbc\047\uffbc\050\uffbc\052\uffbc\053\uffbc" +
    "\054\uffbc\056\uffbc\057\uffbc\061\uffbc\063\uffbc\071\uffbc\072" +
    "\uffbc\073\uffbc\074\uffbc\101\uffbc\104\uffbc\001\002\000\004" +
    "\105\343\001\002\000\004\105\342\001\002\000\074\004" +
    "\uffc4\006\uffc4\015\uffc4\017\uffc4\020\uffc4\025\uffc4\026\uffc4" +
    "\037\uffc4\040\uffc4\041\uffc4\042\uffc4\043\uffc4\044\uffc4\045" +
    "\uffc4\047\uffc4\050\uffc4\052\uffc4\053\uffc4\054\uffc4\056\uffc4" +
    "\057\uffc4\061\uffc4\063\uffc4\071\uffc4\072\uffc4\073\uffc4\074" +
    "\uffc4\101\uffc4\104\uffc4\001\002\000\054\005\uffa8\006\uffa8" +
    "\007\135\010\137\011\uffa8\012\uffa8\013\uffa8\014\uffa8\026" +
    "\256\027\uffa8\030\uffa8\031\uffa8\032\uffa8\033\uffa8\034\uffa8" +
    "\035\uffa8\036\uffa8\063\uffa8\077\140\101\136\105\uffa8\001" +
    "\002\000\074\004\uffc6\006\uffc6\015\uffc6\017\uffc6\020\uffc6" +
    "\025\uffc6\026\uffc6\037\uffc6\040\uffc6\041\uffc6\042\uffc6\043" +
    "\uffc6\044\uffc6\045\uffc6\047\uffc6\050\uffc6\052\uffc6\053\uffc6" +
    "\054\uffc6\056\uffc6\057\uffc6\061\uffc6\063\uffc6\071\uffc6\072" +
    "\uffc6\073\uffc6\074\uffc6\101\uffc6\104\uffc6\001\002\000\074" +
    "\004\uffc5\006\uffc5\015\uffc5\017\uffc5\020\uffc5\025\uffc5\026" +
    "\uffc5\037\uffc5\040\uffc5\041\uffc5\042\uffc5\043\uffc5\044\uffc5" +
    "\045\uffc5\047\uffc5\050\uffc5\052\uffc5\053\uffc5\054\uffc5\056" +
    "\uffc5\057\uffc5\061\uffc5\063\uffc5\071\uffc5\072\uffc5\073\uffc5" +
    "\074\uffc5\101\uffc5\104\uffc5\001\002\000\074\004\uffcc\006" +
    "\uffcc\015\uffcc\017\uffcc\020\uffcc\025\uffcc\026\uffcc\037\uffcc" +
    "\040\uffcc\041\uffcc\042\uffcc\043\uffcc\044\uffcc\045\uffcc\047" +
    "\uffcc\050\uffcc\052\uffcc\053\uffcc\054\uffcc\056\uffcc\057\uffcc" +
    "\061\uffcc\063\uffcc\071\uffcc\072\uffcc\073\uffcc\074\uffcc\101" +
    "\uffcc\104\uffcc\001\002\000\074\004\uffcb\006\uffcb\015\uffcb" +
    "\017\uffcb\020\uffcb\025\uffcb\026\uffcb\037\uffcb\040\uffcb\041" +
    "\uffcb\042\uffcb\043\uffcb\044\uffcb\045\uffcb\047\uffcb\050\uffcb" +
    "\052\uffcb\053\uffcb\054\uffcb\056\uffcb\057\uffcb\061\uffcb\063" +
    "\uffcb\071\uffcb\072\uffcb\073\uffcb\074\uffcb\101\uffcb\104\uffcb" +
    "\001\002\000\074\004\uffd2\006\uffd2\015\uffd2\017\uffd2\020" +
    "\uffd2\025\uffd2\026\uffd2\037\uffd2\040\uffd2\041\uffd2\042\uffd2" +
    "\043\uffd2\044\uffd2\045\uffd2\047\uffd2\050\uffd2\052\uffd2\053" +
    "\uffd2\054\uffd2\056\uffd2\057\uffd2\061\uffd2\063\uffd2\071\uffd2" +
    "\072\uffd2\073\uffd2\074\uffd2\101\uffd2\104\uffd2\001\002\000" +
    "\074\004\uffc0\006\uffc0\015\uffc0\017\uffc0\020\uffc0\025\uffc0" +
    "\026\uffc0\037\uffc0\040\uffc0\041\uffc0\042\uffc0\043\uffc0\044" +
    "\uffc0\045\uffc0\047\uffc0\050\uffc0\052\uffc0\053\uffc0\054\uffc0" +
    "\056\uffc0\057\uffc0\061\uffc0\063\uffc0\071\uffc0\072\uffc0\073" +
    "\uffc0\074\uffc0\101\uffc0\104\uffc0\001\002\000\074\004\uff83" +
    "\006\uff83\015\uff83\017\uff83\020\uff83\025\uff83\026\uff83\037" +
    "\uff83\040\uff83\041\uff83\042\uff83\043\uff83\044\uff83\045\uff83" +
    "\047\uff83\050\uff83\052\uff83\053\uff83\054\uff83\056\uff83\057" +
    "\uff83\061\uff83\063\uff83\071\uff83\072\uff83\073\uff83\074\uff83" +
    "\101\uff83\104\uff83\001\002\000\074\004\uffc7\006\uffc7\015" +
    "\uffc7\017\uffc7\020\uffc7\025\uffc7\026\uffc7\037\uffc7\040\uffc7" +
    "\041\uffc7\042\uffc7\043\uffc7\044\uffc7\045\uffc7\047\uffc7\050" +
    "\uffc7\052\uffc7\053\uffc7\054\uffc7\056\uffc7\057\uffc7\061\uffc7" +
    "\063\uffc7\071\uffc7\072\uffc7\073\uffc7\074\uffc7\101\uffc7\104" +
    "\uffc7\001\002\000\074\004\uffbe\006\uffbe\015\uffbe\017\uffbe" +
    "\020\uffbe\025\uffbe\026\uffbe\037\uffbe\040\uffbe\041\uffbe\042" +
    "\uffbe\043\uffbe\044\uffbe\045\uffbe\047\uffbe\050\uffbe\052\uffbe" +
    "\053\uffbe\054\uffbe\056\uffbe\057\uffbe\061\uffbe\063\uffbe\071" +
    "\uffbe\072\uffbe\073\uffbe\074\uffbe\101\uffbe\104\uffbe\001\002" +
    "\000\004\105\354\001\002\000\074\004\uffbf\006\uffbf\015" +
    "\uffbf\017\uffbf\020\uffbf\025\uffbf\026\uffbf\037\uffbf\040\uffbf" +
    "\041\uffbf\042\uffbf\043\uffbf\044\uffbf\045\uffbf\047\uffbf\050" +
    "\uffbf\052\uffbf\053\uffbf\054\uffbf\056\uffbf\057\uffbf\061\uffbf" +
    "\063\uffbf\071\uffbf\072\uffbf\073\uffbf\074\uffbf\101\uffbf\104" +
    "\uffbf\001\002\000\072\003\322\004\341\006\047\015\052" +
    "\020\032\025\054\026\251\037\067\040\304\041\332\042" +
    "\300\043\031\044\016\045\033\047\030\050\027\052\022" +
    "\053\051\054\057\056\307\057\313\061\315\071\324\072" +
    "\316\073\302\074\301\101\062\104\055\001\002\000\072" +
    "\004\341\006\047\015\052\020\032\025\054\026\251\037" +
    "\067\040\304\041\332\042\300\043\031\044\016\045\033" +
    "\047\030\050\027\052\022\053\051\054\057\056\307\057" +
    "\313\061\315\063\uff56\071\u010a\072\u0106\073\302\074\301" +
    "\101\062\104\055\001\002\000\006\063\uff57\105\346\001" +
    "\002\000\004\063\361\001\002\000\004\064\362\001\002" +
    "\000\026\004\061\006\047\015\052\025\054\037\067\041" +
    "\064\053\051\054\057\101\062\104\055\001\002\000\004" +
    "\105\364\001\002\000\004\062\365\001\002\000\004\061" +
    "\366\001\002\000\004\105\367\001\002\000\076\004\uff59" +
    "\006\uff59\015\uff59\017\uff59\020\uff59\025\uff59\026\uff59\037" +
    "\uff59\040\uff59\041\uff59\042\uff59\043\uff59\044\uff59\045\uff59" +
    "\047\uff59\050\uff59\052\uff59\053\uff59\054\uff59\055\uff59\056" +
    "\uff59\057\uff59\061\uff59\063\uff59\071\uff59\072\uff59\073\uff59" +
    "\074\uff59\101\uff59\104\uff59\001\002\000\076\004\uff54\006" +
    "\uff54\015\uff54\017\uff54\020\uff54\025\uff54\026\uff54\037\uff54" +
    "\040\uff54\041\uff54\042\uff54\043\uff54\044\uff54\045\uff54\047" +
    "\uff54\050\uff54\052\uff54\053\uff54\054\uff54\055\371\056\uff54" +
    "\057\uff54\061\uff54\063\uff54\071\uff54\072\uff54\073\uff54\074" +
    "\uff54\101\uff54\104\uff54\001\002\000\004\103\373\001\002" +
    "\000\074\004\uff58\006\uff58\015\uff58\017\uff58\020\uff58\025" +
    "\uff58\026\uff58\037\uff58\040\uff58\041\uff58\042\uff58\043\uff58" +
    "\044\uff58\045\uff58\047\uff58\050\uff58\052\uff58\053\uff58\054" +
    "\uff58\056\uff58\057\uff58\061\uff58\063\uff58\071\uff58\072\uff58" +
    "\073\uff58\074\uff58\101\uff58\104\uff58\001\002\000\004\016" +
    "\374\001\002\000\072\003\322\004\341\006\047\015\052" +
    "\020\032\025\054\026\251\037\067\040\304\041\332\042" +
    "\300\043\031\044\016\045\033\047\030\050\027\052\022" +
    "\053\051\054\057\056\307\057\313\061\315\071\324\072" +
    "\316\073\302\074\301\101\062\104\055\001\002\000\072" +
    "\004\341\006\047\015\052\017\376\020\032\025\054\026" +
    "\251\037\067\040\304\041\332\042\300\043\031\044\016" +
    "\045\033\047\030\050\027\052\022\053\051\054\057\056" +
    "\307\057\313\061\315\071\u010a\072\u0106\073\302\074\301" +
    "\101\062\104\055\001\002\000\074\004\uff55\006\uff55\015" +
    "\uff55\017\uff55\020\uff55\025\uff55\026\uff55\037\uff55\040\uff55" +
    "\041\uff55\042\uff55\043\uff55\044\uff55\045\uff55\047\uff55\050" +
    "\uff55\052\uff55\053\uff55\054\uff55\056\uff55\057\uff55\061\uff55" +
    "\063\uff55\071\uff55\072\uff55\073\uff55\074\uff55\101\uff55\104" +
    "\uff55\001\002\000\074\004\uffe8\006\uffe8\015\uffe8\017\uffe8" +
    "\020\uffe8\025\uffe8\026\uffe8\037\uffe8\040\uffe8\041\uffe8\042" +
    "\uffe8\043\uffe8\044\uffe8\045\uffe8\047\uffe8\050\uffe8\052\uffe8" +
    "\053\uffe8\054\uffe8\056\uffe8\057\uffe8\061\uffe8\063\uffe8\071" +
    "\uffe8\072\uffe8\073\uffe8\074\uffe8\101\uffe8\104\uffe8\001\002" +
    "\000\074\004\uffda\006\uffda\015\uffda\017\uffda\020\uffda\025" +
    "\uffda\026\uffda\037\uffda\040\uffda\041\uffda\042\uffda\043\uffda" +
    "\044\uffda\045\uffda\047\uffda\050\uffda\052\uffda\053\uffda\054" +
    "\uffda\056\uffda\057\uffda\061\uffda\063\uffda\071\uffda\072\uffda" +
    "\073\uffda\074\uffda\101\uffda\104\uffda\001\002\000\074\004" +
    "\uffdd\006\uffdd\015\uffdd\017\uffdd\020\uffdd\025\uffdd\026\uffdd" +
    "\037\uffdd\040\uffdd\041\uffdd\042\uffdd\043\uffdd\044\uffdd\045" +
    "\uffdd\047\uffdd\050\uffdd\052\uffdd\053\uffdd\054\uffdd\056\uffdd" +
    "\057\uffdd\061\uffdd\063\uffdd\071\uffdd\072\uffdd\073\uffdd\074" +
    "\uffdd\101\uffdd\104\uffdd\001\002\000\074\004\uffe3\006\uffe3" +
    "\015\uffe3\017\uffe3\020\uffe3\025\uffe3\026\uffe3\037\uffe3\040" +
    "\uffe3\041\uffe3\042\uffe3\043\uffe3\044\uffe3\045\uffe3\047\uffe3" +
    "\050\uffe3\052\uffe3\053\uffe3\054\uffe3\056\uffe3\057\uffe3\061" +
    "\uffe3\063\uffe3\071\uffe3\072\uffe3\073\uffe3\074\uffe3\101\uffe3" +
    "\104\uffe3\001\002\000\010\004\040\026\037\105\u0121\001" +
    "\002\000\004\105\u011f\001\002\000\074\004\uffde\006\uffde" +
    "\015\uffde\017\uffde\020\uffde\025\uffde\026\uffde\037\uffde\040" +
    "\uffde\041\uffde\042\uffde\043\uffde\044\uffde\045\uffde\047\uffde" +
    "\050\uffde\052\uffde\053\uffde\054\uffde\056\uffde\057\uffde\061" +
    "\uffde\063\uffde\071\uffde\072\uffde\073\uffde\074\uffde\101\uffde" +
    "\104\uffde\001\002\000\030\004\061\006\047\015\052\025" +
    "\054\037\067\041\064\053\051\054\057\101\062\104\055" +
    "\105\u011c\001\002\000\074\004\uffe4\006\uffe4\015\uffe4\017" +
    "\uffe4\020\uffe4\025\uffe4\026\uffe4\037\uffe4\040\uffe4\041\uffe4" +
    "\042\uffe4\043\uffe4\044\uffe4\045\uffe4\047\uffe4\050\uffe4\052" +
    "\uffe4\053\uffe4\054\uffe4\056\uffe4\057\uffe4\061\uffe4\063\uffe4" +
    "\071\uffe4\072\uffe4\073\uffe4\074\uffe4\101\uffe4\104\uffe4\001" +
    "\002\000\074\004\uffe5\006\uffe5\015\uffe5\017\uffe5\020\uffe5" +
    "\025\uffe5\026\uffe5\037\uffe5\040\uffe5\041\uffe5\042\uffe5\043" +
    "\uffe5\044\uffe5\045\uffe5\047\uffe5\050\uffe5\052\uffe5\053\uffe5" +
    "\054\uffe5\056\uffe5\057\uffe5\061\uffe5\063\uffe5\071\uffe5\072" +
    "\uffe5\073\uffe5\074\uffe5\101\uffe5\104\uffe5\001\002\000\010" +
    "\004\253\026\251\105\u011b\001\002\000\004\105\u011a\001" +
    "\002\000\004\105\u0119\001\002\000\074\004\uffd8\006\uffd8" +
    "\015\uffd8\017\uffd8\020\uffd8\025\uffd8\026\uffd8\037\uffd8\040" +
    "\uffd8\041\uffd8\042\uffd8\043\uffd8\044\uffd8\045\uffd8\047\uffd8" +
    "\050\uffd8\052\uffd8\053\uffd8\054\uffd8\056\uffd8\057\uffd8\061" +
    "\uffd8\063\uffd8\071\uffd8\072\uffd8\073\uffd8\074\uffd8\101\uffd8" +
    "\104\uffd8\001\002\000\074\004\uffe2\006\uffe2\015\uffe2\017" +
    "\uffe2\020\uffe2\025\uffe2\026\uffe2\037\uffe2\040\uffe2\041\uffe2" +
    "\042\uffe2\043\uffe2\044\uffe2\045\uffe2\047\uffe2\050\uffe2\052" +
    "\uffe2\053\uffe2\054\uffe2\056\uffe2\057\uffe2\061\uffe2\063\uffe2" +
    "\071\uffe2\072\uffe2\073\uffe2\074\uffe2\101\uffe2\104\uffe2\001" +
    "\002\000\074\004\uffd9\006\uffd9\015\uffd9\017\uffd9\020\uffd9" +
    "\025\uffd9\026\uffd9\037\uffd9\040\uffd9\041\uffd9\042\uffd9\043" +
    "\uffd9\044\uffd9\045\uffd9\047\uffd9\050\uffd9\052\uffd9\053\uffd9" +
    "\054\uffd9\056\uffd9\057\uffd9\061\uffd9\063\uffd9\071\uffd9\072" +
    "\uffd9\073\uffd9\074\uffd9\101\uffd9\104\uffd9\001\002\000\010" +
    "\004\253\026\251\105\u0118\001\002\000\010\004\040\026" +
    "\037\105\u0117\001\002\000\074\004\uffd3\006\uffd3\015\uffd3" +
    "\017\uffd3\020\uffd3\025\uffd3\026\uffd3\037\uffd3\040\uffd3\041" +
    "\uffd3\042\uffd3\043\uffd3\044\uffd3\045\uffd3\047\uffd3\050\uffd3" +
    "\052\uffd3\053\uffd3\054\uffd3\056\uffd3\057\uffd3\061\uffd3\063" +
    "\uffd3\071\uffd3\072\uffd3\073\uffd3\074\uffd3\101\uffd3\104\uffd3" +
    "\001\002\000\004\105\u0116\001\002\000\004\105\u0115\001" +
    "\002\000\074\004\uffdf\006\uffdf\015\uffdf\017\uffdf\020\uffdf" +
    "\025\uffdf\026\uffdf\037\uffdf\040\uffdf\041\uffdf\042\uffdf\043" +
    "\uffdf\044\uffdf\045\uffdf\047\uffdf\050\uffdf\052\uffdf\053\uffdf" +
    "\054\uffdf\056\uffdf\057\uffdf\061\uffdf\063\uffdf\071\uffdf\072" +
    "\uffdf\073\uffdf\074\uffdf\101\uffdf\104\uffdf\001\002\000\074" +
    "\004\uffe0\006\uffe0\015\uffe0\017\uffe0\020\uffe0\025\uffe0\026" +
    "\uffe0\037\uffe0\040\uffe0\041\uffe0\042\uffe0\043\uffe0\044\uffe0" +
    "\045\uffe0\047\uffe0\050\uffe0\052\uffe0\053\uffe0\054\uffe0\056" +
    "\uffe0\057\uffe0\061\uffe0\063\uffe0\071\uffe0\072\uffe0\073\uffe0" +
    "\074\uffe0\101\uffe0\104\uffe0\001\002\000\074\004\uffdb\006" +
    "\uffdb\015\uffdb\017\uffdb\020\uffdb\025\uffdb\026\uffdb\037\uffdb" +
    "\040\uffdb\041\uffdb\042\uffdb\043\uffdb\044\uffdb\045\uffdb\047" +
    "\uffdb\050\uffdb\052\uffdb\053\uffdb\054\uffdb\056\uffdb\057\uffdb" +
    "\061\uffdb\063\uffdb\071\uffdb\072\uffdb\073\uffdb\074\uffdb\101" +
    "\uffdb\104\uffdb\001\002\000\074\004\uffe7\006\uffe7\015\uffe7" +
    "\017\uffe7\020\uffe7\025\uffe7\026\uffe7\037\uffe7\040\uffe7\041" +
    "\uffe7\042\uffe7\043\uffe7\044\uffe7\045\uffe7\047\uffe7\050\uffe7" +
    "\052\uffe7\053\uffe7\054\uffe7\056\uffe7\057\uffe7\061\uffe7\063" +
    "\uffe7\071\uffe7\072\uffe7\073\uffe7\074\uffe7\101\uffe7\104\uffe7" +
    "\001\002\000\074\004\uffe6\006\uffe6\015\uffe6\017\uffe6\020" +
    "\uffe6\025\uffe6\026\uffe6\037\uffe6\040\uffe6\041\uffe6\042\uffe6" +
    "\043\uffe6\044\uffe6\045\uffe6\047\uffe6\050\uffe6\052\uffe6\053" +
    "\uffe6\054\uffe6\056\uffe6\057\uffe6\061\uffe6\063\uffe6\071\uffe6" +
    "\072\uffe6\073\uffe6\074\uffe6\101\uffe6\104\uffe6\001\002\000" +
    "\074\004\uffe9\006\uffe9\015\uffe9\017\uffe9\020\uffe9\025\uffe9" +
    "\026\uffe9\037\uffe9\040\uffe9\041\uffe9\042\uffe9\043\uffe9\044" +
    "\uffe9\045\uffe9\047\uffe9\050\uffe9\052\uffe9\053\uffe9\054\uffe9" +
    "\056\uffe9\057\uffe9\061\uffe9\063\uffe9\071\uffe9\072\uffe9\073" +
    "\uffe9\074\uffe9\101\uffe9\104\uffe9\001\002\000\074\004\uffd6" +
    "\006\uffd6\015\uffd6\017\uffd6\020\uffd6\025\uffd6\026\uffd6\037" +
    "\uffd6\040\uffd6\041\uffd6\042\uffd6\043\uffd6\044\uffd6\045\uffd6" +
    "\047\uffd6\050\uffd6\052\uffd6\053\uffd6\054\uffd6\056\uffd6\057" +
    "\uffd6\061\uffd6\063\uffd6\071\uffd6\072\uffd6\073\uffd6\074\uffd6" +
    "\101\uffd6\104\uffd6\001\002\000\074\004\uffe1\006\uffe1\015" +
    "\uffe1\017\uffe1\020\uffe1\025\uffe1\026\uffe1\037\uffe1\040\uffe1" +
    "\041\uffe1\042\uffe1\043\uffe1\044\uffe1\045\uffe1\047\uffe1\050" +
    "\uffe1\052\uffe1\053\uffe1\054\uffe1\056\uffe1\057\uffe1\061\uffe1" +
    "\063\uffe1\071\uffe1\072\uffe1\073\uffe1\074\uffe1\101\uffe1\104" +
    "\uffe1\001\002\000\074\004\uffd4\006\uffd4\015\uffd4\017\uffd4" +
    "\020\uffd4\025\uffd4\026\uffd4\037\uffd4\040\uffd4\041\uffd4\042" +
    "\uffd4\043\uffd4\044\uffd4\045\uffd4\047\uffd4\050\uffd4\052\uffd4" +
    "\053\uffd4\054\uffd4\056\uffd4\057\uffd4\061\uffd4\063\uffd4\071" +
    "\uffd4\072\uffd4\073\uffd4\074\uffd4\101\uffd4\104\uffd4\001\002" +
    "\000\004\105\u011e\001\002\000\074\004\uffd5\006\uffd5\015" +
    "\uffd5\017\uffd5\020\uffd5\025\uffd5\026\uffd5\037\uffd5\040\uffd5" +
    "\041\uffd5\042\uffd5\043\uffd5\044\uffd5\045\uffd5\047\uffd5\050" +
    "\uffd5\052\uffd5\053\uffd5\054\uffd5\056\uffd5\057\uffd5\061\uffd5" +
    "\063\uffd5\071\uffd5\072\uffd5\073\uffd5\074\uffd5\101\uffd5\104" +
    "\uffd5\001\002\000\074\004\uffd7\006\uffd7\015\uffd7\017\uffd7" +
    "\020\uffd7\025\uffd7\026\uffd7\037\uffd7\040\uffd7\041\uffd7\042" +
    "\uffd7\043\uffd7\044\uffd7\045\uffd7\047\uffd7\050\uffd7\052\uffd7" +
    "\053\uffd7\054\uffd7\056\uffd7\057\uffd7\061\uffd7\063\uffd7\071" +
    "\uffd7\072\uffd7\073\uffd7\074\uffd7\101\uffd7\104\uffd7\001\002" +
    "\000\074\004\uff3e\006\uff3e\015\uff3e\017\uff3e\020\uff3e\025" +
    "\uff3e\026\uff3e\037\uff3e\040\uff3e\041\uff3e\042\uff3e\043\uff3e" +
    "\044\uff3e\045\uff3e\047\uff3e\050\uff3e\052\uff3e\053\uff3e\054" +
    "\uff3e\056\uff3e\057\uff3e\061\uff3e\063\uff3e\071\uff3e\072\uff3e" +
    "\073\uff3e\074\uff3e\101\uff3e\104\uff3e\001\002\000\074\004" +
    "\uffdc\006\uffdc\015\uffdc\017\uffdc\020\uffdc\025\uffdc\026\uffdc" +
    "\037\uffdc\040\uffdc\041\uffdc\042\uffdc\043\uffdc\044\uffdc\045" +
    "\uffdc\047\uffdc\050\uffdc\052\uffdc\053\uffdc\054\uffdc\056\uffdc" +
    "\057\uffdc\061\uffdc\063\uffdc\071\uffdc\072\uffdc\073\uffdc\074" +
    "\uffdc\101\uffdc\104\uffdc\001\002\000\100\002\uff65\003\uff65" +
    "\004\uff65\006\uff65\015\uff65\017\uff65\020\uff65\025\uff65\026" +
    "\uff65\037\uff65\040\uff65\041\uff65\042\uff65\043\uff65\044\uff65" +
    "\045\uff65\047\uff65\050\uff65\052\uff65\053\uff65\054\uff65\056" +
    "\uff65\057\uff65\061\uff65\063\uff65\071\uff65\072\uff65\073\uff65" +
    "\074\uff65\101\uff65\104\uff65\001\002\000\030\004\uff63\006" +
    "\uff63\015\uff63\025\uff63\037\uff63\041\uff63\053\uff63\054\uff63" +
    "\055\uff63\101\uff63\104\uff63\001\002\000\030\004\061\006" +
    "\047\015\052\025\054\037\067\041\064\053\051\054\057" +
    "\055\u0125\101\062\104\055\001\002\000\004\103\u0133\001" +
    "\002\000\032\004\061\006\047\015\052\025\054\037\067" +
    "\041\064\053\051\054\057\055\u0125\062\u012f\101\062\104" +
    "\055\001\002\000\004\103\uff5b\001\002\000\032\004\uff60" +
    "\006\uff60\015\uff60\025\uff60\037\uff60\041\uff60\053\uff60\054" +
    "\uff60\055\uff60\062\uff60\101\uff60\104\uff60\001\002\000\004" +
    "\103\u012a\001\002\000\004\016\u012b\001\002\000\072\003" +
    "\uff5f\004\uff5f\006\uff5f\015\uff5f\020\uff5f\025\uff5f\026\uff5f" +
    "\037\uff5f\040\uff5f\041\uff5f\042\uff5f\043\uff5f\044\uff5f\045" +
    "\uff5f\047\uff5f\050\uff5f\052\uff5f\053\uff5f\054\uff5f\056\uff5f" +
    "\057\uff5f\061\uff5f\071\uff5f\072\uff5f\073\uff5f\074\uff5f\101" +
    "\uff5f\104\uff5f\001\002\000\072\003\322\004\341\006\047" +
    "\015\052\020\032\025\054\026\251\037\067\040\304\041" +
    "\332\042\300\043\031\044\016\045\033\047\030\050\027" +
    "\052\022\053\051\054\057\056\307\057\313\061\315\071" +
    "\324\072\316\073\302\074\301\101\062\104\055\001\002" +
    "\000\072\004\341\006\047\015\052\017\u012e\020\032\025" +
    "\054\026\251\037\067\040\304\041\332\042\300\043\031" +
    "\044\016\045\033\047\030\050\027\052\022\053\051\054" +
    "\057\056\307\057\313\061\315\071\u010a\072\u0106\073\302" +
    "\074\301\101\062\104\055\001\002\000\032\004\uff5e\006" +
    "\uff5e\015\uff5e\025\uff5e\037\uff5e\041\uff5e\053\uff5e\054\uff5e" +
    "\055\uff5e\062\uff5e\101\uff5e\104\uff5e\001\002\000\004\057" +
    "\u0131\001\002\000\032\004\uff61\006\uff61\015\uff61\025\uff61" +
    "\037\uff61\041\uff61\053\uff61\054\uff61\055\uff61\062\uff61\101" +
    "\uff61\104\uff61\001\002\000\004\105\u0132\001\002\000\074" +
    "\004\uff62\006\uff62\015\uff62\017\uff62\020\uff62\025\uff62\026" +
    "\uff62\037\uff62\040\uff62\041\uff62\042\uff62\043\uff62\044\uff62" +
    "\045\uff62\047\uff62\050\uff62\052\uff62\053\uff62\054\uff62\056" +
    "\uff62\057\uff62\061\uff62\063\uff62\071\uff62\072\uff62\073\uff62" +
    "\074\uff62\101\uff62\104\uff62\001\002\000\004\016\u0134\001" +
    "\002\000\072\003\uff5d\004\uff5d\006\uff5d\015\uff5d\020\uff5d" +
    "\025\uff5d\026\uff5d\037\uff5d\040\uff5d\041\uff5d\042\uff5d\043" +
    "\uff5d\044\uff5d\045\uff5d\047\uff5d\050\uff5d\052\uff5d\053\uff5d" +
    "\054\uff5d\056\uff5d\057\uff5d\061\uff5d\071\uff5d\072\uff5d\073" +
    "\uff5d\074\uff5d\101\uff5d\104\uff5d\001\002\000\072\003\322" +
    "\004\341\006\047\015\052\020\032\025\054\026\251\037" +
    "\067\040\304\041\332\042\300\043\031\044\016\045\033" +
    "\047\030\050\027\052\022\053\051\054\057\056\307\057" +
    "\313\061\315\071\324\072\316\073\302\074\301\101\062" +
    "\104\055\001\002\000\072\004\341\006\047\015\052\017" +
    "\u0137\020\032\025\054\026\251\037\067\040\304\041\332" +
    "\042\300\043\031\044\016\045\033\047\030\050\027\052" +
    "\022\053\051\054\057\056\307\057\313\061\315\071\u010a" +
    "\072\u0106\073\302\074\301\101\062\104\055\001\002\000" +
    "\032\004\uff5c\006\uff5c\015\uff5c\025\uff5c\037\uff5c\041\uff5c" +
    "\053\uff5c\054\uff5c\055\uff5c\062\uff5c\101\uff5c\104\uff5c\001" +
    "\002\000\074\004\uffc1\006\uffc1\015\uffc1\017\uffc1\020\uffc1" +
    "\025\uffc1\026\uffc1\037\uffc1\040\uffc1\041\uffc1\042\uffc1\043" +
    "\uffc1\044\uffc1\045\uffc1\047\uffc1\050\uffc1\052\uffc1\053\uffc1" +
    "\054\uffc1\056\uffc1\057\uffc1\061\uffc1\063\uffc1\071\uffc1\072" +
    "\uffc1\073\uffc1\074\uffc1\101\uffc1\104\uffc1\001\002\000\074" +
    "\004\uffd1\006\uffd1\015\uffd1\017\uffd1\020\uffd1\025\uffd1\026" +
    "\uffd1\037\uffd1\040\uffd1\041\uffd1\042\uffd1\043\uffd1\044\uffd1" +
    "\045\uffd1\047\uffd1\050\uffd1\052\uffd1\053\uffd1\054\uffd1\056" +
    "\uffd1\057\uffd1\061\uffd1\063\uffd1\071\uffd1\072\uffd1\073\uffd1" +
    "\074\uffd1\101\uffd1\104\uffd1\001\002\000\004\065\u0141\001" +
    "\002\000\004\026\u013f\001\002\000\006\026\u013d\077\140" +
    "\001\002\000\026\004\061\006\047\015\052\025\054\037" +
    "\067\041\064\053\051\054\057\101\062\104\055\001\002" +
    "\000\004\065\uff4f\001\002\000\026\004\061\006\047\015" +
    "\052\025\054\037\067\041\064\053\051\054\057\101\062" +
    "\104\055\001\002\000\004\065\uff4e\001\002\000\026\004" +
    "\061\006\047\015\052\025\054\037\067\041\064\053\051" +
    "\054\057\101\062\104\055\001\002\000\006\066\uff4d\067" +
    "\uff4d\001\002\000\006\066\u0144\067\u0145\001\002\000\026" +
    "\004\061\006\047\015\052\025\054\037\067\041\064\053" +
    "\051\054\057\101\062\104\055\001\002\000\026\004\061" +
    "\006\047\015\052\025\054\037\067\041\064\053\051\054" +
    "\057\101\062\104\055\001\002\000\004\070\u0147\001\002" +
    "\000\004\016\uff51\001\002\000\004\016\275\001\002\000" +
    "\072\003\322\004\341\006\047\015\052\020\032\025\054" +
    "\026\251\037\067\040\304\041\332\042\300\043\031\044" +
    "\016\045\033\047\030\050\027\052\022\053\051\054\057" +
    "\056\307\057\313\061\315\071\324\072\316\073\302\074" +
    "\301\101\062\104\055\001\002\000\072\004\341\006\047" +
    "\015\052\017\u014b\020\032\025\054\026\251\037\067\040" +
    "\304\041\332\042\300\043\031\044\016\045\033\047\030" +
    "\050\027\052\022\053\051\054\057\056\307\057\313\061" +
    "\315\071\u010a\072\u0106\073\302\074\301\101\062\104\055" +
    "\001\002\000\074\004\uff50\006\uff50\015\uff50\017\uff50\020" +
    "\uff50\025\uff50\026\uff50\037\uff50\040\uff50\041\uff50\042\uff50" +
    "\043\uff50\044\uff50\045\uff50\047\uff50\050\uff50\052\uff50\053" +
    "\uff50\054\uff50\056\uff50\057\uff50\061\uff50\063\uff50\071\uff50" +
    "\072\uff50\073\uff50\074\uff50\101\uff50\104\uff50\001\002\000" +
    "\004\070\u014d\001\002\000\004\016\uff53\001\002\000\004" +
    "\016\275\001\002\000\072\003\322\004\341\006\047\015" +
    "\052\020\032\025\054\026\251\037\067\040\304\041\332" +
    "\042\300\043\031\044\016\045\033\047\030\050\027\052" +
    "\022\053\051\054\057\056\307\057\313\061\315\071\324" +
    "\072\316\073\302\074\301\101\062\104\055\001\002\000" +
    "\072\004\341\006\047\015\052\017\u0151\020\032\025\054" +
    "\026\251\037\067\040\304\041\332\042\300\043\031\044" +
    "\016\045\033\047\030\050\027\052\022\053\051\054\057" +
    "\056\307\057\313\061\315\071\u010a\072\u0106\073\302\074" +
    "\301\101\062\104\055\001\002\000\074\004\uff52\006\uff52" +
    "\015\uff52\017\uff52\020\uff52\025\uff52\026\uff52\037\uff52\040" +
    "\uff52\041\uff52\042\uff52\043\uff52\044\uff52\045\uff52\047\uff52" +
    "\050\uff52\052\uff52\053\uff52\054\uff52\056\uff52\057\uff52\061" +
    "\uff52\063\uff52\071\uff52\072\uff52\073\uff52\074\uff52\101\uff52" +
    "\104\uff52\001\002\000\006\016\uff81\101\uff81\001\002\000" +
    "\004\004\u0154\001\002\000\004\077\u0155\001\002\000\004" +
    "\015\u0156\001\002\000\004\100\u0157\001\002\000\010\004" +
    "\uff4c\026\uff4c\105\uff4c\001\002\000\004\004\u0159\001\002" +
    "\000\004\102\u015a\001\002\000\004\105\u015b\001\002\000" +
    "\074\004\uff9f\006\uff9f\015\uff9f\017\uff9f\020\uff9f\025\uff9f" +
    "\026\uff9f\037\uff9f\040\uff9f\041\uff9f\042\uff9f\043\uff9f\044" +
    "\uff9f\045\uff9f\047\uff9f\050\uff9f\052\uff9f\053\uff9f\054\uff9f" +
    "\056\uff9f\057\uff9f\061\uff9f\063\uff9f\071\uff9f\072\uff9f\073" +
    "\uff9f\074\uff9f\101\uff9f\104\uff9f\001\002\000\026\004\061" +
    "\006\047\015\052\025\054\037\067\041\064\053\051\054" +
    "\057\101\062\104\055\001\002\000\004\102\u015e\001\002" +
    "\000\004\105\uff34\001\002\000\006\016\uff80\101\uff80\001" +
    "\002\000\004\004\u0161\001\002\000\004\077\u0162\001\002" +
    "\000\004\015\u0163\001\002\000\004\100\u0164\001\002\000" +
    "\010\004\uff4b\026\uff4b\105\uff4b\001\002\000\006\016\uff75" +
    "\102\u016a\001\002\000\004\004\u0174\001\002\000\010\016" +
    "\uff74\024\u0172\102\uff74\001\002\000\004\004\u0171\001\002" +
    "\000\004\004\u0170\001\002\000\004\016\uff76\001\002\000" +
    "\004\016\uff78\001\002\000\004\004\u016f\001\002\000\004" +
    "\004\u016e\001\002\000\010\016\uff70\024\uff70\102\uff70\001" +
    "\002\000\010\016\uff71\024\uff71\102\uff71\001\002\000\010" +
    "\016\uff6e\024\uff6e\102\uff6e\001\002\000\010\016\uff6f\024" +
    "\uff6f\102\uff6f\001\002\000\014\040\u0166\041\u016d\042\u016c" +
    "\043\u0168\044\u0169\001\002\000\006\016\uff73\102\uff73\001" +
    "\002\000\010\016\uff72\024\uff72\102\uff72\001\002\000\004" +
    "\016\uff79\001\002\000\032\002\ufff5\003\025\020\032\040" +
    "\012\041\017\042\013\043\031\044\016\045\033\047\030" +
    "\050\027\052\022\001\002\000\004\002\ufff6\001\002\000" +
    "\004\002\uffec\001\002\000\004\016\uff7b\001\002\000\004" +
    "\016\275\001\002\000\072\003\322\004\341\006\047\015" +
    "\052\020\032\025\054\026\251\037\067\040\304\041\332" +
    "\042\300\043\031\044\016\045\033\047\030\050\027\052" +
    "\022\053\051\054\057\056\307\057\313\061\315\071\324" +
    "\072\316\073\302\074\301\101\062\104\055\001\002\000" +
    "\072\004\341\006\047\015\052\017\u017d\020\032\025\054" +
    "\026\251\037\067\040\304\041\332\042\300\043\031\044" +
    "\016\045\033\047\030\050\027\052\022\053\051\054\057" +
    "\056\307\057\313\061\315\071\u010a\072\u0106\073\302\074" +
    "\301\101\062\104\055\001\002\000\100\002\uff7a\003\uff7a" +
    "\004\uff7a\006\uff7a\015\uff7a\017\uff7a\020\uff7a\025\uff7a\026" +
    "\uff7a\037\uff7a\040\uff7a\041\uff7a\042\uff7a\043\uff7a\044\uff7a" +
    "\045\uff7a\047\uff7a\050\uff7a\052\uff7a\053\uff7a\054\uff7a\056" +
    "\uff7a\057\uff7a\061\uff7a\063\uff7a\071\uff7a\072\uff7a\073\uff7a" +
    "\074\uff7a\101\uff7a\104\uff7a\001\002" });

  /** Access to parse-action table. */
  public short[][] action_table() {return _action_table;}

  /** <code>reduce_goto</code> table. */
  protected static final short[][] _reduce_table = 
    unpackFromStrings(new String[] {
    "\000\u017b\000\006\003\004\075\003\001\001\000\034\004" +
    "\025\012\022\013\023\025\010\026\033\037\013\040\006" +
    "\047\017\050\035\051\020\053\034\054\014\065\007\001" +
    "\001\000\002\001\001\000\002\001\001\000\004\055\u0178" +
    "\001\001\000\034\004\025\012\022\013\023\025\010\026" +
    "\033\037\013\040\006\047\u0177\050\035\051\020\053\034" +
    "\054\014\065\007\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\004\055\271\001\001\000\034" +
    "\004\025\012\022\013\023\025\010\026\033\037\013\040" +
    "\006\047\267\050\035\051\020\053\034\054\014\065\007" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\006\005\247\044\251\001\001\000\002\001\001" +
    "\000\034\004\025\012\022\013\023\025\010\026\033\037" +
    "\013\040\006\047\246\050\035\051\020\053\034\054\014" +
    "\065\007\001\001\000\034\004\025\012\022\013\023\025" +
    "\010\026\033\037\013\040\006\047\245\050\035\051\020" +
    "\053\034\054\014\065\007\001\001\000\034\004\025\012" +
    "\022\013\023\025\010\026\033\037\013\040\006\047\244" +
    "\050\035\051\020\053\034\054\014\065\007\001\001\000" +
    "\002\001\001\000\004\067\222\001\001\000\002\001\001" +
    "\000\002\001\001\000\004\066\172\001\001\000\002\001" +
    "\001\000\002\001\001\000\034\004\025\012\022\013\023" +
    "\025\010\026\033\037\013\040\006\047\164\050\035\051" +
    "\020\053\034\054\014\065\007\001\001\000\004\021\040" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\034\004\025\012\022\013\023\025\010\026\033" +
    "\037\013\040\006\047\042\050\035\051\020\053\034\054" +
    "\014\065\007\001\001\000\002\001\001\000\002\001\001" +
    "\000\016\007\052\010\057\011\047\023\055\024\062\044" +
    "\045\001\001\000\002\001\001\000\004\024\154\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\022\007\065\010\057\011\047\024\062\041\064" +
    "\042\070\043\067\044\045\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\006\072\107\074\103" +
    "\001\001\000\016\007\065\010\057\011\047\024\062\043" +
    "\075\044\045\001\001\000\002\001\001\000\002\001\001" +
    "\000\016\007\065\010\057\011\047\024\062\043\074\044" +
    "\045\001\001\000\016\007\065\010\057\011\047\024\062" +
    "\043\073\044\045\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\014\007\132\010\057\011\047" +
    "\024\062\044\045\001\001\000\012\010\057\011\131\024" +
    "\062\044\045\001\001\000\014\007\130\010\057\011\047" +
    "\024\062\044\045\001\001\000\012\010\057\011\117\024" +
    "\062\044\045\001\001\000\014\007\116\010\057\011\047" +
    "\024\062\044\045\001\001\000\006\073\114\074\113\001" +
    "\001\000\014\007\112\010\057\011\047\024\062\044\045" +
    "\001\001\000\014\007\111\010\057\011\047\024\062\044" +
    "\045\001\001\000\014\007\110\010\057\011\047\024\062" +
    "\044\045\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\006\073\115\074\113" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\010\010\127\024\062\044\045" +
    "\001\001\000\010\010\126\024\062\044\045\001\001\000" +
    "\010\010\125\024\062\044\045\001\001\000\010\010\124" +
    "\024\062\044\045\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\026\007\065\010\057\011\047\024\062" +
    "\041\142\042\070\043\067\044\045\061\144\062\143\001" +
    "\001\000\002\001\001\000\014\007\140\010\057\011\047" +
    "\024\062\044\045\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\024\007\065\010\057\011\047\024" +
    "\062\041\142\042\070\043\067\044\045\062\147\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\016\007\052\010\057\011\047\023\153\024\062\044\045" +
    "\001\001\000\002\001\001\000\002\001\001\000\022\007" +
    "\065\010\057\011\047\024\062\041\156\042\070\043\067" +
    "\044\045\001\001\000\002\001\001\000\002\001\001\000" +
    "\016\007\052\010\057\011\047\023\161\024\062\044\045" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\034\004\025\012\022\013\023" +
    "\025\010\026\033\037\013\040\006\047\166\050\035\051" +
    "\020\053\034\054\014\065\007\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\004\067\214\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\022\007\065\010\057\011\047\024\062\041\241" +
    "\042\070\043\067\044\045\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\004\070\231\001\001" +
    "\000\002\001\001\000\024\007\065\010\057\011\047\024" +
    "\062\041\233\042\070\043\067\044\045\071\235\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\024\007\065\010\057\011\047\024\062" +
    "\041\233\042\070\043\067\044\045\071\240\001\001\000" +
    "\002\001\001\000\002\001\001\000\034\004\025\012\022" +
    "\013\023\025\010\026\033\037\013\040\006\047\243\050" +
    "\035\051\020\053\034\054\014\065\007\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\022\007\065\010\057\011\047" +
    "\024\062\041\263\042\070\043\067\044\045\001\001\000" +
    "\002\001\001\000\002\001\001\000\034\004\025\012\022" +
    "\013\023\025\010\026\033\037\013\040\006\047\254\050" +
    "\035\051\020\053\034\054\014\065\007\001\001\000\002" +
    "\001\001\000\022\007\065\010\057\011\047\024\062\041" +
    "\256\042\070\043\067\044\045\001\001\000\002\001\001" +
    "\000\002\001\001\000\022\007\065\010\057\011\047\024" +
    "\062\041\261\042\070\043\067\044\045\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\010\056\u016a\057\u0164\060\u0166\001\001\000\004\077" +
    "\272\001\001\000\004\015\273\001\001\000\076\004\322" +
    "\005\302\006\313\007\065\010\057\011\047\012\326\013" +
    "\307\014\311\020\310\022\330\024\062\025\336\026\335" +
    "\031\337\032\316\034\305\036\325\037\013\040\006\041" +
    "\324\042\070\043\067\044\327\050\333\051\332\052\304" +
    "\053\320\054\317\065\334\001\001\000\004\016\276\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\006" +
    "\044\u013a\063\u0139\001\001\000\002\001\001\000\004\021" +
    "\u011f\001\001\000\002\001\001\000\002\001\001\000\074" +
    "\004\u0108\005\376\007\065\010\057\011\047\012\u010c\013" +
    "\u0101\014\u0103\020\u0102\022\u010d\024\062\025\u0112\026\u0111" +
    "\031\u0113\032\u0104\034\u0100\036\u010b\037\013\040\006\041" +
    "\u010a\042\070\043\067\044\327\050\u010f\051\u010e\052\377" +
    "\053\u0107\054\u0106\065\u0110\001\001\000\004\103\354\001" +
    "\001\000\022\007\065\010\057\011\047\024\062\041\352" +
    "\042\070\043\067\044\045\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\006" +
    "\005\347\044\251\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\006\005\247\044" +
    "\251\001\001\000\004\021\040\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\100\004\322\005" +
    "\302\006\355\007\065\010\057\011\047\012\326\013\307" +
    "\014\311\017\357\020\310\022\330\024\062\025\336\026" +
    "\335\031\337\032\316\034\305\036\325\037\013\040\006" +
    "\041\356\042\070\043\067\044\327\050\333\051\332\052" +
    "\304\053\320\054\317\065\334\001\001\000\074\004\u0108" +
    "\005\376\007\065\010\057\011\047\012\u010c\013\u0101\014" +
    "\u0103\020\u0102\022\u010d\024\062\025\u0112\026\u0111\031\u0113" +
    "\032\u0104\034\u0100\036\u010b\037\013\040\006\041\u010a\042" +
    "\070\043\067\044\327\050\u010f\051\u010e\052\377\053\u0107" +
    "\054\u0106\065\u0110\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\022\007\065\010\057\011\047" +
    "\024\062\041\362\042\070\043\067\044\045\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\004\104\367\001\001\000\004\033\371\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\076\004\322\005\302\006\374\007\065\010\057\011" +
    "\047\012\326\013\307\014\311\020\310\022\330\024\062" +
    "\025\336\026\335\031\337\032\316\034\305\036\325\037" +
    "\013\040\006\041\324\042\070\043\067\044\327\050\333" +
    "\051\332\052\304\053\320\054\317\065\334\001\001\000" +
    "\074\004\u0108\005\376\007\065\010\057\011\047\012\u010c" +
    "\013\u0101\014\u0103\020\u0102\022\u010d\024\062\025\u0112\026" +
    "\u0111\031\u0113\032\u0104\034\u0100\036\u010b\037\013\040\006" +
    "\041\u010a\042\070\043\067\044\327\050\u010f\051\u010e\052" +
    "\377\053\u0107\054\u0106\065\u0110\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\004\021\u011f\001\001\000\002\001\001" +
    "\000\002\001\001\000\022\007\065\010\057\011\047\024" +
    "\062\041\u011c\042\070\043\067\044\045\001\001\000\002" +
    "\001\001\000\002\001\001\000\006\005\347\044\251\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\006\005\247\044" +
    "\251\001\001\000\004\021\040\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\004\100\u0123\001\001\000\030\007\065" +
    "\010\057\011\047\024\062\027\u0125\030\u0127\035\u0128\041" +
    "\u0126\042\070\043\067\044\045\001\001\000\002\001\001" +
    "\000\026\007\065\010\057\011\047\024\062\030\u012f\035" +
    "\u0128\041\u0126\042\070\043\067\044\045\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\004\101\u012b\001\001\000\076\004\322\005\302" +
    "\006\u012c\007\065\010\057\011\047\012\326\013\307\014" +
    "\311\020\310\022\330\024\062\025\336\026\335\031\337" +
    "\032\316\034\305\036\325\037\013\040\006\041\324\042" +
    "\070\043\067\044\327\050\333\051\332\052\304\053\320" +
    "\054\317\065\334\001\001\000\074\004\u0108\005\376\007" +
    "\065\010\057\011\047\012\u010c\013\u0101\014\u0103\020\u0102" +
    "\022\u010d\024\062\025\u0112\026\u0111\031\u0113\032\u0104\034" +
    "\u0100\036\u010b\037\013\040\006\041\u010a\042\070\043\067" +
    "\044\327\050\u010f\051\u010e\052\377\053\u0107\054\u0106\065" +
    "\u0110\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\004\102\u0134\001\001\000\076\004\322\005\302" +
    "\006\u0135\007\065\010\057\011\047\012\326\013\307\014" +
    "\311\020\310\022\330\024\062\025\336\026\335\031\337" +
    "\032\316\034\305\036\325\037\013\040\006\041\324\042" +
    "\070\043\067\044\327\050\333\051\332\052\304\053\320" +
    "\054\317\065\334\001\001\000\074\004\u0108\005\376\007" +
    "\065\010\057\011\047\012\u010c\013\u0101\014\u0103\020\u0102" +
    "\022\u010d\024\062\025\u0112\026\u0111\031\u0113\032\u0104\034" +
    "\u0100\036\u010b\037\013\040\006\041\u010a\042\070\043\067" +
    "\044\327\050\u010f\051\u010e\052\377\053\u0107\054\u0106\065" +
    "\u0110\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\022\007\065\010\057\011\047\024\062\041\u013d" +
    "\042\070\043\067\044\045\001\001\000\002\001\001\000" +
    "\022\007\065\010\057\011\047\024\062\041\u013f\042\070" +
    "\043\067\044\045\001\001\000\002\001\001\000\024\007" +
    "\065\010\057\011\047\024\062\041\u0141\042\070\043\067" +
    "\044\045\064\u0142\001\001\000\002\001\001\000\002\001" +
    "\001\000\022\007\065\010\057\011\047\024\062\041\u014b" +
    "\042\070\043\067\044\045\001\001\000\022\007\065\010" +
    "\057\011\047\024\062\041\u0145\042\070\043\067\044\045" +
    "\001\001\000\002\001\001\000\004\106\u0147\001\001\000" +
    "\004\015\u0148\001\001\000\076\004\322\005\302\006\u0149" +
    "\007\065\010\057\011\047\012\326\013\307\014\311\020" +
    "\310\022\330\024\062\025\336\026\335\031\337\032\316" +
    "\034\305\036\325\037\013\040\006\041\324\042\070\043" +
    "\067\044\327\050\333\051\332\052\304\053\320\054\317" +
    "\065\334\001\001\000\074\004\u0108\005\376\007\065\010" +
    "\057\011\047\012\u010c\013\u0101\014\u0103\020\u0102\022\u010d" +
    "\024\062\025\u0112\026\u0111\031\u0113\032\u0104\034\u0100\036" +
    "\u010b\037\013\040\006\041\u010a\042\070\043\067\044\327" +
    "\050\u010f\051\u010e\052\377\053\u0107\054\u0106\065\u0110\001" +
    "\001\000\002\001\001\000\002\001\001\000\004\105\u014d" +
    "\001\001\000\004\015\u014e\001\001\000\076\004\322\005" +
    "\302\006\u014f\007\065\010\057\011\047\012\326\013\307" +
    "\014\311\020\310\022\330\024\062\025\336\026\335\031" +
    "\337\032\316\034\305\036\325\037\013\040\006\041\324" +
    "\042\070\043\067\044\327\050\333\051\332\052\304\053" +
    "\320\054\317\065\334\001\001\000\074\004\u0108\005\376" +
    "\007\065\010\057\011\047\012\u010c\013\u0101\014\u0103\020" +
    "\u0102\022\u010d\024\062\025\u0112\026\u0111\031\u0113\032\u0104" +
    "\034\u0100\036\u010b\037\013\040\006\041\u010a\042\070\043" +
    "\067\044\327\050\u010f\051\u010e\052\377\053\u0107\054\u0106" +
    "\065\u0110\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\022\007\065" +
    "\010\057\011\047\024\062\041\u015c\042\070\043\067\044" +
    "\045\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\004\056\u0174" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\006" +
    "\057\u0172\060\u0166\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\034\004\025\012\022\013\023" +
    "\025\010\026\033\037\013\040\006\047\u0176\050\035\051" +
    "\020\053\034\054\014\065\007\001\001\000\002\001\001" +
    "\000\002\001\001\000\004\076\u0179\001\001\000\004\015" +
    "\u017a\001\001\000\076\004\322\005\302\006\u017b\007\065" +
    "\010\057\011\047\012\326\013\307\014\311\020\310\022" +
    "\330\024\062\025\336\026\335\031\337\032\316\034\305" +
    "\036\325\037\013\040\006\041\324\042\070\043\067\044" +
    "\327\050\333\051\332\052\304\053\320\054\317\065\334" +
    "\001\001\000\074\004\u0108\005\376\007\065\010\057\011" +
    "\047\012\u010c\013\u0101\014\u0103\020\u0102\022\u010d\024\062" +
    "\025\u0112\026\u0111\031\u0113\032\u0104\034\u0100\036\u010b\037" +
    "\013\040\006\041\u010a\042\070\043\067\044\327\050\u010f" +
    "\051\u010e\052\377\053\u0107\054\u0106\065\u0110\001\001\000" +
    "\002\001\001" });

  /** Access to <code>reduce_goto</code> table. */
  public short[][] reduce_table() {return _reduce_table;}

  /** Instance of action encapsulation class. */
  protected CUP$Parser$actions action_obj;

  /** Action encapsulation object initializer. */
  protected void init_actions()
    {
      action_obj = new CUP$Parser$actions(this);
    }

  /** Invoke a user supplied parse action. */
  public java_cup.runtime.Symbol do_action(
    int                        act_num,
    java_cup.runtime.lr_parser parser,
    java.util.Stack            stack,
    int                        top)
    throws java.lang.Exception
  {
    /* call code in generated class */
    return action_obj.CUP$Parser$do_action(act_num, parser, stack, top);
  }

  /** Indicates start state. */
  public int start_state() {return 0;}
  /** Indicates start production. */
  public int start_production() {return 0;}

  /** <code>EOF</code> Symbol index. */
  public int EOF_sym() {return 0;}

  /** <code>error</code> Symbol index. */
  public int error_sym() {return 1;}


  /** User initialization code. */
  public void user_init() throws java.lang.Exception
    {

    }

  /** Scan to get the next Symbol. */
  public java_cup.runtime.Symbol scan()
    throws java.lang.Exception
    {
return lex.next_token();
    }


    Lexer lex;
    HashMap<String, ArrayList<String>> scopePrograma = new HashMap<>();
    HashMap<String, LinkedHashMap<String, SymbolInfo>> semanticScopes = new HashMap<>();
    HashMap<String, FunctionInfo> functionTable = new HashMap<>();
    ArrayDeque<String> decideEndStack = new ArrayDeque<>();
    ArrayDeque<String> decideNextStack = new ArrayDeque<>();
    ArrayDeque<String> loopStartStack = new ArrayDeque<>();
    ArrayDeque<String> loopEndStack = new ArrayDeque<>();
    ArrayList<String> semanticErrors = new ArrayList<>();
    StringBuilder cod3D = new StringBuilder();
    String currentHash;
    String globalHash = "SCOPE GLOBAL";
    int tempCounter = 0;
    int labelCounter = 0;
    boolean artifactsExported = false;
    boolean ciHeaderEmitted = false;

    static class SymbolInfo {
        final String name;
        final String type;
        final boolean isArray;
        final int arraySize;
        final boolean isParam;
        final boolean isGlobal;
        final int line;
        final int col;

        SymbolInfo(String name, String type, boolean isArray, int arraySize,
                   boolean isParam, boolean isGlobal, int line, int col) {
            this.name = name;
            this.type = type;
            this.isArray = isArray;
            this.arraySize = arraySize;
            this.isParam = isParam;
            this.isGlobal = isGlobal;
            this.line = line;
            this.col = col;
        }
    }

    static class FunctionInfo {
        final String name;
        final String returnType;
        final boolean returnsVoid;
        final ArrayList<SymbolInfo> params = new ArrayList<>();
        boolean hasReturn = false;
        boolean paramsMetadataEmitted = false;

        FunctionInfo(String name, String returnType) {
            this.name = name;
            this.returnType = returnType;
            this.returnsVoid = "VOID".equals(returnType);
        }
    }

    static class ComparisonLink {
        final String operator;
        final ExprAttr right;
        final Symbol token;

        ComparisonLink(String operator, ExprAttr right, Symbol token) {
            this.operator = operator;
            this.right = right;
            this.token = token;
        }
    }

    static class ExprAttr {
        final String place;
        final String type;
        final boolean constant;
        final String location;      // describe el l-value (por ejemplo arr[idx]) cuando aplica
        final SymbolInfo symbolInfo; // referencia al simbolo propietario (para arreglos)
        final String indexPlace;    // expresion que se usa para indexar arreglos

        ExprAttr(String place, String type, boolean constant) {
            this(place, type, constant, null, null, null);
        }

        ExprAttr(String place, String type, boolean constant, String location,
                 SymbolInfo symbolInfo, String indexPlace) {
            this.place = place;
            this.type = type;
            this.constant = constant;
            this.location = location;
            this.symbolInfo = symbolInfo;
            this.indexPlace = indexPlace;
        }

        static ExprAttr invalid() {
            return new ExprAttr("__err", "ERROR", true);
        }

        boolean isValid() {
            return place != null && type != null && !"ERROR".equals(type);
        }

        boolean isNumeric() {
            return "INT".equals(type) || "FLOAT".equals(type);
        }

        boolean isBoolean() {
            return "BOOL".equals(type);
        }

        boolean isArrayReference() {
            return location != null && symbolInfo != null && indexPlace != null;
        }
    }

    static class ForContext {
        final String target;
        final String type;
        final ExprAttr step;
        final ExprAttr limit;
        final boolean downto;
        final String condLabel;
        final String endLabel;

        ForContext(String target, String type, ExprAttr step, ExprAttr limit, boolean downto, String condLabel, String endLabel) {
            this.target = target;
            this.type = type;
            this.step = step;
            this.limit = limit;
            this.downto = downto;
            this.condLabel = condLabel;
            this.endLabel = endLabel;
        }
    }

    ArrayDeque<ForContext> forStack = new ArrayDeque<>();

    /**
     * Proposito: construir el parser e inicializar las estructuras de alcance.
     * Entradas: instancia de Lexer generada por JFlex que entrega los tokens.
     * Salidas: parser listo para usarse con fabrica de simbolos y alcance global cargado.
     * Restricciones: la referencia al lexer no debe ser nula.
     */
    @SuppressWarnings("deprecation")
    public Parser(Lexer lex) {
        this.lex = lex;
        this.symbolFactory = new DefaultSymbolFactory();
        initializeGlobalScope();
    }

    /**
     * Proposito: garantizar que el alcance global exista antes de cualquier declaracion.
     * Entradas: ninguna; usa los campos internos del parser.
     * Salidas: registros creados para globalHash dentro de scopePrograma y semanticScopes.
     * Restricciones: idealmente se ejecuta una sola vez en la inicializacion.
     */
    private void initializeGlobalScope() {
        if (!scopePrograma.containsKey(globalHash)) {
            scopePrograma.put(globalHash, new ArrayList<>());
        }
        if (!semanticScopes.containsKey(globalHash)) {
            semanticScopes.put(globalHash, new LinkedHashMap<>());
        }
    }

    /**
     * Proposito: crear bajo demanda los contenedores asociados a un alcance.
     * Entradas: nombre del alcance que se desea preparar.
     * Salidas: registros inicializados en scopePrograma y semanticScopes.
     * Restricciones: el nombre del alcance no debe ser null.
     */
    private void ensureScopeBucket(String scope) {
        if (!scopePrograma.containsKey(scope)) {
            scopePrograma.put(scope, new ArrayList<>());
        }
        if (!semanticScopes.containsKey(scope)) {
            semanticScopes.put(scope, new LinkedHashMap<>());
        }
    }

    /**
     * Proposito: convertir un simbolo CUP en linea 1-based para diagnosticos.
     * Entradas: simbolo sintactico proveniente de las acciones de la gramatica.
     * Salidas: numero de linea >=1 o -1 cuando no hay coordenadas.
     * Restricciones: depende del atributo left proporcionado por CUP.
     */
    private int toLine(Symbol sym) {
        return (sym == null || sym.left < 0) ? -1 : sym.left + 1;
    }

    /**
     * Proposito: obtener la posicion de columna (1-based) de un simbolo CUP.
     * Entradas: simbolo a inspeccionar.
     * Salidas: numero de columna >=1 o -1 si no existe informacion.
     * Restricciones: usa el atributo right calculado por CUP.
     */
    private int toColumn(Symbol sym) {
        return (sym == null || sym.right < 0) ? -1 : sym.right + 1;
    }

    /**
     * Proposito: formatear una cadena legible con la posicion del simbolo.
     * Entradas: simbolo que contiene metadatos de linea/columna.
     * Salidas: texto " (linea X, columna Y)" o cadena vacia si faltan datos.
     * Restricciones: solo tiene sentido cuando el simbolo tiene coordenadas.
     */
    private String posString(Symbol sym) {
        int line = toLine(sym);
        int col = toColumn(sym);
        if (line < 0 || col < 0) {
            return "";
        }
        return " (linea " + line + ", columna " + col + ")";
    }

    /**
     * Proposito: centralizar el registro y almacenamiento de errores semanticos.
     * Entradas: mensaje descriptivo y simbolo relacionado para la posicion.
     * Salidas: linea en stderr y adicion a la lista semanticErrors.
     * Restricciones: protege contra simbolos nulos antes de usar sus datos.
     */
    private void reportSemanticError(String message, Symbol sym) {
        String formatted = "[SEMANTICO] " + message + posString(sym);
        semanticErrors.add(formatted);
        System.err.println(formatted);
    }

    /**
     * Proposito: detectar si la ejecucion ocurre en la raiz del repo o dentro de /programa.
     * Entradas: ninguna; se basa en el directorio de trabajo actual.
     * Salidas: Path base que contiene las carpetas src y output.
     * Restricciones: si no se puede detectar, regresa el directorio actual.
     */
    private Path resolveProjectBaseDir() {
        Path cwd = Paths.get(System.getProperty("user.dir")).toAbsolutePath();
        if (Files.isDirectory(cwd.resolve("src")) && Files.isDirectory(cwd.resolve("output"))) {
            return cwd;
        }
        Path nested = cwd.resolve("programa");
        if (Files.isDirectory(nested) && Files.isDirectory(nested.resolve("src"))) {
            return nested;
        }
        return cwd;
    }

    /**
     * Proposito: obtener la tabla semantica de un alcance, creandola si no existe.
     * Entradas: nombre textual del alcance solicitado.
     * Salidas: LinkedHashMap con los SymbolInfo del alcance.
     * Restricciones: el nombre no debe ser null; la creacion es idempotente.
     */
    private LinkedHashMap<String, SymbolInfo> semanticScope(String scopeName) {
        ensureScopeBucket(scopeName);
        return semanticScopes.get(scopeName);
    }

    /**
     * Proposito: declarar un simbolo dentro del alcance correspondiente y registrar su metadata.
     * Entradas: alcance propietario, lexema, tipo, indicadores de arreglo, bandera de parametro/global y token para ubicacion.
     * Salidas: SymbolInfo almacenado en semanticScopes y linea resumen en scopePrograma.
     * Restricciones: evita duplicados por alcance y usa el global cuando owner es null.
     */
    private SymbolInfo declareSymbol(String ownerScope, String name, String type,
                                     boolean isArray, int arraySize, boolean isParam,
                                     boolean forceGlobal, Symbol token) {
        String scopeName = forceGlobal ? globalHash : (ownerScope != null ? ownerScope : globalHash);
        ensureScopeBucket(scopeName);
        LinkedHashMap<String, SymbolInfo> table = semanticScopes.get(scopeName);
        if (table.containsKey(name)) {
            reportSemanticError("El identificador '" + name + "' ya existe en el alcance '" + scopeName + "'", token);
            return null;
        }
        SymbolInfo info = new SymbolInfo(name, type, isArray, arraySize, isParam,
                                         scopeName.equals(globalHash), toLine(token), toColumn(token));
        table.put(name, info);

        ArrayList<String> bucket = scopePrograma.get(scopeName);
        if (bucket == null) {
            bucket = new ArrayList<>();
            scopePrograma.put(scopeName, bucket);
        }
        String lineStr = info.line >= 0 ? Integer.toString(info.line) : "n/a";
        String colStr = info.col >= 0 ? Integer.toString(info.col) : "n/a";
        String prefix;
        if (isParam) {
            prefix = "Parametro";
        } else if (scopeName.equals(globalHash)) {
            prefix = "Instancia GLOBAL";
        } else {
            prefix = "Instancia";
        }
        String typeLabel = isArray ? ("ARR:" + type) : type;
        bucket.add(prefix + ": " + name + ":" + typeLabel + ":line=" + lineStr + ":col=" + colStr);
        return info;
    }

    /**
     * Proposito: resolver identificadores buscando primero en el alcance actual y luego en el global.
     * Entradas: lexema a localizar.
     * Salidas: SymbolInfo encontrado o null si no existe declaracion.
     * Restricciones: depende de currentHash para conocer el alcance activo.
     */
    private SymbolInfo lookupSymbol(String name) {
        if (currentHash != null) {
            LinkedHashMap<String, SymbolInfo> local = semanticScopes.get(currentHash);
            if (local != null && local.containsKey(name)) {
                return local.get(name);
            }
        }
        LinkedHashMap<String, SymbolInfo> global = semanticScopes.get(globalHash);
        if (global != null && global.containsKey(name)) {
            return global.get(name);
        }
        return null;
    }

    /**
     * Proposito: construir los atributos de una expresion basada en un identificador simple.
     * Entradas: lexema y simbolo que origina la referencia.
     * Salidas: ExprAttr con place/type o un marcador invalido si hay errores.
     * Restricciones: los arreglos requieren indice y se rechazan aqui.
     */
    private ExprAttr identifierExpr(String name, Symbol token) {
        SymbolInfo info = lookupSymbol(name);
        if (info == null) {
            reportSemanticError("El identificador '" + name + "' no ha sido declarado", token);
            return ExprAttr.invalid();
        }
        if (info.isArray) {
            reportSemanticError("El identificador '" + name + "' es un arreglo, se requiere indice", token);
            return ExprAttr.invalid();
        }
        return new ExprAttr(name, info.type, false);
    }

    /**
     * Proposito: validar y describir el acceso a un elemento de arreglo generando codigo de tres direcciones explicito.
     * Entradas: nombre del arreglo, expresion de indice y simbolos para diagnosticos.
     * Salidas: ExprAttr con el temporal cargado desde memoria y los metadatos necesarios para reasignaciones.
     * Restricciones: requiere arreglo declarado, indice INT valido y verifica limites cuando sea posible.
     */
    private ExprAttr arrayAccess(String name, ExprAttr index, Symbol idSym, Symbol idxSym) {
        SymbolInfo info = lookupSymbol(name);
        if (info == null) {
            reportSemanticError("El arreglo '" + name + "' no ha sido declarado", idSym);
            return ExprAttr.invalid();
        }
        if (!info.isArray) {
            reportSemanticError("El identificador '" + name + "' no es un arreglo", idSym);
            return ExprAttr.invalid();
        }
        if (index == null || !index.isValid()) {
            reportSemanticError("El indice para '" + name + "' es invalido", idxSym != null ? idxSym : idSym);
            return ExprAttr.invalid();
        }
        if (!"INT".equals(index.type)) {
            reportSemanticError("El indice para '" + name + "' debe ser de tipo INT", idxSym != null ? idxSym : idSym);
            return ExprAttr.invalid();
        }
        if (info.arraySize > 0 && index.constant) {
            try {
                int idxVal = Integer.parseInt(index.place);
                if (idxVal < 0 || idxVal >= info.arraySize) {
                    reportSemanticError("Indice fuera de rango para '" + name + "' (0.." + (info.arraySize - 1) + ")", idxSym != null ? idxSym : idSym);
                }
            } catch (NumberFormatException ignore) {
                // Si no se puede evaluar en tiempo de compilacion no se aplica la verificacion
            }
        }

        String loadTemp = newTemp(info.type);
        emit("aload " + loadTemp + ", " + name + ", " + index.place);
        String location = name + "[" + index.place + "]";
        return new ExprAttr(loadTemp, info.type, false, location, info, index.place);
    }

    /**
     * Proposito: centralizar la escritura de valores dentro de un arreglo en el codigo de tres direcciones.
     * Entradas: referencia al ExprAttr que apunta al elemento, valor evaluado y simbolo para diagnosticos.
     * Salidas: instruccion 'astore' que refleja la asignacion.
     * Restricciones: el ExprAttr debe representar un elemento de arreglo y los tipos deben coincidir.
     */
    private void emitArrayStore(ExprAttr target, ExprAttr value, Symbol token) {
        if (target == null || !target.isArrayReference()) {
            reportSemanticError("Se intento asignar a un destino que no es un arreglo", token);
            return;
        }
        if (value == null || !value.isValid()) {
            reportSemanticError("Expresion invalida al asignar a arreglo", token);
            return;
        }
        if (!target.type.equals(value.type)) {
            reportSemanticError("Tipos incompatibles al asignar a arreglo: se esperaba '" + target.type + "' y se recibio '" + value.type + "'", token);
            return;
        }
        emit("astore " + target.symbolInfo.name + ", " + target.indexPlace + ", " + value.place);
    }

    /**
     * Proposito: verificar que una lista de inicializacion de arreglos no mezcle tipos diferentes.
     * Entradas: lista de ExprAttr y simbolo para diagnosticos.
     * Salidas: true cuando todos los elementos comparten el mismo tipo; false en caso contrario.
     * Restricciones: ignora entradas nulas o invalidas para evitar duplicar mensajes previos.
     */
    private boolean ensureHomogeneousElements(ArrayList<ExprAttr> list, Symbol token) {
        if (list == null || list.isEmpty()) {
            return true;
        }
        String baseType = null;
        boolean ok = true;
        for (ExprAttr expr : list) {
            if (expr == null || !expr.isValid()) {
                continue;
            }
            if (baseType == null) {
                baseType = expr.type;
            } else if (!baseType.equals(expr.type)) {
                reportSemanticError("Los elementos del arreglo deben ser del mismo tipo; se encontro '" + expr.type + "' y '" + baseType + "'", token);
                ok = false;
            }
        }
        return ok;
    }

    /**
     * Proposito: poblar un arreglo declarado con la lista de expresiones evaluadas durante la inicializacion.
     * Entradas: simbolo del arreglo, lista de ExprAttr y el token para diagnosticos.
     * Salidas: emite las instrucciones 'astore' necesarias y rellena con ceros cuando falten elementos.
     * Restricciones: el arreglo debe haber sido declarado previamente y el tipo de cada elemento debe coincidir.
     */
    private void initializeArrayValues(SymbolInfo info, ArrayList<ExprAttr> values, Symbol token) {
        if (info == null) {
            return;
        }
        if (!info.isArray) {
            reportSemanticError("El identificador '" + info.name + "' no es un arreglo", token);
            return;
        }
        ensureHomogeneousElements(values, token);
        if (values != null) {
            if (info.arraySize > 0 && values.size() > info.arraySize) {
                reportSemanticError("Demasiados elementos para '" + info.name + "'", token);
            }
            for (int i = 0; i < values.size(); i++) {
                if (info.arraySize > 0 && i >= info.arraySize) {
                    break;
                }
                ExprAttr expr = values.get(i);
                if (expr == null || !expr.isValid()) {
                    reportSemanticError("Elemento invalido en inicializacion de '" + info.name + "'", token);
                    continue;
                }
                if (!info.type.equals(expr.type)) {
                    reportSemanticError("Elemento no compatible para arreglo '" + info.name + "'", token);
                    continue;
                }
                emit("astore " + info.name + ", " + i + ", " + expr.place);
            }
            if (info.arraySize > 0 && values.size() < info.arraySize) {
                emit("arr_pad_zero " + info.name + ", " + values.size() + ", " + info.arraySize);
            }
        } else if (info.arraySize > 0) {
            emit("arr_pad_zero " + info.name + ", 0, " + info.arraySize);
        }
    }

    /**
     * Proposito: realizar las validaciones semanticas de una llamada e imprimir el codigo 3D correspondiente.
     * Entradas: nombre de la funcion, lista de argumentos evaluados y simbolo del sitio de llamada.
     * Salidas: ExprAttr que referencia el temporal de retorno; registra errores si algo no coincide.
     * Restricciones: la funcion debe existir previamente y los tipos de los argumentos deben coincidir de forma exacta.
     */
    private ExprAttr invokeFunction(String name, ArrayList<ExprAttr> args, Symbol token) {
        FunctionInfo fun = functionTable.get(name);
        if (fun == null) {
            reportSemanticError("La funcion '" + name + "' no ha sido declarada", token);
            return ExprAttr.invalid();
        }
        if (args == null) {
            args = new ArrayList<>();
        }
        if (fun.params.size() != args.size()) {
            reportSemanticError("La funcion '" + name + "' espera " + fun.params.size() + " parametros y recibe " + args.size(), token);
        } else {
            for (int i = 0; i < fun.params.size(); i++) {
                SymbolInfo param = fun.params.get(i);
                ExprAttr provided = args.get(i);
                if (provided == null || !provided.isValid()) {
                    reportSemanticError("Parametro " + (i+1) + " invalido al invocar '" + name + "'", token);
                    continue;
                }
                if (!param.type.equals(provided.type)) {
                    reportSemanticError("Parametro " + (i+1) + " de '" + name + "' espera '" + param.type + "' y recibe '" + provided.type + "'", token);
                }
            }
        }
        for (ExprAttr expr : args) {
            if (expr != null && expr.isValid()) {
                emit("param " + expr.place);
            }
        }
        String temp = newTemp(fun.returnType);
        emit(temp + " = call " + name + ", " + args.size());
        return new ExprAttr(temp, fun.returnType, false);
    }

    /**
     * Proposito: preparar las estructuras internas para una nueva declaracion de funcion.
     * Entradas: nombre de la funcion, tipo de retorno y simbolo de declaracion.
     * Salidas: registros en functionTable/scopePrograma y emision del bloque begin_func.
     * Restricciones: reporta error si la funcion ya existia.
     */
    private void startFunctionScope(String name, String returnType, Symbol token) {
        if (functionTable.containsKey(name)) {
            reportSemanticError("La funcion '" + name + "' ya fue declarada", token);
            return;
        }
        FunctionInfo info = new FunctionInfo(name, returnType);
        functionTable.put(name, info);
        currentHash = name;
        ArrayList<String> bucket = new ArrayList<>();
        bucket.add("tipo:func:" + returnType);
        scopePrograma.put(name, bucket);
        semanticScopes.put(name, new LinkedHashMap<>());
    }

    /**
     * Proposito: abandonar el alcance de funcion en el que se estaba trabajando.
     * Entradas: ninguna (usa currentHash).
     * Salidas: restablece currentHash para que las declaraciones regresen al alcance global.
     * Restricciones: debe invocarse una sola vez por startFunctionScope.
     */
    private void closeCurrentScope() {
        currentHash = null;
    }

    /**
     * Proposito: recuperar la metadata de la funcion que se esta procesando.
     * Entradas: ninguna.
     * Salidas: instancia FunctionInfo o null si no estamos dentro de una funcion.
     * Restricciones: depende de que currentHash refleje el alcance real.
     */
    private FunctionInfo currentFunction() {
        if (currentHash == null) {
            return null;
        }
        return functionTable.get(currentHash);
    }

    /**
     * Proposito: registrar un parametro formal tanto en la tabla semantica como en la metadata de la funcion.
     * Entradas: nombre/tipo del parametro y coordenadas del token original.
     * Salidas: SymbolInfo almacenado en el alcance actual y agregado a la lista de parametros.
     * Restricciones: asume que currentHash apunta a la funcion propietaria.
     */
    private void registrarParametroEnScope(String nombre, String tipo, int left, int right) {
        Symbol fake = new Symbol(sym.IDENTIFIER, left, right, nombre);
        SymbolInfo info = declareSymbol(currentHash, nombre, tipo, false, 0, true, false, fake);
        FunctionInfo fun = currentFunction();
        if (fun != null && info != null) {
            fun.params.add(info);
        }
    }

    /**
     * Proposito: reflejar en el codigo 3D los parametros formales de la funcion actual.
     * Entradas: ninguna (usa currentFunction para obtener la metadata vigente).
     * Salidas: linea "Parametros_funcion_nombre: [TIPO_param,...]" si existen parametros.
     * Restricciones: se emite una sola vez por funcion para evitar duplicados.
     */
    private void emitFunctionParamMetadata() {
        FunctionInfo fun = currentFunction();
        if (fun == null || fun.paramsMetadataEmitted || fun.params.isEmpty()) {
            return;
        }
        ArrayList<String> descriptors = new ArrayList<>();
        for (SymbolInfo param : fun.params) {
            descriptors.add(param.type + "_" + param.name);
        }
        emit("Parametros_funcion_" + fun.name + ": [" + String.join(", ", descriptors) + "]");
        fun.paramsMetadataEmitted = true;
    }

    /**
     * Proposito: encapsular literales o valores por defecto dentro de un ExprAttr.
     * Entradas: simbolo CUP (puede ser null), texto por defecto y tipo semantico.
     * Salidas: ExprAttr marcado como constante con el place/type correspondiente.
     * Restricciones: quien llama debe asegurarse de que el tipo sea compatible con el lenguaje.
     */
    private ExprAttr literalAttr(Symbol sym, String fallback, String type) {
        String raw = sym != null && sym.value != null ? sym.value.toString() : fallback;
        if (raw == null) {
            raw = fallback != null ? fallback : "0";
        }
        return new ExprAttr(raw, type, true);
    }

    /**
     * Proposito: asegurar que una expresion sea numerica antes de usarla en aritmetica.
     * Entradas: ExprAttr a validar, simbolo para reportar el error y descripcion textual del contexto.
     * Salidas: el mismo ExprAttr si es valido o un marcador invalido con registro de error.
     * Restricciones: se espera que expr no sea null y que ya tenga tipo asociado.
     */
    private ExprAttr ensureNumeric(ExprAttr expr, Symbol token, String context) {
        if (expr == null || !expr.isValid() || !expr.isNumeric()) {
            reportSemanticError("Se esperaba expresion numerica en " + context, token);
            return ExprAttr.invalid();
        }
        return expr;
    }

    private ExprAttr promoteIntToFloat(ExprAttr expr, Symbol token) {
        if (expr == null || !expr.isValid()) {
            return ExprAttr.invalid();
        }
        if (!"INT".equals(expr.type)) {
            reportSemanticError("Solo se pueden promover INT a FLOAT", token);
            return ExprAttr.invalid();
        }
        String temp = newTemp("FLOAT");
        emit(temp + " = itof " + expr.place);
        return new ExprAttr(temp, "FLOAT", false);
    }

    private ExprAttr[] alignNumericTypes(ExprAttr left, ExprAttr right, Symbol token) {
        ExprAttr[] pair = new ExprAttr[]{left, right};
        if (left == null || right == null) {
            return pair;
        }
        if (!left.isNumeric() || !right.isNumeric()) {
            return pair;
        }
        if (left.type.equals(right.type)) {
            return pair;
        }
        if ("INT".equals(left.type) && "FLOAT".equals(right.type)) {
            pair[0] = promoteIntToFloat(left, token);
        } else if ("FLOAT".equals(left.type) && "INT".equals(right.type)) {
            pair[1] = promoteIntToFloat(right, token);
        } else {
            reportSemanticError("Comparacion no soportada entre '" + left.type + "' y '" + right.type + "'", token);
            pair[0] = ExprAttr.invalid();
            pair[1] = ExprAttr.invalid();
        }
        return pair;
    }

    /**
     * Proposito: aplicar las reglas semanticas de operadores aritmeticos binarios y emitir su codigo de tres direcciones.
     * Entradas: lexema del operador, operandos izquierdo/derecho y simbolo para diagnosticos.
     * Salidas: ExprAttr que apunta al nuevo temporal generado; invalido si ocurre algun error.
     * Restricciones: ambos operandos deben ser numericos; se promociona a FLOAT si es necesario.
     */
    private ExprAttr numericBinary(String op, ExprAttr left, ExprAttr right, Symbol token) {
        if (left == null) left = ExprAttr.invalid();
        if (right == null) right = ExprAttr.invalid();
        if (!left.isValid() || !right.isValid()) {
            reportSemanticError("Operacion aritmetica invalida", token);
            return ExprAttr.invalid();
        }
        if (!left.isNumeric() || !right.isNumeric()) {
            reportSemanticError("Operacion '" + op + "' solo soporta INT/FLOAT", token);
            return ExprAttr.invalid();
        }
        if (!left.type.equals(right.type)) {
            reportSemanticError("No se puede operar '" + left.type + "' con '" + right.type + "' usando '" + op + "'", token);
            return ExprAttr.invalid();
        }
        String resultType = left.type;
        String temp = newTemp(resultType);
        emit(temp + " = " + left.place + " " + op + " " + right.place);
        return new ExprAttr(temp, resultType, false);
    }

    /**
     * Proposito: procesar operadores numericos unarios y emitir su codigo de tres direcciones.
     * Entradas: lexema del operador, expresion operando y simbolo para diagnosticos.
     * Salidas: ExprAttr que referencia el temporal resultante.
     * Restricciones: el operando debe ser numerico; los errores propagan expresiones invalidas.
     */
    private ExprAttr numericUnary(String op, ExprAttr value, Symbol token) {
        if (value == null || !value.isValid() || !value.isNumeric()) {
            reportSemanticError("Operacion '" + op + "' requiere un numerico", token);
            return ExprAttr.invalid();
        }
        String temp = newTemp(value.type);
        emit(temp + " = " + op + value.place);
        return new ExprAttr(temp, value.type, false);
    }

    /**
     * Proposito: aplicar las reglas de comparacion y generar temporales booleanos.
     * Entradas: operador, operandos izquierdo/derecho y simbolo CUP para los mensajes.
     * Salidas: ExprAttr de tipo BOOL que referencia el codigo emitido.
     * Restricciones: si los operandos no son numericos deben compartir exactamente el mismo tipo.
     */
    private ExprAttr compareBinary(String op, ExprAttr left, ExprAttr right, Symbol token) {
        if (left == null) left = ExprAttr.invalid();
        if (right == null) right = ExprAttr.invalid();
        if (!left.isValid() || !right.isValid()) {
            reportSemanticError("Comparacion invalida", token);
            return ExprAttr.invalid();
        }
        boolean numericOperands = left.isNumeric() && right.isNumeric();
        if (!left.type.equals(right.type)) {
            if (numericOperands) {
                ExprAttr[] aligned = alignNumericTypes(left, right, token);
                left = aligned[0];
                right = aligned[1];
                if (left == null || right == null || !left.isValid() || !right.isValid()) {
                    return ExprAttr.invalid();
                }
                numericOperands = left.isNumeric() && right.isNumeric();
            } else {
                reportSemanticError("Comparacion requiere operandos del mismo tipo; se obtuvo '" + left.type + "' y '" + right.type + "'", token);
                return ExprAttr.invalid();
            }
        }
        boolean equalityOp = "==".equals(op) || "!=".equals(op);
        if (equalityOp) {
            if (!numericOperands && !left.isBoolean() && !"CHAR".equals(left.type) && !"STRING".equals(left.type)) {
                reportSemanticError("Comparacion no soportada para tipo '" + left.type + "'", token);
                return ExprAttr.invalid();
            }
        } else if (!numericOperands) {
            reportSemanticError("El operador '" + op + "' solo admite operandos numericos del mismo tipo", token);
            return ExprAttr.invalid();
        }
        String temp = newTemp("BOOL");
        emit(temp + " = " + left.place + " " + op + " " + right.place);
        return new ExprAttr(temp, "BOOL", false);
    }

    /**
     * Proposito: evaluar secuencias del tipo a > b > c reduciendolas a una expresion booleana.
     * Entradas: resultado de la primera subexpresion aritmetica y la lista de comparaciones restantes.
     * Salidas: ExprAttr booleano que representa la conjuncion de todas las comparaciones consecutivas.
     * Restricciones: cada comparacion debe ser valida y sus operandos deben compartir tipo compatible.
     */
    private ExprAttr buildChainedComparison(ExprAttr first, ArrayList<ComparisonLink> links) {
        if (first == null || links == null || links.isEmpty()) {
            return ExprAttr.invalid();
        }
        if (!first.isValid()) {
            return ExprAttr.invalid();
        }
        ExprAttr previous = first;
        ExprAttr accumulated = null;
        for (ComparisonLink link : links) {
            if (link == null || link.right == null) {
                return ExprAttr.invalid();
            }
            ExprAttr comparison = compareBinary(link.operator, previous, link.right, link.token);
            if (comparison == null || !comparison.isValid()) {
                return ExprAttr.invalid();
            }
            accumulated = (accumulated == null)
                    ? comparison
                    : logicalBinary("&&", accumulated, comparison, link.token);
            previous = link.right;
            if (accumulated == null || !accumulated.isValid()) {
                return ExprAttr.invalid();
            }
        }
        return accumulated != null ? accumulated : ExprAttr.invalid();
    }

    /**
     * Proposito: validar operaciones logicas tipo AND/OR a nivel semantico.
     * Entradas: operador logico, operandos booleanos y simbolo con datos de error.
     * Salidas: ExprAttr booleano ligado al temporal que almacena el resultado.
     * Restricciones: ambos operandos deben ser BOOL.
     */
    private ExprAttr logicalBinary(String op, ExprAttr left, ExprAttr right, Symbol token) {
        if (left == null || right == null || !left.isBoolean() || !right.isBoolean()) {
            reportSemanticError("Operacion logica requiere booleanos", token);
            return ExprAttr.invalid();
        }
        String temp = newTemp("BOOL");
        emit(temp + " = " + left.place + " " + op + " " + right.place);
        return new ExprAttr(temp, "BOOL", false);
    }

    /**
     * Proposito: procesar operadores logicos unarios como la negacion.
     * Entradas: operador, expresion operando y simbolo fuente.
     * Salidas: ExprAttr booleano cuando el operando es valido.
     * Restricciones: solo acepta entradas booleanas.
     */
    private ExprAttr logicalUnary(String op, ExprAttr value, Symbol token) {
        if (value == null || !value.isBoolean()) {
            reportSemanticError("Operacion logica requiere booleano", token);
            return ExprAttr.invalid();
        }
        String temp = newTemp("BOOL");
        emit(temp + " = " + op + " " + value.place);
        return new ExprAttr(temp, "BOOL", false);
    }

    /**
     * Proposito: salvaguardar sentencias que dependen de expresiones booleanas.
     * Entradas: ExprAttr evaluado, simbolo para ubicar el error y descripcion del contexto.
     * Salidas: ninguna; solo reporta el error cuando la condicion no se cumple.
     * Restricciones: aun con el reporte, quien llama debe manejar expresiones invalidas.
     */
    private void ensureBoolean(ExprAttr expr, Symbol token, String context) {
        if (expr == null || !expr.isBoolean()) {
            reportSemanticError("La expresion en " + context + " debe ser BOOL", token);
        }
    }

    private ExprAttr ensureBooleanExpr(ExprAttr expr, Symbol token, String context) {
        if (expr != null && expr.isBoolean()) {
            return expr;
        }
        reportSemanticError("La expresion en " + context + " debe ser BOOL", token);
        return new ExprAttr("false", "BOOL", true);
    }

    private String peekLabelOrFallback(ArrayDeque<String> stack, String context, String prefix, boolean pushWhenMissing) {
        if (!stack.isEmpty()) {
            return stack.peek();
        }
        reportSemanticError("No existe una etiqueta activa para " + context, null);
        String fallback = newLabel(prefix + "_recovery");
        if (pushWhenMissing) {
            stack.push(fallback);
        }
        return fallback;
    }

    private String popLabelOrFallback(ArrayDeque<String> stack, String context, String prefix) {
        if (!stack.isEmpty()) {
            return stack.pop();
        }
        reportSemanticError("No existe una etiqueta activa para " + context, null);
        return newLabel(prefix + "_recovery");
    }

    /**
     * Proposito: centralizar las validaciones de asignaciones escalares y la emision de codigo de tres direcciones.
     * Entradas: metadata del destino, expresion evaluada y simbolo '='.
     * Salidas: emite el codigo de asignacion cuando los tipos coinciden.
     * Restricciones: el destino no puede ser arreglo y los tipos tienen que ser identicos.
     */
    private void recordAssignment(SymbolInfo target, ExprAttr value, Symbol token) {
        if (target == null || value == null || !value.isValid()) {
            reportSemanticError("Asignacion invalida", token);
            return;
        }
        if (!target.type.equals(value.type)) {
            reportSemanticError("Tipos incompatibles en asignacion para '" + target.name + "'", token);
            return;
        }
        emit(target.name + " = " + value.place);
    }

    /**
     * Proposito: validar las sentencias return y marcar que la funcion retorno.
     * Entradas: expresion opcional, simbolo y bandera que indica si hay valor explicito.
    * Salidas: emite el codigo de tres direcciones del return cuando los tipos coinciden; reporta errores cuando falta.
     * Restricciones: no puede usarse fuera de los alcances de funcion.
     */
    private void recordReturn(ExprAttr value, Symbol token, boolean hasValue) {
        FunctionInfo fun = currentFunction();
        if (fun == null) {
            reportSemanticError("Return fuera de una funcin", token);
            return;
        }
        boolean expectsValue = !fun.returnsVoid;
        if (expectsValue && !hasValue) {
            reportSemanticError("La funcin '" + fun.name + "' requiere retornar un valor de tipo '" + fun.returnType + "'", token);
            return;
        }
        if (!expectsValue && hasValue) {
            reportSemanticError("La funcin '" + fun.name + "' no debe retornar valores", token);
            return;
        }
        if (hasValue) {
            if (value == null || !value.isValid()) {
                reportSemanticError("Return invlido", token);
                return;
            }
            if (!fun.returnType.equals(value.type)) {
                reportSemanticError("El return de '" + fun.name + "' espera tipo '" + fun.returnType + "' y recibe '" + value.type + "'", token);
                return;
            }
            emit("return " + value.place);
        } else {
            emit("return");
        }
        fun.hasReturn = true;
    }

    /**
     * Proposito: generar identificadores unicos para temporales.
     * Entradas: etiqueta de tipo solo para fines descriptivos.
     * Salidas: nombre de cadena para usarse en el codigo de tres direcciones.
     * Restricciones: no depender del prefijo mas alla de la legibilidad.
     */
    private String newTemp(String type) {
        tempCounter++;
        return ("FLOAT".equals(type) ? "f" : "t") + tempCounter;
    }

    /**
     * Proposito: crear etiquetas unicas para estructuras de control.
     * Entradas: prefijo textual que describe la construccion.
     * Salidas: etiqueta con un contador incremental.
     * Restricciones: el prefijo debe ser descriptivo para ayudar al depurado.
     */
    private String newLabel(String prefix) {
        labelCounter++;
        return prefix + "_" + labelCounter;
    }

    /**
     * Proposito: agregar una instruccion al buffer de codigo 3D.
     * Entradas: linea de codigo de tres direcciones ya formateada.
     * Salidas: actualiza cod3D con la linea mas un salto de linea.
     * Restricciones: quien llama debe evitar cadenas nulas o vacias.
     */
    private void emit(String codeLine) {
        cod3D.append(codeLine).append("\n");
    }

    /**
     * Proposito: imprimir la declaracion de una etiqueta dentro del codigo 3D.
     * Entradas: etiqueta generada previamente.
     * Salidas: escribe "label:" seguido de salto de linea en cod3D.
     * Restricciones: solo debe llamarse con etiquetas unicas.
     */
    private void emitLabel(String label) {
        cod3D.append(label).append(":\n");
    }

    /**
     * Proposito: escribir una cabecera estandarizada que describa el formato del codigo intermedio.
     * Entradas: ninguna.
     * Salidas: inserta directivas #!CI_* al inicio del archivo si no se han emitido.
     * Restricciones: se ejecuta una sola vez por ejecucion del parser.
     */
    private void emitCiHeader() {
        if (ciHeaderEmitted) {
            return;
        }
        ciHeaderEmitted = true;
        emit("#!CI_VERSION 1.1");
        emit("#!CI_TARGET MIPS");
        emit("#!CI_FORMAT structured");
    }

    private void emitFunctionEntry(String name, String returnType) {
        emitCiHeader();
        emit("FUNC_BEGIN " + name + " RET " + returnType);
        emitLabel("INICIO_funcion_" + name);
    }

    private void emitFunctionExit(String name) {
        emitLabel("FIN_funcion_" + name);
        emit("FUNC_END " + name);
    }

    /**
     * Proposito: convertir literales CUP en enteros primitivos para tamanos de arreglo.
     * Entradas: simbolo que contiene digitos.
     * Salidas: valor entero o 0 si la conversion falla.
     * Restricciones: pensado para literales decimales no negativos.
     */
    private int literalToInt(Symbol sym) {
        if (sym != null && sym.value != null) {
            try {
                return Integer.parseInt(sym.value.toString());
            } catch (NumberFormatException ex) {
                reportSemanticError("Valor numrico invlido", sym);
            }
        }
        return 0;
    }

    /**
     * Proposito: construir simbolos CUP sinteticos para llamadas auxiliares internas.
     * Entradas: valor bruto, coordenadas y el id del simbolo.
     * Salidas: Symbol con la metadata proporcionada.
     * Restricciones: usar solo para diagnostico, nunca para devolverlo al lexer.
     */
    private Symbol tokenFrom(Object value, int left, int right, int symId) {
        return new Symbol(symId, left, right, value);
    }

    /**
     * Proposito: convertir valores arbitrarios de tokens en cadenas seguras y no nulas.
     * Entradas: referencia proveniente del lexer o de auxiliares.
     * Salidas: representacion en cadena o vacio si es null.
     * Restricciones: utilidad simple; quien llama puede aplicar trim si lo requiere.
     */
    private String lexeme(Object value) {
        return value != null ? value.toString() : "";
    }

    /**
     * Proposito: inicializar las pilas antes de procesar un decide-of.
     * Entradas: ninguna.
     * Salidas: apila la etiqueta de cierre para usarla en las ramas.
     * Restricciones: debe emparejarse con endDecideStructure.
     */
    private void beginDecideStructure() {
        String beginLabel = newLabel("decide_begin");
        emitLabel(beginLabel);
        decideEndStack.push(newLabel("decide_end"));
    }

    /**
     * Proposito: cerrar la estructura decide-of y emitir su etiqueta final.
     * Entradas: ninguna.
     * Salidas: imprime la etiqueta pendiente y limpia las pilas.
     * Restricciones: asume que beginDecideStructure ya se invoco.
     */
    private void endDecideStructure() {
        emitLabel(popLabelOrFallback(decideEndStack, "decide", "decide_end"));
    }

    /**
     * Proposito: iniciar un caso dentro de decide-of validando su condicion y preparando los saltos.
     * Entradas: expresion condicional y simbolo para diagnosticos.
     * Salidas: emite los saltos condicionales y apila la etiqueta de continuacion.
     * Restricciones: la condicion debe ser booleana o se reporta error.
     */
    private void beginDecideCase(ExprAttr condition, Symbol token) {
        ExprAttr guard = ensureBooleanExpr(condition, token, "la condicin de decide");
        String hitLabel = newLabel("case_hit");
        String nextLabel = newLabel("case_next");
        emit("if " + guard.place + " goto " + hitLabel);
        emit("goto " + nextLabel);
        emitLabel(hitLabel);
        decideNextStack.push(nextLabel);
    }

    /**
     * Proposito: cerrar el caso activo de decide y ajustar el flujo de control.
     * Entradas: ninguna.
     * Salidas: emite el salto hacia la etiqueta final y declara la etiqueta siguiente almacenada.
     * Restricciones: requiere que beginDecideCase haya colocado una etiqueta en la pila.
     */
    private void endDecideCase() {
        String endLabel = peekLabelOrFallback(decideEndStack, "decide", "decide_end", true);
        String nextLabel = decideNextStack.isEmpty() ? newLabel("case_next_recovery") : decideNextStack.pop();
        emit("goto " + endLabel);
        emitLabel(nextLabel);
    }

    /**
     * Proposito: preparar la rama else del decide-of.
     * Entradas: ninguna.
     * Salidas: emite un comentario para claridad y reutiliza las etiquetas en pila.
     * Restricciones: se debe invocar una sola vez por cada decide-of.
     */
    private void beginDecideElse() {
        emit("// rama else");
    }

    /**
     * Proposito: cerrar la rama else saltando hacia la etiqueta final del decide.
     * Entradas: ninguna.
     * Salidas: emite un goto hacia la etiqueta de cierre.
     * Restricciones: asume que decideEndStack tiene una entrada vigente.
     */
    private void endDecideElse() {
        String endLabel = peekLabelOrFallback(decideEndStack, "decide", "decide_end", true);
        emit("goto " + endLabel);
    }

    /**
     * Proposito: inicializar las pilas de control para una estructura loop.
     * Entradas: ninguna.
     * Salidas: apila etiquetas de inicio/fin y emite la cabecera del ciclo.
     * Restricciones: debe emparejarse con endLoopStructure.
     */
    private void beginLoopStructure() {
        String start = newLabel("loop_begin");
        String end = newLabel("loop_end");
        loopStartStack.push(start);
        loopEndStack.push(end);
        emitLabel(start);
    }

    /**
     * Proposito: cerrar una estructura loop y desapilar sus etiquetas de control.
     * Entradas: ninguna.
     * Salidas: emite la etiqueta de fin y limpia las pilas.
     * Restricciones: solo es valido si beginLoopStructure fue invocado.
     */
    private void endLoopStructure() {
        emitLabel(popLabelOrFallback(loopEndStack, "loop", "loop_end"));
        if (!loopStartStack.isEmpty()) {
            loopStartStack.pop();
        } else {
            reportSemanticError("No existe etiqueta de inicio activa para loop", null);
        }
    }

    /**
     * Proposito: emitir la condicion de salida que abandona el cuerpo de un loop.
     * Entradas: expresion booleana de salida y simbolo relacionado.
     * Salidas: genera el salto condicional al final del loop y el retorno al inicio.
     * Restricciones: la expresion debe evaluar a BOOL.
     */
    private void finalizeLoopBody(ExprAttr exitExpr, Symbol token) {
        ExprAttr guard = ensureBooleanExpr(exitExpr, token, "la condicin de salida del loop");
        String start = peekLabelOrFallback(loopStartStack, "loop", "loop_begin", true);
        String end = peekLabelOrFallback(loopEndStack, "loop", "loop_end", true);
        emit("if " + guard.place + " goto " + end);
        emit("goto " + start);
    }

    /**
     * Proposito: validar y emitir la estructura base de los ciclos FOR/DOWNTO.
     * Entradas: expresion de la variable control, paso, limite y bandera de direccion.
     * Salidas: emite etiquetas de condicion/cuerpo y almacena el contexto del ciclo.
     * Restricciones: todas las expresiones deben ser numericas y el destino asignable.
     */
    private void beginForLoop(ExprAttr target, ExprAttr step, ExprAttr limit, boolean downto) {
        if (target == null || !target.isNumeric()) {
            reportSemanticError("La variable de control del for debe ser numrica", null);
            return;
        }
        if (step == null || !step.isNumeric()) {
            reportSemanticError("El paso del for debe ser numrico", null);
            return;
        }
        if (limit == null || !limit.isNumeric()) {
            reportSemanticError("El lmite del for debe ser numrico", null);
            return;
        }
        String condLabel = newLabel("for_cond");
        String bodyLabel = newLabel("for_body");
        String endLabel = newLabel("for_end");
        emitLabel(condLabel);
        String comparator = downto ? "<" : ">";
        emit("if " + target.place + " " + comparator + " " + limit.place + " goto " + endLabel);
        emitLabel(bodyLabel);
        loopStartStack.push(condLabel);
        loopEndStack.push(endLabel);
        forStack.push(new ForContext(target.place, target.type, step, limit, downto, condLabel, endLabel));
    }

    /**
     * Proposito: cerrar los ciclos FOR emitiendo el incremento/decremento y limpiando el estado.
     * Entradas: ninguna (usa la pila de contexto).
     * Salidas: actualiza la variable de control, regresa a la condicion y emite la etiqueta final.
     * Restricciones: asume que beginForLoop inserto un contexto en forStack.
     */
    private void endForLoop() {
        if (forStack.isEmpty()) {
            return;
        }
        ForContext ctx = forStack.pop();
        String op = ctx.downto ? "-" : "+";
        emit(ctx.target + " = " + ctx.target + " " + op + " " + ctx.step.place);
        emit("goto " + ctx.condLabel);
        emitLabel(ctx.endLabel);
        if (!loopEndStack.isEmpty()) loopEndStack.pop();
        if (!loopStartStack.isEmpty()) loopStartStack.pop();
    }

    /**
     * Proposito: volcar las tablas de simbolos en CSV y mostrar un resumen en consola.
     * Entradas: ninguna (usa el mapa scopePrograma).
     * Salidas: escribe TablaSimbolos.txt dentro del directorio de salida determinado.
     * Restricciones: garantiza que el directorio exista y maneja alcances vacios sin fallar.
     */
    public void imprimirscopePrograma () {
        System.out.println("\nTABLA DE SIMBOLOS (resumen)");
        try {
            Path outDir = resolveProjectBaseDir().resolve("output");
            Files.createDirectories(outDir);

            if (scopePrograma.isEmpty()) {
                scopePrograma.put(globalHash, new ArrayList<>());
            }

            Path tablaFile = outDir.resolve("TablaSimbolos.txt");
            Pattern p = Pattern.compile(".*:\\s*([^:]+):([^:]+)(:line=(\\d+):col=(\\d+))?.*");
            try (FileWriter fw = new FileWriter(tablaFile.toFile())) {
                fw.write("Scope,Name,Type,Line,Column\n");
                for (Map.Entry<String, ArrayList<String>> entry : scopePrograma.entrySet()) {
                    String key = entry.getKey();
                    System.out.println("Scope: " + key + "  (" + entry.getValue().size() + " entradas)");
                    for (String item : entry.getValue()) {
                        String name="", type="", line="n/a", col="n/a";
                        String[] parts = item.split(":");
                        if (parts.length >= 2) {
                            name = parts[1].trim();
                        }
                        if (parts.length >= 3) {
                            for (int i = 2; i < parts.length; i++) {
                                String part = parts[i].trim();
                                if (part.equals("INT") || part.equals("CHAR") || part.equals("FLOAT") || part.equals("BOOL") || part.equals("STRING") || part.startsWith("ARR") || part.startsWith("tipo:")) {
                                    type = part;
                                    break;
                                }
                            }
                            if (type.isEmpty()) {
                                type = parts[2].trim();
                            }
                        }
                        Matcher ml = Pattern.compile("line=(\\d+)").matcher(item);
                        if (ml.find()) line = ml.group(1);
                        Matcher mc = Pattern.compile("col=(\\d+)").matcher(item);
                        if (mc.find()) col = mc.group(1);
                        fw.write(key + "," + name + "," + type + "," + line + "," + col + "\n");
                    }
                }
            }

            System.out.println("Tablas de simbolos exportadas a: " + outDir.toAbsolutePath());
        } catch (Exception e) {
            System.err.println("Error al exportar tablas de simbolos: " + e.getMessage());
        }
    }

    /**
     * Proposito: persistir el codigo 3D generado en Codigo3D.txt.
     * Entradas: ninguna (usa el buffer cod3D).
     * Salidas: escribe el archivo y muestra el destino; avisa cuando no hay codigo.
     * Restricciones: crea el directorio de salida si falta y captura excepciones de IO.
     */
    private void exportarCodigo3D() {
        try {
            Path outDir = resolveProjectBaseDir().resolve("output");
            Files.createDirectories(outDir);
            Path cod3DFile = outDir.resolve("Codigo3D.txt");
            try (FileWriter fw = new FileWriter(cod3DFile.toFile())) {
                String codigo = cod3D.toString().trim();
                if (codigo.isEmpty()) {
                    fw.write("// No se genero codigo 3D\n");
                    System.out.println("Advertencia: No se genero codigo 3D");
                } else {
                    fw.write(codigo + "\n");
                    System.out.println("Codigo 3D exportado a: " + cod3DFile.toAbsolutePath());
                }
            }
        } catch (Exception e) {
            System.err.println("Error al exportar codigo 3D: " + e.getMessage());
        }
    }

    /**
     * Proposito: exportar tablas y codigo 3D solo una vez por ejecucion del parser.
     * Entradas: ninguna.
     * Salidas: invoca imprimirscopePrograma y exportarCodigo3D si aun no se han generado.
     * Restricciones: controlado por la bandera artifactsExported para evitar duplicados.
     */
    public void exportarResultados() {
        if (artifactsExported) {
            return;
        }
        imprimirscopePrograma();
        exportarCodigo3D();
        artifactsExported = true;
    }

    // recuperacin de errores de sintaxis (mejorada)
    /**
     * Proposito: ofrecer un gancho detallado para el manejo de errores sintacticos de CUP.
     * Entradas: simbolo que ocasiono el error (puede ser null en EOF).
     * Salidas: mensaje detallado en stderr con id de token, yytext y coordenadas.
     * Restricciones: no debe lanzar excepciones; se protege contra fallos del lexer.
     */
    public void syntax_error(Symbol s) {
        try {
            if (s == null) {
                String yy = "";
                try { yy = lex.yytext(); } catch (Exception e) { yy = "<no-yytext>"; }
                System.err.println("!!Error de Sintaxis: smbolo nulo (fin de fichero probable). yytext='" + yy + "'");
                return;
            }

            int symId = s.sym;
            Object val = s.value;
            int left = s.left;
            int right = s.right;
            String yytext = "";
            try { yytext = lex.yytext(); } catch (Exception e) { yytext = "<no-yytext>"; }

            System.err.println("!!Error de Sintaxis: tokenId=" + symId + " value=" + val + " yytext='" + yytext + "' linea:" + (left>=0 ? (left+1) : "n/a") + " columna:" + (right>=0 ? (right+1) : "n/a"));

        } catch (Exception e) {
            System.err.println("!!Error de Sintaxis (excepcin al informar): " + e.getMessage());
        }
    }

    /**
     * Proposito: informar errores sintacticos fatales cuando CUP no puede recuperarse.
     * Entradas: simbolo problematico o null.
     * Salidas: mensaje en stderr similar a syntax_error pero marcado como fatal.
     * Restricciones: no debe lanzar excepciones para permitir un cierre limpio del parser.
     */
    public void unrecovered_syntax_error(Symbol s) {
        try {
            if (s == null) {
                String yy = "";
                try { yy = lex.yytext(); } catch (Exception e) { yy = "<no-yytext>"; }
                System.err.println("!!Error fatal: smbolo nulo. yytext='" + yy + "'");
                return;
            }

            int symId = s.sym;
            Object val = s.value;
            int left = s.left;
            int right = s.right;
            String yytext = "";
            try { yytext = lex.yytext(); } catch (Exception e) { yytext = "<no-yytext>"; }

            System.err.println("!!Error fatal: tokenId=" + symId + " value=" + val + " yytext='" + yytext + "' linea:" + (left>=0 ? (left+1) : "n/a") + " columna:" + (right>=0 ? (right+1) : "n/a"));

        } catch (Exception e) {
            System.err.println("!!Error fatal (excepcin al informar): " + e.getMessage());
        }
    }


/** Cup generated class to encapsulate user supplied action code.*/
@SuppressWarnings({"rawtypes", "unchecked", "unused"})
class CUP$Parser$actions {
  private final Parser parser;

  /** Constructor */
  CUP$Parser$actions(Parser parser) {
    this.parser = parser;
  }

  /** Method 0 with the actual generated action code for actions 0 to 300. */
  public final java_cup.runtime.Symbol CUP$Parser$do_action_part00000000(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack            CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      /* Symbol object for return from actions */
      java_cup.runtime.Symbol CUP$Parser$result;

      /* select the action based on the action number */
      switch (CUP$Parser$act_num)
        {
          /*. . . . . . . . . . . . . . . . . . . .*/
          case 0: // $START ::= PROGRAMA EOF 
            {
              Object RESULT =null;
		int start_valleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int start_valright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Object start_val = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		RESULT = start_val;
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("$START",0, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          /* ACCEPT */
          CUP$Parser$parser.done_parsing();
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 1: // NT$0 ::= 
            {
              Object RESULT =null;
 initializeGlobalScope(); emitCiHeader(); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("NT$0",59, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 2: // PROGRAMA ::= NT$0 PROGRAM_ITEMS 
            {
              Object RESULT =null;
              // propagate RESULT from NT$0
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		 exportarResultados(); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("PROGRAMA",1, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 3: // PROGRAM_ITEMS ::= mainStruct PROGRAM_ITEMS 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("PROGRAM_ITEMS",37, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 4: // PROGRAM_ITEMS ::= mainStruct 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("PROGRAM_ITEMS",37, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 5: // PROGRAM_ITEMS ::= funcStruct PROGRAM_ITEMS 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("PROGRAM_ITEMS",37, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 6: // PROGRAM_ITEMS ::= funcStruct 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("PROGRAM_ITEMS",37, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 7: // PROGRAM_ITEMS ::= arrayInsGl DOLLAR PROGRAM_ITEMS 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("PROGRAM_ITEMS",37, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 8: // PROGRAM_ITEMS ::= arrayInsGl DOLLAR 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("PROGRAM_ITEMS",37, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 9: // PROGRAM_ITEMS ::= varInsGl DOLLAR PROGRAM_ITEMS 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("PROGRAM_ITEMS",37, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 10: // PROGRAM_ITEMS ::= varInsGl DOLLAR 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("PROGRAM_ITEMS",37, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 11: // PROGRAM_ITEMS ::= varInsInit DOLLAR PROGRAM_ITEMS 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("PROGRAM_ITEMS",37, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 12: // PROGRAM_ITEMS ::= varInsInit DOLLAR 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("PROGRAM_ITEMS",37, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 13: // PROGRAM_ITEMS ::= varIns DOLLAR PROGRAM_ITEMS 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("PROGRAM_ITEMS",37, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 14: // PROGRAM_ITEMS ::= varIns DOLLAR 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("PROGRAM_ITEMS",37, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 15: // PROGRAM_ITEMS ::= varInsAsigGl PROGRAM_ITEMS 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("PROGRAM_ITEMS",37, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 16: // PROGRAM_ITEMS ::= varInsAsigGl 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("PROGRAM_ITEMS",37, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 17: // PROGRAM_ITEMS ::= arrayInsAsignGl PROGRAM_ITEMS 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("PROGRAM_ITEMS",37, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 18: // PROGRAM_ITEMS ::= arrayInsAsignGl 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("PROGRAM_ITEMS",37, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 19: // PROGRAM_ITEMS ::= arrayLetStmt DOLLAR PROGRAM_ITEMS 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("PROGRAM_ITEMS",37, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 20: // PROGRAM_ITEMS ::= arrayLetStmt DOLLAR 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("PROGRAM_ITEMS",37, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 21: // PROGRAM_ITEMS ::= commentBlock PROGRAM_ITEMS 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("PROGRAM_ITEMS",37, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 22: // PROGRAM_ITEMS ::= commentBlock 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("PROGRAM_ITEMS",37, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 23: // PROGRAM_ITEMS ::= error PROGRAM_ITEMS 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("PROGRAM_ITEMS",37, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 24: // BLOCK ::= BLOCK exprP DOLLAR 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("BLOCK",4, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 25: // BLOCK ::= BLOCK varAsig 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("BLOCK",4, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 26: // BLOCK ::= BLOCK arrayInsGl DOLLAR 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("BLOCK",4, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 27: // BLOCK ::= BLOCK varInsGl DOLLAR 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("BLOCK",4, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 28: // BLOCK ::= BLOCK varInsAsigGl 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("BLOCK",4, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 29: // BLOCK ::= BLOCK arrayInsAsignGl 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("BLOCK",4, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 30: // BLOCK ::= BLOCK mainStruct 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("BLOCK",4, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 31: // BLOCK ::= BLOCK funcStruct 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("BLOCK",4, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 32: // BLOCK ::= BLOCK varIns DOLLAR 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("BLOCK",4, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 33: // BLOCK ::= BLOCK varInsInit DOLLAR 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("BLOCK",4, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 34: // BLOCK ::= BLOCK decideOfStruct 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("BLOCK",4, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 35: // BLOCK ::= BLOCK loopStruct 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("BLOCK",4, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 36: // BLOCK ::= BLOCK forStruct 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("BLOCK",4, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 37: // BLOCK ::= BLOCK arrayIns DOLLAR 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("BLOCK",4, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 38: // BLOCK ::= BLOCK arrayLetStmt DOLLAR 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("BLOCK",4, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 39: // BLOCK ::= BLOCK varInsAsig 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("BLOCK",4, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 40: // BLOCK ::= BLOCK arrayInsAsign 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("BLOCK",4, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 41: // BLOCK ::= BLOCK inputStruct 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("BLOCK",4, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 42: // BLOCK ::= BLOCK outPutStruct DOLLAR 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("BLOCK",4, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 43: // BLOCK ::= BLOCK BREAK DOLLAR 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("BLOCK",4, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 44: // BLOCK ::= BLOCK RETURN exprP DOLLAR 
            {
              Object RESULT =null;
		int retTokleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int retTokright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		Object retTok = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int expleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int expright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Object exp = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		 Symbol retSym = tokenFrom(retTok, retTokleft, retTokright, sym.RETURN);
                    recordReturn((ExprAttr)exp, retSym, true);
                
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("BLOCK",4, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 45: // BLOCK ::= BLOCK RETURN DOLLAR 
            {
              Object RESULT =null;
		int retTokleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int retTokright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Object retTok = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		 Symbol retSym = tokenFrom(retTok, retTokleft, retTokright, sym.RETURN);
                    recordReturn(null, retSym, false);
                
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("BLOCK",4, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 46: // BLOCK ::= BLOCK commentBlock 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("BLOCK",4, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 47: // BLOCK ::= exprP DOLLAR 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("BLOCK",4, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 48: // BLOCK ::= arrayIns DOLLAR 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("BLOCK",4, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 49: // BLOCK ::= arrayInsAsign 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("BLOCK",4, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 50: // BLOCK ::= mainStruct 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("BLOCK",4, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 51: // BLOCK ::= funcStruct 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("BLOCK",4, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 52: // BLOCK ::= varAsig 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("BLOCK",4, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 53: // BLOCK ::= arrayInsGl DOLLAR 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("BLOCK",4, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 54: // BLOCK ::= varInsGl DOLLAR 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("BLOCK",4, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 55: // BLOCK ::= varInsAsigGl 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("BLOCK",4, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 56: // BLOCK ::= arrayInsAsignGl 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("BLOCK",4, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 57: // BLOCK ::= varInsAsig 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("BLOCK",4, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 58: // BLOCK ::= varIns DOLLAR 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("BLOCK",4, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 59: // BLOCK ::= varInsInit DOLLAR 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("BLOCK",4, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 60: // BLOCK ::= arrayLetStmt DOLLAR 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("BLOCK",4, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 61: // BLOCK ::= decideOfStruct 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("BLOCK",4, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 62: // BLOCK ::= forStruct 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("BLOCK",4, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 63: // BLOCK ::= loopStruct 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("BLOCK",4, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 64: // BLOCK ::= outPutStruct DOLLAR 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("BLOCK",4, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 65: // BLOCK ::= BREAK DOLLAR 
            {
              Object RESULT =null;
		int brkleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int brkright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Object brk = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		 Symbol brkSym = tokenFrom(brk, brkleft, brkright, sym.BREAK); if (loopEndStack.isEmpty()) { reportSemanticError("'break' fuera de ciclo", brkSym); } else { emit("goto " + loopEndStack.peek()); } 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("BLOCK",4, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 66: // BLOCK ::= RETURN exprP DOLLAR 
            {
              Object RESULT =null;
		int retTokleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int retTokright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		Object retTok = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int expleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int expright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Object exp = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		 Symbol retSym = tokenFrom(retTok, retTokleft, retTokright, sym.RETURN); recordReturn((ExprAttr)exp, retSym, true); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("BLOCK",4, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 67: // BLOCK ::= RETURN DOLLAR 
            {
              Object RESULT =null;
		int retTokleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int retTokright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Object retTok = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		 Symbol retSym = tokenFrom(retTok, retTokleft, retTokright, sym.RETURN); recordReturn(null, retSym, false); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("BLOCK",4, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 68: // BLOCK ::= inputStruct 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("BLOCK",4, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 69: // BLOCK ::= commentBlock 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("BLOCK",4, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 70: // BLOCK ::= error 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("BLOCK",4, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 71: // commentBlock ::= INIT_COMMENT commentBody END_COMMENT 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("commentBlock",51, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 72: // commentBlock ::= INIT_COMMENT END_COMMENT 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("commentBlock",51, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 73: // commentBody ::= commentBody COMMENT 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("commentBody",52, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 74: // commentBody ::= COMMENT 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("commentBody",52, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 75: // numbers ::= INT_LITERAL 
            {
              Object RESULT =null;
		int litleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int litright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object lit = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 Symbol litSym = tokenFrom(lit, litleft, litright, sym.INT_LITERAL); RESULT = literalAttr(litSym, "0", "INT"); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("numbers",18, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 76: // numbers ::= FLOAT 
            {
              Object RESULT =null;
		int litleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int litright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object lit = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 Symbol litSym = tokenFrom(lit, litleft, litright, sym.FLOAT); RESULT = literalAttr(litSym, "0.0", "FLOAT"); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("numbers",18, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 77: // compAritOp ::= term 
            {
              Object RESULT =null;
		int tleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int tright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object t = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 RESULT = t; 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("compAritOp",5, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 78: // compAritOp ::= compAritOp MAS term 
            {
              Object RESULT =null;
		int lleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int lright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		Object l = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int opleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int opright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Object op = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int rleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int rright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object r = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 Symbol opSym = tokenFrom(op, opleft, opright, sym.MAS); RESULT = numericBinary("+", (ExprAttr)l, (ExprAttr)r, opSym); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("compAritOp",5, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 79: // compAritOp ::= compAritOp MENOS term 
            {
              Object RESULT =null;
		int lleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int lright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		Object l = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int opleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int opright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Object op = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int rleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int rright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object r = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 Symbol opSym = tokenFrom(op, opleft, opright, sym.MENOS); RESULT = numericBinary("-", (ExprAttr)l, (ExprAttr)r, opSym); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("compAritOp",5, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 80: // term ::= factor 
            {
              Object RESULT =null;
		int fleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int fright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object f = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 RESULT = f; 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("term",7, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 81: // term ::= term MULTI factor 
            {
              Object RESULT =null;
		int lleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int lright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		Object l = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int opleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int opright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Object op = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int rleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int rright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object r = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 Symbol opSym = tokenFrom(op, opleft, opright, sym.MULTI); RESULT = numericBinary("*", (ExprAttr)l, (ExprAttr)r, opSym); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("term",7, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 82: // term ::= term DIV factor 
            {
              Object RESULT =null;
		int lleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int lright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		Object l = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int opleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int opright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Object op = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int rleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int rright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object r = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 Symbol opSym = tokenFrom(op, opleft, opright, sym.DIV); RESULT = numericBinary("/", (ExprAttr)l, (ExprAttr)r, opSym); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("term",7, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 83: // term ::= term POTENCIA factor 
            {
              Object RESULT =null;
		int lleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int lright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		Object l = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int opleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int opright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Object op = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int rleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int rright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object r = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 Symbol opSym = tokenFrom(op, opleft, opright, sym.POTENCIA); RESULT = numericBinary("^", (ExprAttr)l, (ExprAttr)r, opSym); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("term",7, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 84: // term ::= term FLOAT_DIV factor 
            {
              Object RESULT =null;
		int lleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int lright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		Object l = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int opleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int opright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Object op = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int rleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int rright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object r = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 Symbol opSym = tokenFrom(op, opleft, opright, sym.FLOAT_DIV); RESULT = numericBinary("%", (ExprAttr)l, (ExprAttr)r, opSym); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("term",7, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 85: // factor ::= numbers 
            {
              Object RESULT =null;
		int nleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int nright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object n = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 RESULT = n; 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("factor",6, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 86: // factor ::= MENOS numbers 
            {
              Object RESULT =null;
		int opleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int opright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Object op = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int nleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int nright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object n = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 Symbol opSym = tokenFrom(op, opleft, opright, sym.MENOS); RESULT = numericUnary("-", (ExprAttr)n, opSym); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("factor",6, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 87: // factor ::= STRING_LITERAL 
            {
              Object RESULT =null;
		int litleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int litright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object lit = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 Symbol litSym = tokenFrom(lit, litleft, litright, sym.STRING_LITERAL); RESULT = literalAttr(litSym, "\"\"", "STRING"); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("factor",6, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 88: // factor ::= CHARSTR 
            {
              Object RESULT =null;
		int chleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int chright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object ch = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 Symbol chSym = tokenFrom(ch, chleft, chright, sym.CHARSTR); RESULT = literalAttr(chSym, "'?'", "CHAR"); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("factor",6, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 89: // factor ::= IDENTIFIER 
            {
              Object RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int idright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object id = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 Symbol idSym = tokenFrom(id, idleft, idright, sym.IDENTIFIER); RESULT = identifierExpr(lexeme(id), idSym); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("factor",6, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 90: // factor ::= IDENTIFIER DMENOS 
            {
              Object RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Object id = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int opleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int opright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object op = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 
                    Symbol idSym = tokenFrom(id, idleft, idright, sym.IDENTIFIER);
                    Symbol opSym = tokenFrom(op, opleft, opright, sym.DMENOS);
                    ExprAttr base = identifierExpr(lexeme(id), idSym);
                    String step = "FLOAT".equals(base.type) ? "1.0" : "1";
                    ExprAttr result = numericBinary("-", base, literalAttr(null, step, base.type), opSym);
                    emit(lexeme(id) + " = " + result.place);
                    RESULT = result;
                
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("factor",6, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 91: // factor ::= IDENTIFIER DMAS 
            {
              Object RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Object id = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int opleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int opright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object op = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 
                    Symbol idSym = tokenFrom(id, idleft, idright, sym.IDENTIFIER);
                    Symbol opSym = tokenFrom(op, opleft, opright, sym.DMAS);
                    ExprAttr base = identifierExpr(lexeme(id), idSym);
                    String step = "FLOAT".equals(base.type) ? "1.0" : "1";
                    ExprAttr result = numericBinary("+", base, literalAttr(null, step, base.type), opSym);
                    emit(lexeme(id) + " = " + result.place);
                    RESULT = result;
                
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("factor",6, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 92: // factor ::= IDENTIFIER UKRA argListOpt RUSS 
            {
              Object RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).right;
		Object id = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-3)).value;
		int argsleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int argsright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Object args = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		 Symbol idSym = tokenFrom(id, idleft, idright, sym.IDENTIFIER); RESULT = invokeFunction(lexeme(id), (ArrayList)args, idSym); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("factor",6, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 93: // factor ::= arrayElement 
            {
              Object RESULT =null;
		int arrleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int arrright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object arr = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 RESULT = arr; 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("factor",6, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 94: // factor ::= MENOS UKRA exprP RUSS 
            {
              Object RESULT =null;
		int opleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).left;
		int opright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).right;
		Object op = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-3)).value;
		int eleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int eright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Object e = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		 Symbol opSym = tokenFrom(op, opleft, opright, sym.MENOS); RESULT = numericUnary("-", (ExprAttr)e, opSym); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("factor",6, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 95: // factor ::= UKRA exprP RUSS 
            {
              Object RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int eright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Object e = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		 RESULT = e; 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("factor",6, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 96: // factor ::= TRUE 
            {
              Object RESULT =null;
		 RESULT = new ExprAttr("true", "BOOL", true); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("factor",6, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 97: // factor ::= FALSE 
            {
              Object RESULT =null;
		 RESULT = new ExprAttr("false", "BOOL", true); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("factor",6, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 98: // inputStruct ::= INPUT UKRA IDENTIFIER RUSS DOLLAR 
            {
              Object RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		Object id = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		 
                    Symbol idSym = tokenFrom(id, idleft, idright, sym.IDENTIFIER);
                    String name = lexeme(id);
                    SymbolInfo info = lookupSymbol(name);
                    if (info == null) {
                        reportSemanticError("Variable '" + name + "' no declarada", idSym);
                    } else if (info.isArray) {
                        reportSemanticError("No se puede leer directamente un arreglo", idSym);
                    } else {
                        emit("read " + name);
                    }
                
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("inputStruct",28, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-4)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 99: // exprP ::= exprLog 
            {
              Object RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int eright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object e = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 RESULT = e; 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("exprP",31, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 100: // exprLog ::= exprLog AND exprRel 
            {
              Object RESULT =null;
		int lleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int lright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		Object l = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int opleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int opright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Object op = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int rleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int rright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object r = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 Symbol opSym = tokenFrom(op, opleft, opright, sym.AND); RESULT = logicalBinary("&&", (ExprAttr)l, (ExprAttr)r, opSym); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("exprLog",32, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 101: // exprLog ::= exprLog OR exprRel 
            {
              Object RESULT =null;
		int lleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int lright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		Object l = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int opleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int opright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Object op = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int rleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int rright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object r = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 Symbol opSym = tokenFrom(op, opleft, opright, sym.OR); RESULT = logicalBinary("||", (ExprAttr)l, (ExprAttr)r, opSym); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("exprLog",32, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 102: // exprLog ::= exprRel 
            {
              Object RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int eright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object e = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 RESULT = e; 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("exprLog",32, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 103: // exprRel ::= compAritOp relChainSeq 
            {
              Object RESULT =null;
		int leftleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int leftright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Object left = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int seqleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int seqright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		ArrayList seq = (ArrayList)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 ExprAttr base = (ExprAttr)left; RESULT = (seq != null) ? buildChainedComparison(base, (ArrayList<ComparisonLink>)seq) : base; 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("exprRel",33, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 104: // exprRel ::= NEGA exprRel 
            {
              Object RESULT =null;
		int opleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int opright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Object op = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int eleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int eright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object e = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 Symbol opSym = tokenFrom(op, opleft, opright, sym.NEGA); RESULT = logicalUnary("!", (ExprAttr)e, opSym); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("exprRel",33, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 105: // relChainSeq ::= relChainLink relChainSuffix 
            {
              ArrayList RESULT =null;
		int firstleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int firstright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		ComparisonLink first = (ComparisonLink)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int tailleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int tailright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		ArrayList tail = (ArrayList)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
                                    ArrayList<ComparisonLink> list = new ArrayList<>();
                                    list.add((ComparisonLink)first);
                                    if (tail != null) list.addAll((ArrayList<ComparisonLink>)tail);
                                    RESULT = list;
                            
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("relChainSeq",56, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 106: // relChainSeq ::= 
            {
              ArrayList RESULT =null;
		 RESULT = null; 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("relChainSeq",56, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 107: // relChainSuffix ::= relChainLink relChainSuffix 
            {
              ArrayList RESULT =null;
		int firstleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int firstright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		ComparisonLink first = (ComparisonLink)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int tailleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int tailright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		ArrayList tail = (ArrayList)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
                                         ArrayList<ComparisonLink> list = new ArrayList<>();
                                         list.add((ComparisonLink)first);
                                         if (tail != null) list.addAll((ArrayList<ComparisonLink>)tail);
                                         RESULT = list;
                                 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("relChainSuffix",57, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 108: // relChainSuffix ::= 
            {
              ArrayList RESULT =null;
		 RESULT = null; 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("relChainSuffix",57, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 109: // relChainLink ::= GREATHER compAritOp 
            {
              ComparisonLink RESULT =null;
		int opleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int opright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Object op = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int rightleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int rightright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object right = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 Symbol opSym = tokenFrom(op, opleft, opright, sym.GREATHER); RESULT = new ComparisonLink(">", (ExprAttr)right, opSym); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("relChainLink",58, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 110: // relChainLink ::= LESS compAritOp 
            {
              ComparisonLink RESULT =null;
		int opleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int opright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Object op = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int rightleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int rightright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object right = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 Symbol opSym = tokenFrom(op, opleft, opright, sym.LESS); RESULT = new ComparisonLink("<=", (ExprAttr)right, opSym); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("relChainLink",58, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 111: // relChainLink ::= MORE compAritOp 
            {
              ComparisonLink RESULT =null;
		int opleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int opright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Object op = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int rightleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int rightright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object right = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 Symbol opSym = tokenFrom(op, opleft, opright, sym.MORE); RESULT = new ComparisonLink(">=", (ExprAttr)right, opSym); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("relChainLink",58, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 112: // relChainLink ::= LOWER compAritOp 
            {
              ComparisonLink RESULT =null;
		int opleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int opright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Object op = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int rightleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int rightright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object right = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 Symbol opSym = tokenFrom(op, opleft, opright, sym.LOWER); RESULT = new ComparisonLink("<", (ExprAttr)right, opSym); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("relChainLink",58, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 113: // relChainLink ::= DIFF compAritOp 
            {
              ComparisonLink RESULT =null;
		int opleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int opright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Object op = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int rightleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int rightright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object right = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 Symbol opSym = tokenFrom(op, opleft, opright, sym.DIFF); RESULT = new ComparisonLink("!=", (ExprAttr)right, opSym); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("relChainLink",58, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 114: // relChainLink ::= COMPARA compAritOp 
            {
              ComparisonLink RESULT =null;
		int opleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int opright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Object op = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int rightleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int rightright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object right = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 Symbol opSym = tokenFrom(op, opleft, opright, sym.COMPARA); RESULT = new ComparisonLink("==", (ExprAttr)right, opSym); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("relChainLink",58, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 115: // scalarType ::= INT 
            {
              String RESULT =null;
		 RESULT = "INT"; 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("scalarType",53, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 116: // scalarType ::= CHAR 
            {
              String RESULT =null;
		 RESULT = "CHAR"; 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("scalarType",53, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 117: // scalarType ::= FLOAT 
            {
              String RESULT =null;
		 RESULT = "FLOAT"; 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("scalarType",53, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 118: // scalarType ::= BOOL 
            {
              String RESULT =null;
		 RESULT = "BOOL"; 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("scalarType",53, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 119: // scalarType ::= STRING 
            {
              String RESULT =null;
		 RESULT = "STRING"; 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("scalarType",53, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 120: // varAsig ::= IDENTIFIER EQ exprP DOLLAR 
            {
              Object RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).right;
		Object id = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-3)).value;
		int eqleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int eqright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		Object eq = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int expleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int expright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Object exp = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		
                    Symbol idSym = tokenFrom(id, idleft, idright, sym.IDENTIFIER);
                    Symbol eqSym = tokenFrom(eq, eqleft, eqright, sym.EQ);
                    String name = lexeme(id);
                    SymbolInfo target = lookupSymbol(name);
                    if (target == null) {
                        reportSemanticError("Variable '" + name + "' no declarada", idSym);
                    } else if (target.isArray) {
                        reportSemanticError("No se puede asignar a un arreglo completo sin indice", idSym);
                    } else {
                        recordAssignment(target, (ExprAttr)exp, eqSym);
                    }
                
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("varAsig",3, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 121: // varAsig ::= arrayElement EQ exprP DOLLAR 
            {
              Object RESULT =null;
		int elemleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).left;
		int elemright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).right;
		Object elem = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-3)).value;
		int eqleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int eqright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		Object eq = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int expleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int expright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Object exp = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		
                    Symbol eqSym = tokenFrom(eq, eqleft, eqright, sym.EQ);
                    ExprAttr lhs = (ExprAttr)elem;
                    ExprAttr rhs = (ExprAttr)exp;
                    emitArrayStore(lhs, rhs, eqSym);
                
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("varAsig",3, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 122: // varAsig ::= EQ exprP DOLLAR 
            {
              Object RESULT =null;
		int eqleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int eqright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		Object eq = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		 Symbol eqSym = tokenFrom(eq, eqleft, eqright, sym.EQ); reportSemanticError("Asignacion sin destino", eqSym); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("varAsig",3, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 123: // varIns ::= LET scalarType IDENTIFIER 
            {
              Object RESULT =null;
		int tleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int tright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		String t = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int IDleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int IDright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object ID = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 Symbol idSym = tokenFrom(ID, IDleft, IDright, sym.IDENTIFIER); String name = lexeme(ID); String typeName = t != null ? t.toString() : "INT"; SymbolInfo info = declareSymbol(currentHash, name, typeName, false, 0, false, false, idSym); if (info != null) emit("declare " + name + ":" + typeName); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("varIns",2, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 124: // varInsInit ::= LET scalarType IDENTIFIER EQ exprP 
            {
              Object RESULT =null;
		int tleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).left;
		int tright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).right;
		String t = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-3)).value;
		int IDleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int IDright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		Object ID = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int eqleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int eqright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Object eq = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int expleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int expright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object exp = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
                        Symbol idSym = tokenFrom(ID, IDleft, IDright, sym.IDENTIFIER);
                        Symbol eqSym = tokenFrom(eq, eqleft, eqright, sym.EQ);
                        String name = lexeme(ID);
                        String typeName = t != null ? t.toString() : "INT";
                        SymbolInfo info = declareSymbol(currentHash, name, typeName, false, 0, false, false, idSym);
                        if (info != null) {
                            emit("declare " + name + ":" + typeName);
                            recordAssignment(info, (ExprAttr)exp, eqSym);
                        }
                    
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("varInsInit",19, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-4)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 125: // varInsGl ::= GLOBAL LET scalarType IDENTIFIER 
            {
              Object RESULT =null;
		int tleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int tright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		String t = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int IDleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int IDright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object ID = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 Symbol idSym = tokenFrom(ID, IDleft, IDright, sym.IDENTIFIER); String name = lexeme(ID); String typeName = t != null ? t.toString() : "INT"; SymbolInfo info = declareSymbol(globalHash, name, typeName, false, 0, false, true, idSym); if (info != null) emit("declare_global " + name + ":" + typeName); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("varInsGl",39, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 126: // varInsAsig ::= varIns varAsig 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("varInsAsig",40, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 127: // varInsAsigGl ::= varInsGl varAsig 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("varInsAsigGl",41, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 128: // funInitial ::= INT IDENTIFIER 
            {
              Object RESULT =null;
		int IDleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int IDright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object ID = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		   Symbol idSym = tokenFrom(ID, IDleft, IDright, sym.IDENTIFIER); String name = lexeme(ID); startFunctionScope(name, "INT", idSym); emitFunctionEntry(name, "INT"); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("funInitial",30, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 129: // funInitial ::= CHAR IDENTIFIER 
            {
              Object RESULT =null;
		int IDleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int IDright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object ID = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		   Symbol idSym = tokenFrom(ID, IDleft, IDright, sym.IDENTIFIER); String name = lexeme(ID); startFunctionScope(name, "CHAR", idSym); emitFunctionEntry(name, "CHAR"); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("funInitial",30, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 130: // funInitial ::= BOOL IDENTIFIER 
            {
              Object RESULT =null;
		int IDleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int IDright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object ID = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		   Symbol idSym = tokenFrom(ID, IDleft, IDright, sym.IDENTIFIER); String name = lexeme(ID); startFunctionScope(name, "BOOL", idSym); emitFunctionEntry(name, "BOOL"); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("funInitial",30, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 131: // funInitial ::= STRING IDENTIFIER 
            {
              Object RESULT =null;
		int IDleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int IDright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object ID = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		   Symbol idSym = tokenFrom(ID, IDleft, IDright, sym.IDENTIFIER); String name = lexeme(ID); startFunctionScope(name, "STRING", idSym); emitFunctionEntry(name, "STRING"); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("funInitial",30, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 132: // funInitial ::= FLOAT IDENTIFIER 
            {
              Object RESULT =null;
		int IDleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int IDright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object ID = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		   Symbol idSym = tokenFrom(ID, IDleft, IDright, sym.IDENTIFIER); String name = lexeme(ID); startFunctionScope(name, "FLOAT", idSym); emitFunctionEntry(name, "FLOAT"); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("funInitial",30, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 133: // funInitial ::= VOID IDENTIFIER 
            {
              Object RESULT =null;
		int IDleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int IDright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object ID = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		   Symbol idSym = tokenFrom(ID, IDleft, IDright, sym.IDENTIFIER); String name = lexeme(ID); startFunctionScope(name, "VOID", idSym); emitFunctionEntry(name, "VOID"); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("funInitial",30, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 134: // NT$1 ::= 
            {
              Object RESULT =null;
 emitFunctionParamMetadata(); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("NT$1",60, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 135: // funcStruct ::= funInitial paramSection NT$1 blockStart BLOCK END_BLOCK 
            {
              Object RESULT =null;
              // propagate RESULT from NT$1
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-3)).value;
		 String finished = currentHash; if (finished != null) { emitFunctionExit(finished); } FunctionInfo info = finished != null ? functionTable.get(finished) : null; if (info != null && !info.returnsVoid && !info.hasReturn) { reportSemanticError("La funcion '" + finished + "' no retorna", null); } closeCurrentScope(); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("funcStruct",8, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-5)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 136: // paramSection ::= UKRA paramDeclList paramSectionClose 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("paramSection",43, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 137: // paramSection ::= UKRA paramSectionClose 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("paramSection",43, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 138: // paramSection ::= 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("paramSection",43, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 139: // paramSectionClose ::= RUSS 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("paramSectionClose",44, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 140: // paramSectionClose ::= 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("paramSectionClose",44, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 141: // paramDeclList ::= paramDecl 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("paramDeclList",45, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 142: // paramDeclList ::= paramDecl COMA paramDeclList 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("paramDeclList",45, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 143: // paramDecl ::= INT IDENTIFIER 
            {
              Object RESULT =null;
		int IDleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int IDright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object ID = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 registrarParametroEnScope(lexeme(ID), "INT", IDleft, IDright); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("paramDecl",46, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 144: // paramDecl ::= CHAR IDENTIFIER 
            {
              Object RESULT =null;
		int IDleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int IDright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object ID = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 registrarParametroEnScope(lexeme(ID), "CHAR", IDleft, IDright); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("paramDecl",46, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 145: // paramDecl ::= FLOAT IDENTIFIER 
            {
              Object RESULT =null;
		int IDleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int IDright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object ID = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 registrarParametroEnScope(lexeme(ID), "FLOAT", IDleft, IDright); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("paramDecl",46, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 146: // paramDecl ::= BOOL IDENTIFIER 
            {
              Object RESULT =null;
		int IDleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int IDright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object ID = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 registrarParametroEnScope(lexeme(ID), "BOOL", IDleft, IDright); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("paramDecl",46, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 147: // paramDecl ::= STRING IDENTIFIER 
            {
              Object RESULT =null;
		int IDleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int IDright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object ID = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 registrarParametroEnScope(lexeme(ID), "STRING", IDleft, IDright); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("paramDecl",46, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 148: // blockStart ::= INIT_BLOCK blockStartClose 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("blockStart",11, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 149: // blockStartClose ::= RUSS 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("blockStartClose",12, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 150: // blockStartClose ::= 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("blockStartClose",12, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 151: // argListOpt ::= argList 
            {
              Object RESULT =null;
		int lleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int lright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object l = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 RESULT = l; 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("argListOpt",47, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 152: // argListOpt ::= 
            {
              Object RESULT =null;
		 RESULT = new ArrayList(); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("argListOpt",47, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 153: // argList ::= exprP 
            {
              Object RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int eright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object e = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 ArrayList tmp = new ArrayList(); tmp.add((ExprAttr)e); RESULT = tmp; 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("argList",48, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 154: // argList ::= exprP COMA argList 
            {
              Object RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int eright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		Object e = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int restleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int restright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object rest = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 ArrayList tmp = new ArrayList(); tmp.add((ExprAttr)e); tmp.addAll((ArrayList)rest); RESULT = tmp; 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("argList",48, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 155: // NT$2 ::= 
            {
              Object RESULT =null;
 emitFunctionParamMetadata(); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("NT$2",61, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 156: // mainStruct ::= mainInitial paramSection NT$2 blockStart BLOCK END_BLOCK 
            {
              Object RESULT =null;
              // propagate RESULT from NT$2
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-3)).value;
		 emitFunctionExit("MAIN"); emitLabel("FIN_main"); emit("MAIN_END"); closeCurrentScope(); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("mainStruct",9, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-5)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 157: // mainInitial ::= PRINCIPAL 
            {
              Object RESULT =null;
		int KWleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int KWright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object KW = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 Symbol kwSym = tokenFrom(KW, KWleft, KWright, sym.PRINCIPAL);
                                                     startFunctionScope("MAIN", "INT", kwSym);
                                                     emit("MAIN_BEGIN");
                                                     emitFunctionEntry("MAIN", "INT");
                                                 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("mainInitial",29, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 158: // NT$3 ::= 
            {
              Object RESULT =null;
 beginDecideStructure(); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("NT$3",62, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 159: // decideOfStruct ::= DECIDE OF NT$3 decideClauseList END DECIDE DOLLAR 
            {
              Object RESULT =null;
              // propagate RESULT from NT$3
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-4)).value;
		 endDecideStructure(); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("decideOfStruct",23, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-6)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 160: // decideClauseList ::= decideClauseList decideClause 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("decideClauseList",21, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 161: // decideClauseList ::= decideClause 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("decideClauseList",21, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 162: // NT$4 ::= 
            {
              Object RESULT =null;
		int condleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int condright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		Object cond = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int arrowTokleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int arrowTokright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Object arrowTok = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
 Symbol arrowSym = tokenFrom(arrowTok, arrowTokleft, arrowTokright, sym.ARROW); beginDecideCase((ExprAttr)cond, arrowSym); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("NT$4",63, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 163: // decideClause ::= caseCondition ARROW INIT_BLOCK NT$4 BLOCK END_BLOCK 
            {
              Object RESULT =null;
              // propagate RESULT from NT$4
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int condleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-5)).left;
		int condright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-5)).right;
		Object cond = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-5)).value;
		int arrowTokleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-4)).left;
		int arrowTokright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-4)).right;
		Object arrowTok = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-4)).value;
		 endDecideCase(); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("decideClause",22, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-5)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 164: // NT$5 ::= 
            {
              Object RESULT =null;
 beginDecideElse(); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("NT$5",64, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 165: // decideClause ::= ELSE ARROW INIT_BLOCK NT$5 BLOCK END_BLOCK 
            {
              Object RESULT =null;
              // propagate RESULT from NT$5
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		 endDecideElse(); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("decideClause",22, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-5)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 166: // caseCondition ::= exprP 
            {
              Object RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int eright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object e = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 RESULT = e; 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("caseCondition",27, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 167: // NT$6 ::= 
            {
              Object RESULT =null;
 beginLoopStructure(); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("NT$6",65, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 168: // NT$7 ::= 
            {
              Object RESULT =(Object) ((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-8)).value;
		int exitTokleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-6)).left;
		int exitTokright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-6)).right;
		Object exitTok = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-6)).value;
		int exitCondleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-4)).left;
		int exitCondright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-4)).right;
		Object exitCond = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-4)).value;
 Symbol exitSym = tokenFrom(exitTok, exitTokleft, exitTokright, sym.EXIT); finalizeLoopBody((ExprAttr)exitCond, exitSym); endLoopStructure(); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("NT$7",66, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 169: // loopStruct ::= LOOP NT$6 loopBody EXIT WHEN exprP DOLLAR END LOOP DOLLAR NT$7 loopElseOpt 
            {
              Object RESULT =null;
              // propagate RESULT from NT$7
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int exitTokleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-8)).left;
		int exitTokright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-8)).right;
		Object exitTok = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-8)).value;
		int exitCondleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-6)).left;
		int exitCondright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-6)).right;
		Object exitCond = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-6)).value;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("loopStruct",24, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-11)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 170: // loopBody ::= exprP 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("loopBody",13, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 171: // loopBody ::= BLOCK 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("loopBody",13, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 172: // loopElseOpt ::= ELSE ARROW INIT_BLOCK BLOCK END_BLOCK 
            {
              Object RESULT =null;
		 emit("// rama else del loop"); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("loopElseOpt",25, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-4)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 173: // loopElseOpt ::= 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("loopElseOpt",25, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 174: // NT$8 ::= 
            {
              Object RESULT =null;
		int initleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-5)).left;
		int initright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-5)).right;
		Object init = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-5)).value;
		int stepleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).left;
		int stepright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).right;
		Object step = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-3)).value;
		int limitleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int limitright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Object limit = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
 beginForLoop((ExprAttr)init, (ExprAttr)step, (ExprAttr)limit, false); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("NT$8",67, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 175: // forStruct ::= FOR forInit STEP stepValue TO exprP DO NT$8 blockStart BLOCK END_BLOCK 
            {
              Object RESULT =null;
              // propagate RESULT from NT$8
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-3)).value;
		int initleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-9)).left;
		int initright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-9)).right;
		Object init = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-9)).value;
		int stepleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-7)).left;
		int stepright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-7)).right;
		Object step = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-7)).value;
		int limitleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-5)).left;
		int limitright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-5)).right;
		Object limit = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-5)).value;
		 endForLoop(); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("forStruct",26, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-10)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 176: // NT$9 ::= 
            {
              Object RESULT =null;
		int initleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-5)).left;
		int initright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-5)).right;
		Object init = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-5)).value;
		int stepleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).left;
		int stepright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).right;
		Object step = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-3)).value;
		int limitleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int limitright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Object limit = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
 beginForLoop((ExprAttr)init, (ExprAttr)step, (ExprAttr)limit, true); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("NT$9",68, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 177: // forStruct ::= FOR forInit STEP stepValue DOWNTO exprP DO NT$9 blockStart BLOCK END_BLOCK 
            {
              Object RESULT =null;
              // propagate RESULT from NT$9
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-3)).value;
		int initleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-9)).left;
		int initright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-9)).right;
		Object init = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-9)).value;
		int stepleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-7)).left;
		int stepright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-7)).right;
		Object step = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-7)).value;
		int limitleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-5)).left;
		int limitright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-5)).right;
		Object limit = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-5)).value;
		 endForLoop(); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("forStruct",26, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-10)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 178: // forInit ::= IDENTIFIER EQ exprP 
            {
              Object RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		Object id = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int eqleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int eqright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Object eq = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int expleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int expright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object exp = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
              Symbol idSym = tokenFrom(id, idleft, idright, sym.IDENTIFIER);
              Symbol eqSym = tokenFrom(eq, eqleft, eqright, sym.EQ);
              String name = lexeme(id);
              SymbolInfo info = lookupSymbol(name);
              ExprAttr rhs = (ExprAttr)exp;
              if (info == null) {
                  reportSemanticError("Variable '" + name + "' no declarada", idSym);
                  RESULT = ExprAttr.invalid();
              } else {
                  recordAssignment(info, rhs, eqSym);
                  RESULT = new ExprAttr(info.name, info.type, false);
              }
          
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("forInit",49, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 179: // forInit ::= arrayElement EQ exprP 
            {
              Object RESULT =null;
		int elemleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int elemright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		Object elem = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int eqleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int eqright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Object eq = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int expleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int expright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object exp = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
              Symbol eqSym = tokenFrom(eq, eqleft, eqright, sym.EQ);
              reportSemanticError("Los ciclos FOR requieren una variable ESCALAR como control", eqSym);
              RESULT = ExprAttr.invalid();
          
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("forInit",49, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 180: // stepValue ::= exprP 
            {
              Object RESULT =null;
		int expleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int expright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object exp = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 RESULT = ensureNumeric((ExprAttr)exp, null, "step value"); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("stepValue",50, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 181: // arrayIns ::= INT ARRAY IDENTIFIER SQUARES INT_LITERAL SQUAREC 
            {
              Object RESULT =null;
		int IDleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).left;
		int IDright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).right;
		Object ID = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-3)).value;
		int SZleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int SZright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Object SZ = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		 Symbol idSym = tokenFrom(ID, IDleft, IDright, sym.IDENTIFIER); Symbol szSym = tokenFrom(SZ, SZleft, SZright, sym.INT_LITERAL); String name = lexeme(ID); int len = Math.max(0, literalToInt(szSym)); SymbolInfo info = declareSymbol(currentHash, name, "INT", true, len, false, false, idSym); if (info != null) { emit("declare_arr " + name + "[" + len + "] INT"); if (len > 0) emit("arr_pad_zero " + name + ", 0, " + len); } 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("arrayIns",14, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-5)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 182: // arrayIns ::= CHAR ARRAY IDENTIFIER SQUARES INT_LITERAL SQUAREC 
            {
              Object RESULT =null;
		int IDleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).left;
		int IDright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).right;
		Object ID = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-3)).value;
		int SZleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int SZright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Object SZ = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		 Symbol idSym = tokenFrom(ID, IDleft, IDright, sym.IDENTIFIER); Symbol szSym = tokenFrom(SZ, SZleft, SZright, sym.INT_LITERAL); String name = lexeme(ID); int len = Math.max(0, literalToInt(szSym)); SymbolInfo info = declareSymbol(currentHash, name, "CHAR", true, len, false, false, idSym); if (info != null) { emit("declare_arr " + name + "[" + len + "] CHAR"); if (len > 0) emit("arr_pad_zero " + name + ", 0, " + len); } 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("arrayIns",14, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-5)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 183: // arrayInsGl ::= GLOBAL INT ARRAY IDENTIFIER SQUARES INT_LITERAL SQUAREC 
            {
              Object RESULT =null;
		int IDleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).left;
		int IDright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).right;
		Object ID = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-3)).value;
		int SZleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int SZright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Object SZ = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		 Symbol idSym = tokenFrom(ID, IDleft, IDright, sym.IDENTIFIER); Symbol szSym = tokenFrom(SZ, SZleft, SZright, sym.INT_LITERAL); String name = lexeme(ID); int len = Math.max(0, literalToInt(szSym)); SymbolInfo info = declareSymbol(globalHash, name, "INT", true, len, false, true, idSym); if (info != null) { emit("declare_global_arr " + name + "[" + len + "] INT"); if (len > 0) emit("arr_pad_zero " + name + ", 0, " + len); } 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("arrayInsGl",38, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-6)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 184: // arrayInsGl ::= GLOBAL CHAR ARRAY IDENTIFIER SQUARES INT_LITERAL SQUAREC 
            {
              Object RESULT =null;
		int IDleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).left;
		int IDright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).right;
		Object ID = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-3)).value;
		int SZleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int SZright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Object SZ = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		 Symbol idSym = tokenFrom(ID, IDleft, IDright, sym.IDENTIFIER); Symbol szSym = tokenFrom(SZ, SZleft, SZright, sym.INT_LITERAL); String name = lexeme(ID); int len = Math.max(0, literalToInt(szSym)); SymbolInfo info = declareSymbol(globalHash, name, "CHAR", true, len, false, true, idSym); if (info != null) { emit("declare_global_arr " + name + "[" + len + "] CHAR"); if (len > 0) emit("arr_pad_zero " + name + ", 0, " + len); } 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("arrayInsGl",38, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-6)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 185: // arrayLetStmt ::= LET scalarType IDENTIFIER SQUARES INT_LITERAL SQUAREC 
            {
              Object RESULT =null;
		int tleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-4)).left;
		int tright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-4)).right;
		String t = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-4)).value;
		int IDleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).left;
		int IDright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).right;
		Object ID = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-3)).value;
		int SZleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int SZright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Object SZ = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		
                    Symbol idSym = tokenFrom(ID, IDleft, IDright, sym.IDENTIFIER);
                    Symbol szSym = tokenFrom(SZ, SZleft, SZright, sym.INT_LITERAL);
                    String name = lexeme(ID);
                    String elementType = t != null ? t.toString() : "INT";
                    int len = Math.max(0, literalToInt(szSym));
                    SymbolInfo info = declareSymbol(currentHash, name, elementType, true, len, false, false, idSym);
                    if (info != null) {
                        emit("declare_arr " + name + "[" + len + "] " + elementType);
                        initializeArrayValues(info, null, idSym);
                    }
                
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("arrayLetStmt",20, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-5)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 186: // arrayLetStmt ::= LET scalarType IDENTIFIER SQUARES INT_LITERAL SQUAREC EQ arrayLiteral 
            {
              Object RESULT =null;
		int tleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-6)).left;
		int tright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-6)).right;
		String t = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-6)).value;
		int IDleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-5)).left;
		int IDright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-5)).right;
		Object ID = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-5)).value;
		int SZleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).left;
		int SZright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).right;
		Object SZ = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-3)).value;
		int eqleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int eqright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Object eq = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int valsleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int valsright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		ArrayList vals = (ArrayList)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
                    Symbol idSym = tokenFrom(ID, IDleft, IDright, sym.IDENTIFIER);
                    Symbol szSym = tokenFrom(SZ, SZleft, SZright, sym.INT_LITERAL);
                    Symbol eqSym = tokenFrom(eq, eqleft, eqright, sym.EQ);
                    String name = lexeme(ID);
                    String elementType = t != null ? t.toString() : "INT";
                    int len = Math.max(0, literalToInt(szSym));
                    SymbolInfo info = declareSymbol(currentHash, name, elementType, true, len, false, false, idSym);
                    if (info != null) {
                        emit("declare_arr " + name + "[" + len + "] " + elementType);
                        initializeArrayValues(info, (ArrayList<ExprAttr>)vals, eqSym);
                    }
                
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("arrayLetStmt",20, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-7)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 187: // arrayAsig ::= IDENTIFIER EQ SQUARES elementos SQUAREC DOLLAR 
            {
              Object RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-5)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-5)).right;
		Object id = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-5)).value;
		int eqleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-4)).left;
		int eqright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-4)).right;
		Object eq = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-4)).value;
		int valsleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int valsright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		Object vals = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		 
                    Symbol idSym = tokenFrom(id, idleft, idright, sym.IDENTIFIER);
                    Symbol eqSym = tokenFrom(eq, eqleft, eqright, sym.EQ);
                    String name = lexeme(id);
                    SymbolInfo info = lookupSymbol(name);
                    if (info == null) {
                        reportSemanticError("Arreglo '" + name + "' no declarado", idSym);
                    } else if (!info.isArray) {
                        reportSemanticError("'" + name + "' no es un arreglo", idSym);
                    } else {
                        ArrayList<ExprAttr> list = (ArrayList<ExprAttr>)vals;
                        initializeArrayValues(info, list, eqSym);
                    }
                
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("arrayAsig",15, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-5)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 188: // arrayAsig ::= EQ SQUARES elementos SQUAREC DOLLAR 
            {
              Object RESULT =null;
		int eqleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-4)).left;
		int eqright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-4)).right;
		Object eq = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-4)).value;
		 Symbol eqSym = tokenFrom(eq, eqleft, eqright, sym.EQ); reportSemanticError("Se requiere identificador para asignar arreglo", eqSym); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("arrayAsig",15, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-4)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 189: // elementos ::= compAritOp COMA elementos 
            {
              Object RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int eright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		Object e = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int restleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int restright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object rest = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 ArrayList<ExprAttr> tmp = new ArrayList<>(); tmp.add((ExprAttr)e); tmp.addAll((ArrayList<ExprAttr>)rest); RESULT = tmp; 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("elementos",17, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 190: // elementos ::= compAritOp 
            {
              Object RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int eright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object e = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 ArrayList<ExprAttr> tmp = new ArrayList<>(); tmp.add((ExprAttr)e); RESULT = tmp; 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("elementos",17, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 191: // arrayLiteral ::= INIT_BLOCK arrayLiteralItems END_BLOCK 
            {
              ArrayList RESULT =null;
		int valsleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int valsright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		ArrayList vals = (ArrayList)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		 RESULT = (ArrayList<ExprAttr>)vals; 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("arrayLiteral",54, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 192: // arrayLiteral ::= INIT_BLOCK END_BLOCK 
            {
              ArrayList RESULT =null;
		 RESULT = new ArrayList<ExprAttr>(); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("arrayLiteral",54, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 193: // arrayLiteralItems ::= exprP COMA arrayLiteralItems 
            {
              ArrayList RESULT =null;
		int expleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int expright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		Object exp = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int restleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int restright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		ArrayList rest = (ArrayList)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 ArrayList<ExprAttr> list = new ArrayList<>(); list.add((ExprAttr)exp); list.addAll((ArrayList<ExprAttr>)rest); RESULT = list; 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("arrayLiteralItems",55, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 194: // arrayLiteralItems ::= exprP 
            {
              ArrayList RESULT =null;
		int expleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int expright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object exp = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 ArrayList<ExprAttr> list = new ArrayList<>(); list.add((ExprAttr)exp); RESULT = list; 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("arrayLiteralItems",55, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 195: // arrayInsAsign ::= arrayIns arrayAsig 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("arrayInsAsign",16, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 196: // arrayInsAsignGl ::= arrayInsGl arrayAsig 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("arrayInsAsignGl",42, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 197: // arrayElement ::= IDENTIFIER SQUARES compAritOp SQUAREC 
            {
              Object RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).right;
		Object id = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-3)).value;
		int exprleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int exprright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Object expr = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		 Symbol idSym = tokenFrom(id, idleft, idright, sym.IDENTIFIER); RESULT = arrayAccess(lexeme(id), (ExprAttr)expr, idSym, null); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("arrayElement",34, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 198: // paramStruct ::= PARAM INT IDENTIFIER 
            {
              Object RESULT =null;
		int IDleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int IDright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object ID = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 String lex = lexeme(ID); String target=(currentHash!=null?currentHash:globalHash); ensureScopeBucket(target); scopePrograma.get(target).add("Instancia PARAM: " + lex + ":" + "INT" + ":line=" + (IDleft+1) + ":col=" + (IDright+1)); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("paramStruct",35, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 199: // paramStruct ::= PARAM CHAR IDENTIFIER 
            {
              Object RESULT =null;
		int IDleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int IDright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object ID = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 String lex = lexeme(ID); String target=(currentHash!=null?currentHash:globalHash); ensureScopeBucket(target); scopePrograma.get(target).add("Instancia PARAM: " + lex + ":" + "CHAR" + ":line=" + (IDleft+1) + ":col=" + (IDright+1)); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("paramStruct",35, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 200: // paramStruct ::= PARAM STRING IDENTIFIER 
            {
              Object RESULT =null;
		int IDleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int IDright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object ID = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 String lex = lexeme(ID); String target=(currentHash!=null?currentHash:globalHash); ensureScopeBucket(target); scopePrograma.get(target).add("Instancia PARAM: " + lex + ":" + "STRING" + ":line=" + (IDleft+1) + ":col=" + (IDright+1)); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("paramStruct",35, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 201: // paramStruct ::= PARAM FLOAT IDENTIFIER 
            {
              Object RESULT =null;
		int IDleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int IDright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object ID = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 String lex = lexeme(ID); String target=(currentHash!=null?currentHash:globalHash); ensureScopeBucket(target); scopePrograma.get(target).add("Instancia PARAM: " + lex + ":" + "FLOAT" + ":line=" + (IDleft+1) + ":col=" + (IDright+1)); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("paramStruct",35, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 202: // paramStruct ::= PARAM BOOL IDENTIFIER 
            {
              Object RESULT =null;
		int IDleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int IDright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object ID = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 String lex = lexeme(ID); String target=(currentHash!=null?currentHash:globalHash); ensureScopeBucket(target); scopePrograma.get(target).add("Instancia PARAM: " + lex + ":" + "BOOL" + ":line=" + (IDleft+1) + ":col=" + (IDright+1)); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("paramStruct",35, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 203: // paramList ::= paramStruct paramList 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("paramList",36, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 204: // paramList ::= paramStruct 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("paramList",36, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 205: // outPutStruct ::= OUTPUT UKRA exprP RUSS 
            {
              Object RESULT =null;
		int expleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int expright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Object exp = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		 ExprAttr value = (ExprAttr)exp; if (value != null && value.isValid()) emit("print " + value.place); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("outPutStruct",10, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /* . . . . . .*/
          default:
            throw new Exception(
               "Invalid action number "+CUP$Parser$act_num+"found in internal parse table");

        }
    } /* end of method */

  /** Method splitting the generated action code into several parts. */
  public final java_cup.runtime.Symbol CUP$Parser$do_action(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack            CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
              return CUP$Parser$do_action_part00000000(
                               CUP$Parser$act_num,
                               CUP$Parser$parser,
                               CUP$Parser$stack,
                               CUP$Parser$top);
    }
}

}
