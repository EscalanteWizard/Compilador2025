
//----------------------------------------------------
// The following code was generated by CUP v0.11b 20160615 (GIT 4ac7450)
//----------------------------------------------------

import java_cup.runtime.*;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.Map;
import java.util.Deque;
import java.util.ArrayDeque;
import java.util.List;
import java.util.ArrayList;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.regex.Pattern;
import java.util.regex.Matcher;
import java_cup.runtime.XMLElement;

/** CUP v0.11b 20160615 (GIT 4ac7450) generated parser.
  */
@SuppressWarnings({"rawtypes"})
public class Parser extends java_cup.runtime.lr_parser {

 public final Class getSymbolContainer() {
    return sym.class;
}

  /** Default constructor. */
  @Deprecated
  public Parser() {super();}

  /** Constructor which sets the default scanner. */
  @Deprecated
  public Parser(java_cup.runtime.Scanner s) {super(s);}

  /** Constructor which sets the default scanner. */
  public Parser(java_cup.runtime.Scanner s, java_cup.runtime.SymbolFactory sf) {super(s,sf);}

  /** Production table. */
  protected static final short _production_table[][] = 
    unpackFromStrings(new String[] {
    "\000\273\000\002\002\004\000\002\065\002\000\002\003" +
    "\004\000\002\045\004\000\002\045\003\000\002\045\004" +
    "\000\002\045\003\000\002\045\005\000\002\045\004\000" +
    "\002\045\005\000\002\045\004\000\002\045\005\000\002" +
    "\045\004\000\002\045\004\000\002\045\003\000\002\045" +
    "\004\000\002\045\003\000\002\045\004\000\002\045\003" +
    "\000\002\045\004\000\002\006\005\000\002\006\004\000" +
    "\002\006\005\000\002\006\005\000\002\006\004\000\002" +
    "\006\004\000\002\006\004\000\002\006\004\000\002\006" +
    "\005\000\002\006\004\000\002\006\004\000\002\006\004" +
    "\000\002\006\005\000\002\006\004\000\002\006\004\000" +
    "\002\006\004\000\002\006\005\000\002\006\005\000\002" +
    "\006\006\000\002\006\005\000\002\006\004\000\002\006" +
    "\004\000\002\006\004\000\002\006\003\000\002\006\003" +
    "\000\002\006\003\000\002\006\003\000\002\006\004\000" +
    "\002\006\004\000\002\006\003\000\002\006\003\000\002" +
    "\006\003\000\002\006\004\000\002\006\003\000\002\006" +
    "\003\000\002\006\003\000\002\006\004\000\002\006\004" +
    "\000\002\006\005\000\002\006\004\000\002\006\003\000" +
    "\002\006\003\000\002\006\003\000\002\063\005\000\002" +
    "\063\004\000\002\064\004\000\002\064\003\000\002\024" +
    "\003\000\002\024\003\000\002\007\003\000\002\007\005" +
    "\000\002\007\005\000\002\011\003\000\002\011\005\000" +
    "\002\011\005\000\002\011\005\000\002\011\005\000\002" +
    "\010\003\000\002\010\004\000\002\010\003\000\002\010" +
    "\003\000\002\010\003\000\002\010\004\000\002\010\004" +
    "\000\002\010\006\000\002\010\003\000\002\010\006\000" +
    "\002\010\005\000\002\010\003\000\002\010\003\000\002" +
    "\034\007\000\002\037\003\000\002\040\005\000\002\040" +
    "\005\000\002\040\003\000\002\041\005\000\002\041\005" +
    "\000\002\041\005\000\002\041\005\000\002\041\005\000" +
    "\002\041\005\000\002\041\004\000\002\041\003\000\002" +
    "\005\006\000\002\005\006\000\002\005\005\000\002\004" +
    "\005\000\002\004\005\000\002\004\005\000\002\004\005" +
    "\000\002\004\005\000\002\047\006\000\002\047\006\000" +
    "\002\047\006\000\002\047\006\000\002\047\006\000\002" +
    "\050\004\000\002\051\004\000\002\036\004\000\002\036" +
    "\004\000\002\036\004\000\002\036\004\000\002\036\004" +
    "\000\002\012\007\000\002\053\005\000\002\053\004\000" +
    "\002\053\002\000\002\054\003\000\002\054\002\000\002" +
    "\055\003\000\002\055\005\000\002\056\004\000\002\056" +
    "\004\000\002\056\004\000\002\056\004\000\002\056\004" +
    "\000\002\015\004\000\002\016\003\000\002\016\002\000" +
    "\002\057\003\000\002\057\002\000\002\060\003\000\002" +
    "\060\005\000\002\013\007\000\002\035\003\000\002\066" +
    "\002\000\002\027\011\000\002\025\004\000\002\025\003" +
    "\000\002\067\002\000\002\026\010\000\002\070\002\000" +
    "\002\026\010\000\002\033\003\000\002\071\002\000\002" +
    "\072\002\000\002\030\016\000\002\017\003\000\002\017" +
    "\003\000\002\031\007\000\002\031\002\000\002\073\002" +
    "\000\002\032\015\000\002\074\002\000\002\032\015\000" +
    "\002\061\005\000\002\061\005\000\002\062\003\000\002" +
    "\020\010\000\002\020\010\000\002\046\011\000\002\046" +
    "\011\000\002\021\010\000\002\021\007\000\002\023\005" +
    "\000\002\023\003\000\002\022\004\000\002\052\004\000" +
    "\002\042\006\000\002\043\005\000\002\043\005\000\002" +
    "\043\005\000\002\043\005\000\002\043\005\000\002\044" +
    "\004\000\002\044\003\000\002\014\006" });

  /** Access to production table. */
  public short[][] production_table() {return _production_table;}

  /** Parse-action table. */
  protected static final short[][] _action_table = 
    unpackFromStrings(new String[] {
    "\000\u0161\000\026\003\000\020\000\040\000\041\000\042" +
    "\000\043\000\044\000\046\000\047\000\051\000\001\002" +
    "\000\026\003\024\020\030\040\011\041\016\042\012\043" +
    "\031\044\015\046\027\047\026\051\021\001\002\000\004" +
    "\002\006\001\002\000\004\002\001\001\002\000\030\002" +
    "\uffef\003\024\020\030\040\011\041\016\042\012\043\031" +
    "\044\015\046\027\047\026\051\021\001\002\000\006\016" +
    "\uff83\100\253\001\002\000\004\004\u013b\001\002\000\004" +
    "\004\u0148\001\002\000\006\016\uff83\100\253\001\002\000" +
    "\030\002\ufff1\003\024\020\030\040\011\041\016\042\012" +
    "\043\031\044\015\046\027\047\026\051\021\001\002\000" +
    "\004\004\251\001\002\000\004\004\250\001\002\000\004" +
    "\002\uffff\001\002\000\010\004\235\026\233\104\236\001" +
    "\002\000\006\016\uff71\100\uff71\001\002\000\030\002\ufffb" +
    "\003\024\020\030\040\011\041\016\042\012\043\031\044" +
    "\015\046\027\047\026\051\021\001\002\000\030\002\ufffd" +
    "\003\024\020\030\040\011\041\016\042\012\043\031\044" +
    "\015\046\027\047\026\051\021\001\002\000\026\003\024" +
    "\020\030\040\011\041\016\042\012\043\031\044\015\046" +
    "\027\047\026\051\021\001\002\000\004\104\225\001\002" +
    "\000\014\040\217\041\216\042\215\043\214\044\213\001" +
    "\002\000\010\040\166\042\165\047\164\001\002\000\006" +
    "\021\160\022\157\001\002\000\004\004\156\001\002\000" +
    "\030\002\ufff3\003\024\020\030\040\011\041\016\042\012" +
    "\043\031\044\015\046\027\047\026\051\021\001\002\000" +
    "\010\004\035\026\034\104\037\001\002\000\004\076\151" +
    "\001\002\000\004\026\041\001\002\000\076\002\uff50\003" +
    "\uff50\004\uff50\006\uff50\015\uff50\017\uff50\020\uff50\025\uff50" +
    "\026\uff50\037\uff50\040\uff50\041\uff50\042\uff50\043\uff50\044" +
    "\uff50\046\uff50\047\uff50\051\uff50\052\uff50\053\uff50\055\uff50" +
    "\056\uff50\060\uff50\062\uff50\070\uff50\071\uff50\072\uff50\073" +
    "\uff50\100\uff50\103\uff50\001\002\000\030\002\ufff9\003\024" +
    "\020\030\040\011\041\016\042\012\043\031\044\015\046" +
    "\027\047\026\051\021\001\002\000\004\002\ufffa\001\002" +
    "\000\004\076\042\001\002\000\024\004\056\006\044\015" +
    "\047\025\050\041\061\052\046\053\054\100\057\103\053" +
    "\001\002\000\062\005\uffac\006\uffac\011\uffac\012\uffac\013" +
    "\uffac\014\uffac\024\uffac\027\uffac\030\uffac\031\uffac\032\uffac" +
    "\033\uffac\034\uffac\035\uffac\036\uffac\062\uffac\064\uffac\065" +
    "\uffac\066\uffac\067\uffac\077\uffac\101\uffac\102\uffac\104\uffac" +
    "\001\002\000\010\015\047\041\061\100\146\001\002\000" +
    "\062\005\uffbc\006\uffbc\011\114\012\113\013\111\014\112" +
    "\024\uffbc\027\uffbc\030\uffbc\031\uffbc\032\uffbc\033\uffbc\034" +
    "\uffbc\035\uffbc\036\uffbc\062\uffbc\064\uffbc\065\uffbc\066\uffbc" +
    "\067\uffbc\077\uffbc\101\uffbc\102\uffbc\104\uffbc\001\002\000" +
    "\062\005\uffa9\006\uffa9\011\uffa9\012\uffa9\013\uffa9\014\uffa9" +
    "\024\uffa9\027\uffa9\030\uffa9\031\uffa9\032\uffa9\033\uffa9\034" +
    "\uffa9\035\uffa9\036\uffa9\062\uffa9\064\uffa9\065\uffa9\066\uffa9" +
    "\067\uffa9\077\uffa9\101\uffa9\102\uffa9\104\uffa9\001\002\000" +
    "\062\005\uffbe\006\uffbe\011\uffbe\012\uffbe\013\uffbe\014\uffbe" +
    "\024\uffbe\027\uffbe\030\uffbe\031\uffbe\032\uffbe\033\uffbe\034" +
    "\uffbe\035\uffbe\036\uffbe\062\uffbe\064\uffbe\065\uffbe\066\uffbe" +
    "\067\uffbe\077\uffbe\101\uffbe\102\uffbe\104\uffbe\001\002\000" +
    "\062\005\uffb2\006\uffb2\011\uffb2\012\uffb2\013\uffb2\014\uffb2" +
    "\024\uffb2\027\uffb2\030\uffb2\031\uffb2\032\uffb2\033\uffb2\034" +
    "\uffb2\035\uffb2\036\uffb2\062\uffb2\064\uffb2\065\uffb2\066\uffb2" +
    "\067\uffb2\077\uffb2\101\uffb2\102\uffb2\104\uffb2\001\002\000" +
    "\012\005\074\006\077\024\143\077\uff52\001\002\000\004" +
    "\077\141\001\002\000\062\005\uffb1\006\uffb1\011\uffb1\012" +
    "\uffb1\013\uffb1\014\uffb1\024\uffb1\027\uffb1\030\uffb1\031\uffb1" +
    "\032\uffb1\033\uffb1\034\uffb1\035\uffb1\036\uffb1\062\uffb1\064" +
    "\uffb1\065\uffb1\066\uffb1\067\uffb1\077\uffb1\101\uffb1\102\uffb1" +
    "\104\uffb1\001\002\000\062\005\uffa8\006\uffa8\011\uffa8\012" +
    "\uffa8\013\uffa8\014\uffa8\024\uffa8\027\uffa8\030\uffa8\031\uffa8" +
    "\032\uffa8\033\uffa8\034\uffa8\035\uffa8\036\uffa8\062\uffa8\064" +
    "\uffa8\065\uffa8\066\uffa8\067\uffa8\077\uffa8\101\uffa8\102\uffa8" +
    "\104\uffa8\001\002\000\062\005\uffb9\006\uffb9\011\uffb9\012" +
    "\uffb9\013\uffb9\014\uffb9\024\uffb9\027\uffb9\030\uffb9\031\uffb9" +
    "\032\uffb9\033\uffb9\034\uffb9\035\uffb9\036\uffb9\062\uffb9\064" +
    "\uffb9\065\uffb9\066\uffb9\067\uffb9\077\uffb9\101\uffb9\102\uffb9" +
    "\104\uffb9\001\002\000\072\005\uffb0\006\uffb0\007\125\010" +
    "\127\011\uffb0\012\uffb0\013\uffb0\014\uffb0\024\uffb0\027\uffb0" +
    "\030\uffb0\031\uffb0\032\uffb0\033\uffb0\034\uffb0\035\uffb0\036" +
    "\uffb0\062\uffb0\064\uffb0\065\uffb0\066\uffb0\067\uffb0\076\130" +
    "\077\uffb0\100\126\101\uffb0\102\uffb0\104\uffb0\001\002\000" +
    "\026\004\056\006\044\015\047\025\050\037\064\041\061" +
    "\052\046\053\054\100\057\103\053\001\002\000\062\005" +
    "\uffb4\006\uffb4\011\uffb4\012\uffb4\013\uffb4\014\uffb4\024\uffb4" +
    "\027\uffb4\030\uffb4\031\uffb4\032\uffb4\033\uffb4\034\uffb4\035" +
    "\uffb4\036\uffb4\062\uffb4\064\uffb4\065\uffb4\066\uffb4\067\uffb4" +
    "\077\uffb4\101\uffb4\102\uffb4\104\uffb4\001\002\000\062\005" +
    "\uffbd\006\uffbd\011\uffbd\012\uffbd\013\uffbd\014\uffbd\024\uffbd" +
    "\027\uffbd\030\uffbd\031\uffbd\032\uffbd\033\uffbd\034\uffbd\035" +
    "\uffbd\036\uffbd\062\uffbd\064\uffbd\065\uffbd\066\uffbd\067\uffbd" +
    "\077\uffbd\101\uffbd\102\uffbd\104\uffbd\001\002\000\004\101" +
    "\124\001\002\000\050\005\074\006\077\024\uff9b\027\102" +
    "\030\076\031\103\032\101\033\100\034\075\035\uff9b\036" +
    "\uff9b\062\uff9b\064\uff9b\065\uff9b\066\uff9b\067\uff9b\101\uff9b" +
    "\102\uff9b\104\uff9b\001\002\000\026\004\056\006\044\015" +
    "\047\025\050\037\064\041\061\052\046\053\054\100\057" +
    "\103\053\001\002\000\030\024\uffa3\035\uffa3\036\uffa3\062" +
    "\uffa3\064\uffa3\065\uffa3\066\uffa3\067\uffa3\101\uffa3\102\uffa3" +
    "\104\uffa3\001\002\000\030\024\uffa6\035\067\036\070\062" +
    "\uffa6\064\uffa6\065\uffa6\066\uffa6\067\uffa6\101\uffa6\102\uffa6" +
    "\104\uffa6\001\002\000\026\004\056\006\044\015\047\025" +
    "\050\037\064\041\061\052\046\053\054\100\057\103\053" +
    "\001\002\000\026\004\056\006\044\015\047\025\050\037" +
    "\064\041\061\052\046\053\054\100\057\103\053\001\002" +
    "\000\030\024\uffa4\035\uffa4\036\uffa4\062\uffa4\064\uffa4\065" +
    "\uffa4\066\uffa4\067\uffa4\101\uffa4\102\uffa4\104\uffa4\001\002" +
    "\000\030\024\uffa5\035\uffa5\036\uffa5\062\uffa5\064\uffa5\065" +
    "\uffa5\066\uffa5\067\uffa5\101\uffa5\102\uffa5\104\uffa5\001\002" +
    "\000\030\024\uff9c\035\uff9c\036\uff9c\062\uff9c\064\uff9c\065" +
    "\uff9c\066\uff9c\067\uff9c\101\uff9c\102\uff9c\104\uff9c\001\002" +
    "\000\024\004\056\006\044\015\047\025\050\041\061\052" +
    "\046\053\054\100\057\103\053\001\002\000\024\004\056" +
    "\006\044\015\047\025\050\041\061\052\046\053\054\100" +
    "\057\103\053\001\002\000\024\004\056\006\044\015\047" +
    "\025\050\041\061\052\046\053\054\100\057\103\053\001" +
    "\002\000\024\004\056\006\044\015\047\025\050\041\061" +
    "\052\046\053\054\100\057\103\053\001\002\000\024\004" +
    "\056\006\044\015\047\025\050\041\061\052\046\053\054" +
    "\100\057\103\053\001\002\000\024\004\056\006\044\015" +
    "\047\025\050\041\061\052\046\053\054\100\057\103\053" +
    "\001\002\000\024\004\056\006\044\015\047\025\050\041" +
    "\061\052\046\053\054\100\057\103\053\001\002\000\024" +
    "\004\056\006\044\015\047\025\050\041\061\052\046\053" +
    "\054\100\057\103\053\001\002\000\034\005\074\006\077" +
    "\024\uffa0\035\uffa0\036\uffa0\062\uffa0\064\uffa0\065\uffa0\066" +
    "\uffa0\067\uffa0\101\uffa0\102\uffa0\104\uffa0\001\002\000\034" +
    "\005\074\006\077\024\uffa2\035\uffa2\036\uffa2\062\uffa2\064" +
    "\uffa2\065\uffa2\066\uffa2\067\uffa2\101\uffa2\102\uffa2\104\uffa2" +
    "\001\002\000\034\005\074\006\077\024\uffa1\035\uffa1\036" +
    "\uffa1\062\uffa1\064\uffa1\065\uffa1\066\uffa1\067\uffa1\101\uffa1" +
    "\102\uffa1\104\uffa1\001\002\000\034\005\074\006\077\024" +
    "\uff9d\035\uff9d\036\uff9d\062\uff9d\064\uff9d\065\uff9d\066\uff9d" +
    "\067\uff9d\101\uff9d\102\uff9d\104\uff9d\001\002\000\062\005" +
    "\uffba\006\uffba\011\114\012\113\013\111\014\112\024\uffba" +
    "\027\uffba\030\uffba\031\uffba\032\uffba\033\uffba\034\uffba\035" +
    "\uffba\036\uffba\062\uffba\064\uffba\065\uffba\066\uffba\067\uffba" +
    "\077\uffba\101\uffba\102\uffba\104\uffba\001\002\000\024\004" +
    "\056\006\044\015\047\025\050\041\061\052\046\053\054" +
    "\100\057\103\053\001\002\000\024\004\056\006\044\015" +
    "\047\025\050\041\061\052\046\053\054\100\057\103\053" +
    "\001\002\000\024\004\056\006\044\015\047\025\050\041" +
    "\061\052\046\053\054\100\057\103\053\001\002\000\024" +
    "\004\056\006\044\015\047\025\050\041\061\052\046\053" +
    "\054\100\057\103\053\001\002\000\062\005\uffb8\006\uffb8" +
    "\011\uffb8\012\uffb8\013\uffb8\014\uffb8\024\uffb8\027\uffb8\030" +
    "\uffb8\031\uffb8\032\uffb8\033\uffb8\034\uffb8\035\uffb8\036\uffb8" +
    "\062\uffb8\064\uffb8\065\uffb8\066\uffb8\067\uffb8\077\uffb8\101" +
    "\uffb8\102\uffb8\104\uffb8\001\002\000\062\005\uffb7\006\uffb7" +
    "\011\uffb7\012\uffb7\013\uffb7\014\uffb7\024\uffb7\027\uffb7\030" +
    "\uffb7\031\uffb7\032\uffb7\033\uffb7\034\uffb7\035\uffb7\036\uffb7" +
    "\062\uffb7\064\uffb7\065\uffb7\066\uffb7\067\uffb7\077\uffb7\101" +
    "\uffb7\102\uffb7\104\uffb7\001\002\000\062\005\uffb6\006\uffb6" +
    "\011\uffb6\012\uffb6\013\uffb6\014\uffb6\024\uffb6\027\uffb6\030" +
    "\uffb6\031\uffb6\032\uffb6\033\uffb6\034\uffb6\035\uffb6\036\uffb6" +
    "\062\uffb6\064\uffb6\065\uffb6\066\uffb6\067\uffb6\077\uffb6\101" +
    "\uffb6\102\uffb6\104\uffb6\001\002\000\062\005\uffb5\006\uffb5" +
    "\011\uffb5\012\uffb5\013\uffb5\014\uffb5\024\uffb5\027\uffb5\030" +
    "\uffb5\031\uffb5\032\uffb5\033\uffb5\034\uffb5\035\uffb5\036\uffb5" +
    "\062\uffb5\064\uffb5\065\uffb5\066\uffb5\067\uffb5\077\uffb5\101" +
    "\uffb5\102\uffb5\104\uffb5\001\002\000\034\005\074\006\077" +
    "\024\uff9f\035\uff9f\036\uff9f\062\uff9f\064\uff9f\065\uff9f\066" +
    "\uff9f\067\uff9f\101\uff9f\102\uff9f\104\uff9f\001\002\000\034" +
    "\005\074\006\077\024\uff9e\035\uff9e\036\uff9e\062\uff9e\064" +
    "\uff9e\065\uff9e\066\uff9e\067\uff9e\101\uff9e\102\uff9e\104\uff9e" +
    "\001\002\000\062\005\uffbb\006\uffbb\011\114\012\113\013" +
    "\111\014\112\024\uffbb\027\uffbb\030\uffbb\031\uffbb\032\uffbb" +
    "\033\uffbb\034\uffbb\035\uffbb\036\uffbb\062\uffbb\064\uffbb\065" +
    "\uffbb\066\uffbb\067\uffbb\077\uffbb\101\uffbb\102\uffbb\104\uffbb" +
    "\001\002\000\062\005\uffaa\006\uffaa\011\uffaa\012\uffaa\013" +
    "\uffaa\014\uffaa\024\uffaa\027\uffaa\030\uffaa\031\uffaa\032\uffaa" +
    "\033\uffaa\034\uffaa\035\uffaa\036\uffaa\062\uffaa\064\uffaa\065" +
    "\uffaa\066\uffaa\067\uffaa\077\uffaa\101\uffaa\102\uffaa\104\uffaa" +
    "\001\002\000\062\005\uffaf\006\uffaf\011\uffaf\012\uffaf\013" +
    "\uffaf\014\uffaf\024\uffaf\027\uffaf\030\uffaf\031\uffaf\032\uffaf" +
    "\033\uffaf\034\uffaf\035\uffaf\036\uffaf\062\uffaf\064\uffaf\065" +
    "\uffaf\066\uffaf\067\uffaf\077\uffaf\101\uffaf\102\uffaf\104\uffaf" +
    "\001\002\000\030\004\056\006\044\015\047\025\050\037" +
    "\064\041\061\052\046\053\054\100\057\101\uff75\103\053" +
    "\001\002\000\062\005\uffae\006\uffae\011\uffae\012\uffae\013" +
    "\uffae\014\uffae\024\uffae\027\uffae\030\uffae\031\uffae\032\uffae" +
    "\033\uffae\034\uffae\035\uffae\036\uffae\062\uffae\064\uffae\065" +
    "\uffae\066\uffae\067\uffae\077\uffae\101\uffae\102\uffae\104\uffae" +
    "\001\002\000\024\004\056\006\044\015\047\025\050\041" +
    "\061\052\046\053\054\100\057\103\053\001\002\000\010" +
    "\005\074\006\077\077\132\001\002\000\064\005\uff4f\006" +
    "\uff4f\011\uff4f\012\uff4f\013\uff4f\014\uff4f\024\uff4f\026\uff4f" +
    "\027\uff4f\030\uff4f\031\uff4f\032\uff4f\033\uff4f\034\uff4f\035" +
    "\uff4f\036\uff4f\062\uff4f\064\uff4f\065\uff4f\066\uff4f\067\uff4f" +
    "\077\uff4f\101\uff4f\102\uff4f\104\uff4f\001\002\000\006\024" +
    "\137\101\uff74\001\002\000\004\101\uff76\001\002\000\004" +
    "\101\136\001\002\000\062\005\uffad\006\uffad\011\uffad\012" +
    "\uffad\013\uffad\014\uffad\024\uffad\027\uffad\030\uffad\031\uffad" +
    "\032\uffad\033\uffad\034\uffad\035\uffad\036\uffad\062\uffad\064" +
    "\uffad\065\uffad\066\uffad\067\uffad\077\uffad\101\uffad\102\uffad" +
    "\104\uffad\001\002\000\026\004\056\006\044\015\047\025" +
    "\050\037\064\041\061\052\046\053\054\100\057\103\053" +
    "\001\002\000\004\101\uff73\001\002\000\004\104\142\001" +
    "\002\000\076\002\uff55\003\uff55\004\uff55\006\uff55\015\uff55" +
    "\017\uff55\020\uff55\025\uff55\026\uff55\037\uff55\040\uff55\041" +
    "\uff55\042\uff55\043\uff55\044\uff55\046\uff55\047\uff55\051\uff55" +
    "\052\uff55\053\uff55\055\uff55\056\uff55\060\uff55\062\uff55\070" +
    "\uff55\071\uff55\072\uff55\073\uff55\100\uff55\103\uff55\001\002" +
    "\000\024\004\056\006\044\015\047\025\050\041\061\052" +
    "\046\053\054\100\057\103\053\001\002\000\004\077\uff53" +
    "\001\002\000\062\005\uffb3\006\uffb3\011\uffb3\012\uffb3\013" +
    "\uffb3\014\uffb3\024\uffb3\027\uffb3\030\uffb3\031\uffb3\032\uffb3" +
    "\033\uffb3\034\uffb3\035\uffb3\036\uffb3\062\uffb3\064\uffb3\065" +
    "\uffb3\066\uffb3\067\uffb3\077\uffb3\101\uffb3\102\uffb3\104\uffb3" +
    "\001\002\000\026\004\056\006\044\015\047\025\050\037" +
    "\064\041\061\052\046\053\054\100\057\103\053\001\002" +
    "\000\004\101\150\001\002\000\062\005\uffab\006\uffab\011" +
    "\uffab\012\uffab\013\uffab\014\uffab\024\uffab\027\uffab\030\uffab" +
    "\031\uffab\032\uffab\033\uffab\034\uffab\035\uffab\036\uffab\062" +
    "\uffab\064\uffab\065\uffab\066\uffab\067\uffab\077\uffab\101\uffab" +
    "\102\uffab\104\uffab\001\002\000\024\004\056\006\044\015" +
    "\047\025\050\041\061\052\046\053\054\100\057\103\053" +
    "\001\002\000\004\077\153\001\002\000\004\104\154\001" +
    "\002\000\076\002\uff54\003\uff54\004\uff54\006\uff54\015\uff54" +
    "\017\uff54\020\uff54\025\uff54\026\uff54\037\uff54\040\uff54\041" +
    "\uff54\042\uff54\043\uff54\044\uff54\046\uff54\047\uff54\051\uff54" +
    "\052\uff54\053\uff54\055\uff54\056\uff54\060\uff54\062\uff54\070" +
    "\uff54\071\uff54\072\uff54\073\uff54\100\uff54\103\uff54\001\002" +
    "\000\004\002\ufff4\001\002\000\006\016\uff89\100\uff89\001" +
    "\002\000\006\021\uffbf\022\uffbf\001\002\000\076\002\uffc1" +
    "\003\uffc1\004\uffc1\006\uffc1\015\uffc1\017\uffc1\020\uffc1\025" +
    "\uffc1\026\uffc1\037\uffc1\040\uffc1\041\uffc1\042\uffc1\043\uffc1" +
    "\044\uffc1\046\uffc1\047\uffc1\051\uffc1\052\uffc1\053\uffc1\055" +
    "\uffc1\056\uffc1\060\uffc1\062\uffc1\070\uffc1\071\uffc1\072\uffc1" +
    "\073\uffc1\100\uffc1\103\uffc1\001\002\000\006\021\163\022" +
    "\162\001\002\000\006\021\uffc0\022\uffc0\001\002\000\076" +
    "\002\uffc2\003\uffc2\004\uffc2\006\uffc2\015\uffc2\017\uffc2\020" +
    "\uffc2\025\uffc2\026\uffc2\037\uffc2\040\uffc2\041\uffc2\042\uffc2" +
    "\043\uffc2\044\uffc2\046\uffc2\047\uffc2\051\uffc2\052\uffc2\053" +
    "\uffc2\055\uffc2\056\uffc2\060\uffc2\062\uffc2\070\uffc2\071\uffc2" +
    "\072\uffc2\073\uffc2\100\uffc2\103\uffc2\001\002\000\014\040" +
    "\205\041\203\042\204\043\202\044\201\001\002\000\004" +
    "\045\174\001\002\000\004\045\167\001\002\000\004\004" +
    "\170\001\002\000\004\076\171\001\002\000\004\015\172" +
    "\001\002\000\004\077\173\001\002\000\010\004\uff57\026" +
    "\uff57\104\uff57\001\002\000\004\004\175\001\002\000\004" +
    "\076\176\001\002\000\004\015\177\001\002\000\004\077" +
    "\200\001\002\000\010\004\uff56\026\uff56\104\uff56\001\002" +
    "\000\004\004\212\001\002\000\004\004\211\001\002\000" +
    "\004\004\210\001\002\000\004\004\207\001\002\000\004" +
    "\004\206\001\002\000\010\004\uff92\026\uff92\104\uff92\001" +
    "\002\000\010\004\uff91\026\uff91\104\uff91\001\002\000\010" +
    "\004\uff90\026\uff90\104\uff90\001\002\000\010\004\uff8e\026" +
    "\uff8e\104\uff8e\001\002\000\010\004\uff8f\026\uff8f\104\uff8f" +
    "\001\002\000\004\004\224\001\002\000\004\004\223\001" +
    "\002\000\004\004\222\001\002\000\004\004\221\001\002" +
    "\000\004\004\220\001\002\000\010\004\uff97\026\uff97\104" +
    "\uff97\001\002\000\010\004\uff95\026\uff95\104\uff95\001\002" +
    "\000\010\004\uff96\026\uff96\104\uff96\001\002\000\010\004" +
    "\uff94\026\uff94\104\uff94\001\002\000\010\004\uff93\026\uff93" +
    "\104\uff93\001\002\000\030\002\ufff5\003\024\020\030\040" +
    "\011\041\016\042\012\043\031\044\015\046\027\047\026" +
    "\051\021\001\002\000\004\002\ufff6\001\002\000\004\002" +
    "\uffee\001\002\000\004\002\ufffe\001\002\000\004\002\ufffc" +
    "\001\002\000\076\002\uff8c\003\uff8c\004\uff8c\006\uff8c\015" +
    "\uff8c\017\uff8c\020\uff8c\025\uff8c\026\uff8c\037\uff8c\040\uff8c" +
    "\041\uff8c\042\uff8c\043\uff8c\044\uff8c\046\uff8c\047\uff8c\051" +
    "\uff8c\052\uff8c\053\uff8c\055\uff8c\056\uff8c\060\uff8c\062\uff8c" +
    "\070\uff8c\071\uff8c\072\uff8c\073\uff8c\100\uff8c\103\uff8c\001" +
    "\002\000\026\004\056\006\044\015\047\025\050\037\064" +
    "\041\061\052\046\053\054\100\057\103\053\001\002\000" +
    "\004\026\243\001\002\000\006\026\240\076\130\001\002" +
    "\000\030\002\ufff7\003\024\020\030\040\011\041\016\042" +
    "\012\043\031\044\015\046\027\047\026\051\021\001\002" +
    "\000\004\002\ufff8\001\002\000\026\004\056\006\044\015" +
    "\047\025\050\037\064\041\061\052\046\053\054\100\057" +
    "\103\053\001\002\000\004\104\242\001\002\000\076\002" +
    "\uff9a\003\uff9a\004\uff9a\006\uff9a\015\uff9a\017\uff9a\020\uff9a" +
    "\025\uff9a\026\uff9a\037\uff9a\040\uff9a\041\uff9a\042\uff9a\043" +
    "\uff9a\044\uff9a\046\uff9a\047\uff9a\051\uff9a\052\uff9a\053\uff9a" +
    "\055\uff9a\056\uff9a\060\uff9a\062\uff9a\070\uff9a\071\uff9a\072" +
    "\uff9a\073\uff9a\100\uff9a\103\uff9a\001\002\000\026\004\056" +
    "\006\044\015\047\025\050\037\064\041\061\052\046\053" +
    "\054\100\057\103\053\001\002\000\004\104\245\001\002" +
    "\000\076\002\uff99\003\uff99\004\uff99\006\uff99\015\uff99\017" +
    "\uff99\020\uff99\025\uff99\026\uff99\037\uff99\040\uff99\041\uff99" +
    "\042\uff99\043\uff99\044\uff99\046\uff99\047\uff99\051\uff99\052" +
    "\uff99\053\uff99\055\uff99\056\uff99\060\uff99\062\uff99\070\uff99" +
    "\071\uff99\072\uff99\073\uff99\100\uff99\103\uff99\001\002\000" +
    "\004\104\247\001\002\000\076\002\uff98\003\uff98\004\uff98" +
    "\006\uff98\015\uff98\017\uff98\020\uff98\025\uff98\026\uff98\037" +
    "\uff98\040\uff98\041\uff98\042\uff98\043\uff98\044\uff98\046\uff98" +
    "\047\uff98\051\uff98\052\uff98\053\uff98\055\uff98\056\uff98\060" +
    "\uff98\062\uff98\070\uff98\071\uff98\072\uff98\073\uff98\100\uff98" +
    "\103\uff98\001\002\000\006\016\uff87\100\uff87\001\002\000" +
    "\006\016\uff88\100\uff88\001\002\000\004\002\ufff2\001\002" +
    "\000\020\016\uff81\040\u014f\041\u0156\042\u0155\043\u0151\044" +
    "\u0152\101\u0153\001\002\000\004\016\256\001\002\000\070" +
    "\003\303\004\320\006\044\015\047\020\030\025\050\026" +
    "\233\037\064\040\265\041\313\042\261\043\031\044\015" +
    "\046\027\047\026\051\021\052\046\053\054\055\270\056" +
    "\274\060\276\070\306\071\277\072\263\073\262\100\057" +
    "\103\053\001\002\000\072\003\uff77\004\uff77\006\uff77\015" +
    "\uff77\020\uff77\025\uff77\026\uff77\037\uff77\040\uff77\041\uff77" +
    "\042\uff77\043\uff77\044\uff77\046\uff77\047\uff77\051\uff77\052" +
    "\uff77\053\uff77\055\uff77\056\uff77\060\uff77\070\uff77\071\uff77" +
    "\072\uff77\073\uff77\100\uff77\101\257\103\uff77\001\002\000" +
    "\070\003\uff78\004\uff78\006\uff78\015\uff78\020\uff78\025\uff78" +
    "\026\uff78\037\uff78\040\uff78\041\uff78\042\uff78\043\uff78\044" +
    "\uff78\046\uff78\047\uff78\051\uff78\052\uff78\053\uff78\055\uff78" +
    "\056\uff78\060\uff78\070\uff78\071\uff78\072\uff78\073\uff78\100" +
    "\uff78\103\uff78\001\002\000\070\003\uff79\004\uff79\006\uff79" +
    "\015\uff79\020\uff79\025\uff79\026\uff79\037\uff79\040\uff79\041" +
    "\uff79\042\uff79\043\uff79\044\uff79\046\uff79\047\uff79\051\uff79" +
    "\052\uff79\053\uff79\055\uff79\056\uff79\060\uff79\070\uff79\071" +
    "\uff79\072\uff79\073\uff79\100\uff79\103\uff79\001\002\000\006" +
    "\004\u0148\045\u0149\001\002\000\004\100\u0145\001\002\000" +
    "\004\100\u0141\001\002\000\072\004\uffd3\006\uffd3\015\uffd3" +
    "\017\uffd3\020\uffd3\025\uffd3\026\uffd3\037\uffd3\040\uffd3\041" +
    "\uffd3\042\uffd3\043\uffd3\044\uffd3\046\uffd3\047\uffd3\051\uffd3" +
    "\052\uffd3\053\uffd3\055\uffd3\056\uffd3\060\uffd3\062\uffd3\070" +
    "\uffd3\071\uffd3\072\uffd3\073\uffd3\100\uffd3\103\uffd3\001\002" +
    "\000\006\004\u013b\045\u013c\001\002\000\072\004\uffce\006" +
    "\uffce\015\uffce\017\uffce\020\uffce\025\uffce\026\uffce\037\uffce" +
    "\040\uffce\041\uffce\042\uffce\043\uffce\044\uffce\046\uffce\047" +
    "\uffce\051\uffce\052\uffce\053\uffce\055\uffce\056\uffce\060\uffce" +
    "\062\uffce\070\uffce\071\uffce\072\uffce\073\uffce\100\uffce\103" +
    "\uffce\001\002\000\072\004\uffcb\006\uffcb\015\uffcb\017\uffcb" +
    "\020\uffcb\025\uffcb\026\uffcb\037\uffcb\040\uffcb\041\uffcb\042" +
    "\uffcb\043\uffcb\044\uffcb\046\uffcb\047\uffcb\051\uffcb\052\uffcb" +
    "\053\uffcb\055\uffcb\056\uffcb\060\uffcb\062\uffcb\070\uffcb\071" +
    "\uffcb\072\uffcb\073\uffcb\100\uffcb\103\uffcb\001\002\000\004" +
    "\004\u0125\001\002\000\072\004\uffd5\006\uffd5\015\uffd5\017" +
    "\uffd5\020\uffd5\025\uffd5\026\uffd5\037\uffd5\040\uffd5\041\uffd5" +
    "\042\uffd5\043\uffd5\044\uffd5\046\uffd5\047\uffd5\051\uffd5\052" +
    "\uffd5\053\uffd5\055\uffd5\056\uffd5\060\uffd5\062\uffd5\070\uffd5" +
    "\071\uffd5\072\uffd5\073\uffd5\100\uffd5\103\uffd5\001\002\000" +
    "\010\004\035\026\034\104\u0122\001\002\000\004\104\u0121" +
    "\001\002\000\004\057\u010c\001\002\000\070\004\320\006" +
    "\044\015\047\017\u010b\020\030\025\050\026\233\037\064" +
    "\040\265\041\313\042\261\043\031\044\015\046\027\047" +
    "\026\051\021\052\046\053\054\055\270\056\274\060\276" +
    "\070\367\071\363\072\263\073\262\100\057\103\053\001" +
    "\002\000\070\003\uff67\004\uff67\006\uff67\015\uff67\020\uff67" +
    "\025\uff67\026\uff67\037\uff67\040\uff67\041\uff67\042\uff67\043" +
    "\uff67\044\uff67\046\uff67\047\uff67\051\uff67\052\uff67\053\uff67" +
    "\055\uff67\056\uff67\060\uff67\070\uff67\071\uff67\072\uff67\073" +
    "\uff67\100\uff67\103\uff67\001\002\000\030\004\056\006\044" +
    "\015\047\025\050\037\064\041\061\052\046\053\054\100" +
    "\057\103\053\104\327\001\002\000\072\004\uffca\006\uffca" +
    "\015\uffca\017\uffca\020\uffca\025\uffca\026\uffca\037\uffca\040" +
    "\uffca\041\uffca\042\uffca\043\uffca\044\uffca\046\uffca\047\uffca" +
    "\051\uffca\052\uffca\053\uffca\055\uffca\056\uffca\060\uffca\062" +
    "\uffca\070\uffca\071\uffca\072\uffca\073\uffca\100\uffca\103\uffca" +
    "\001\002\000\072\004\uffcf\006\uffcf\015\uffcf\017\uffcf\020" +
    "\uffcf\025\uffcf\026\uffcf\037\uffcf\040\uffcf\041\uffcf\042\uffcf" +
    "\043\uffcf\044\uffcf\046\uffcf\047\uffcf\051\uffcf\052\uffcf\053" +
    "\uffcf\055\uffcf\056\uffcf\060\uffcf\062\uffcf\070\uffcf\071\uffcf" +
    "\072\uffcf\073\uffcf\100\uffcf\103\uffcf\001\002\000\072\004" +
    "\uffd0\006\uffd0\015\uffd0\017\uffd0\020\uffd0\025\uffd0\026\uffd0" +
    "\037\uffd0\040\uffd0\041\uffd0\042\uffd0\043\uffd0\044\uffd0\046" +
    "\uffd0\047\uffd0\051\uffd0\052\uffd0\053\uffd0\055\uffd0\056\uffd0" +
    "\060\uffd0\062\uffd0\070\uffd0\071\uffd0\072\uffd0\073\uffd0\100" +
    "\uffd0\103\uffd0\001\002\000\072\004\uffc3\006\uffc3\015\uffc3" +
    "\017\uffc3\020\uffc3\025\uffc3\026\uffc3\037\uffc3\040\uffc3\041" +
    "\uffc3\042\uffc3\043\uffc3\044\uffc3\046\uffc3\047\uffc3\051\uffc3" +
    "\052\uffc3\053\uffc3\055\uffc3\056\uffc3\060\uffc3\062\uffc3\070" +
    "\uffc3\071\uffc3\072\uffc3\073\uffc3\100\uffc3\103\uffc3\001\002" +
    "\000\010\004\235\026\233\104\326\001\002\000\004\104" +
    "\324\001\002\000\004\104\323\001\002\000\072\004\uffc5" +
    "\006\uffc5\015\uffc5\017\uffc5\020\uffc5\025\uffc5\026\uffc5\037" +
    "\uffc5\040\uffc5\041\uffc5\042\uffc5\043\uffc5\044\uffc5\046\uffc5" +
    "\047\uffc5\051\uffc5\052\uffc5\053\uffc5\055\uffc5\056\uffc5\060" +
    "\uffc5\062\uffc5\070\uffc5\071\uffc5\072\uffc5\073\uffc5\100\uffc5" +
    "\103\uffc5\001\002\000\072\004\uffd4\006\uffd4\015\uffd4\017" +
    "\uffd4\020\uffd4\025\uffd4\026\uffd4\037\uffd4\040\uffd4\041\uffd4" +
    "\042\uffd4\043\uffd4\044\uffd4\046\uffd4\047\uffd4\051\uffd4\052" +
    "\uffd4\053\uffd4\055\uffd4\056\uffd4\060\uffd4\062\uffd4\070\uffd4" +
    "\071\uffd4\072\uffd4\073\uffd4\100\uffd4\103\uffd4\001\002\000" +
    "\072\004\uffd6\006\uffd6\015\uffd6\017\uffd6\020\uffd6\025\uffd6" +
    "\026\uffd6\037\uffd6\040\uffd6\041\uffd6\042\uffd6\043\uffd6\044" +
    "\uffd6\046\uffd6\047\uffd6\051\uffd6\052\uffd6\053\uffd6\055\uffd6" +
    "\056\uffd6\060\uffd6\062\uffd6\070\uffd6\071\uffd6\072\uffd6\073" +
    "\uffd6\100\uffd6\103\uffd6\001\002\000\044\005\uffac\006\uffac" +
    "\011\uffac\012\uffac\013\uffac\014\uffac\026\243\027\uffac\030" +
    "\uffac\031\uffac\032\uffac\033\uffac\034\uffac\035\uffac\036\uffac" +
    "\062\uffac\104\uffac\001\002\000\044\004\250\005\uffbd\006" +
    "\uffbd\011\uffbd\012\uffbd\013\uffbd\014\uffbd\027\uffbd\030\uffbd" +
    "\031\uffbd\032\uffbd\033\uffbd\034\uffbd\035\uffbd\036\uffbd\062" +
    "\uffbd\104\uffbd\001\002\000\010\004\235\026\233\104\322" +
    "\001\002\000\010\004\035\026\034\104\321\001\002\000" +
    "\072\004\uffc4\006\uffc4\015\uffc4\017\uffc4\020\uffc4\025\uffc4" +
    "\026\uffc4\037\uffc4\040\uffc4\041\uffc4\042\uffc4\043\uffc4\044" +
    "\uffc4\046\uffc4\047\uffc4\051\uffc4\052\uffc4\053\uffc4\055\uffc4" +
    "\056\uffc4\060\uffc4\062\uffc4\070\uffc4\071\uffc4\072\uffc4\073" +
    "\uffc4\100\uffc4\103\uffc4\001\002\000\072\004\uffcc\006\uffcc" +
    "\015\uffcc\017\uffcc\020\uffcc\025\uffcc\026\uffcc\037\uffcc\040" +
    "\uffcc\041\uffcc\042\uffcc\043\uffcc\044\uffcc\046\uffcc\047\uffcc" +
    "\051\uffcc\052\uffcc\053\uffcc\055\uffcc\056\uffcc\060\uffcc\062" +
    "\uffcc\070\uffcc\071\uffcc\072\uffcc\073\uffcc\100\uffcc\103\uffcc" +
    "\001\002\000\054\005\uffb0\006\uffb0\007\125\010\127\011" +
    "\uffb0\012\uffb0\013\uffb0\014\uffb0\026\240\027\uffb0\030\uffb0" +
    "\031\uffb0\032\uffb0\033\uffb0\034\uffb0\035\uffb0\036\uffb0\062" +
    "\uffb0\076\130\100\126\104\uffb0\001\002\000\072\004\uffd2" +
    "\006\uffd2\015\uffd2\017\uffd2\020\uffd2\025\uffd2\026\uffd2\037" +
    "\uffd2\040\uffd2\041\uffd2\042\uffd2\043\uffd2\044\uffd2\046\uffd2" +
    "\047\uffd2\051\uffd2\052\uffd2\053\uffd2\055\uffd2\056\uffd2\060" +
    "\uffd2\062\uffd2\070\uffd2\071\uffd2\072\uffd2\073\uffd2\100\uffd2" +
    "\103\uffd2\001\002\000\072\004\uffd1\006\uffd1\015\uffd1\017" +
    "\uffd1\020\uffd1\025\uffd1\026\uffd1\037\uffd1\040\uffd1\041\uffd1" +
    "\042\uffd1\043\uffd1\044\uffd1\046\uffd1\047\uffd1\051\uffd1\052" +
    "\uffd1\053\uffd1\055\uffd1\056\uffd1\060\uffd1\062\uffd1\070\uffd1" +
    "\071\uffd1\072\uffd1\073\uffd1\100\uffd1\103\uffd1\001\002\000" +
    "\072\004\uffc8\006\uffc8\015\uffc8\017\uffc8\020\uffc8\025\uffc8" +
    "\026\uffc8\037\uffc8\040\uffc8\041\uffc8\042\uffc8\043\uffc8\044" +
    "\uffc8\046\uffc8\047\uffc8\051\uffc8\052\uffc8\053\uffc8\055\uffc8" +
    "\056\uffc8\060\uffc8\062\uffc8\070\uffc8\071\uffc8\072\uffc8\073" +
    "\uffc8\100\uffc8\103\uffc8\001\002\000\072\004\uffd8\006\uffd8" +
    "\015\uffd8\017\uffd8\020\uffd8\025\uffd8\026\uffd8\037\uffd8\040" +
    "\uffd8\041\uffd8\042\uffd8\043\uffd8\044\uffd8\046\uffd8\047\uffd8" +
    "\051\uffd8\052\uffd8\053\uffd8\055\uffd8\056\uffd8\060\uffd8\062" +
    "\uffd8\070\uffd8\071\uffd8\072\uffd8\073\uffd8\100\uffd8\103\uffd8" +
    "\001\002\000\072\004\uff8d\006\uff8d\015\uff8d\017\uff8d\020" +
    "\uff8d\025\uff8d\026\uff8d\037\uff8d\040\uff8d\041\uff8d\042\uff8d" +
    "\043\uff8d\044\uff8d\046\uff8d\047\uff8d\051\uff8d\052\uff8d\053" +
    "\uff8d\055\uff8d\056\uff8d\060\uff8d\062\uff8d\070\uff8d\071\uff8d" +
    "\072\uff8d\073\uff8d\100\uff8d\103\uff8d\001\002\000\072\004" +
    "\uffcd\006\uffcd\015\uffcd\017\uffcd\020\uffcd\025\uffcd\026\uffcd" +
    "\037\uffcd\040\uffcd\041\uffcd\042\uffcd\043\uffcd\044\uffcd\046" +
    "\uffcd\047\uffcd\051\uffcd\052\uffcd\053\uffcd\055\uffcd\056\uffcd" +
    "\060\uffcd\062\uffcd\070\uffcd\071\uffcd\072\uffcd\073\uffcd\100" +
    "\uffcd\103\uffcd\001\002\000\072\004\uffc6\006\uffc6\015\uffc6" +
    "\017\uffc6\020\uffc6\025\uffc6\026\uffc6\037\uffc6\040\uffc6\041" +
    "\uffc6\042\uffc6\043\uffc6\044\uffc6\046\uffc6\047\uffc6\051\uffc6" +
    "\052\uffc6\053\uffc6\055\uffc6\056\uffc6\060\uffc6\062\uffc6\070" +
    "\uffc6\071\uffc6\072\uffc6\073\uffc6\100\uffc6\103\uffc6\001\002" +
    "\000\004\104\331\001\002\000\072\004\uffc7\006\uffc7\015" +
    "\uffc7\017\uffc7\020\uffc7\025\uffc7\026\uffc7\037\uffc7\040\uffc7" +
    "\041\uffc7\042\uffc7\043\uffc7\044\uffc7\046\uffc7\047\uffc7\051" +
    "\uffc7\052\uffc7\053\uffc7\055\uffc7\056\uffc7\060\uffc7\062\uffc7" +
    "\070\uffc7\071\uffc7\072\uffc7\073\uffc7\100\uffc7\103\uffc7\001" +
    "\002\000\070\003\303\004\320\006\044\015\047\020\030" +
    "\025\050\026\233\037\064\040\265\041\313\042\261\043" +
    "\031\044\015\046\027\047\026\051\021\052\046\053\054" +
    "\055\270\056\274\060\276\070\306\071\277\072\263\073" +
    "\262\100\057\103\053\001\002\000\070\004\320\006\044" +
    "\015\047\020\030\025\050\026\233\037\064\040\265\041" +
    "\313\042\261\043\031\044\015\046\027\047\026\051\021" +
    "\052\046\053\054\055\270\056\274\060\276\062\uff63\070" +
    "\367\071\363\072\263\073\262\100\057\103\053\001\002" +
    "\000\006\062\uff64\104\324\001\002\000\004\062\336\001" +
    "\002\000\004\063\337\001\002\000\026\004\056\006\044" +
    "\015\047\025\050\037\064\041\061\052\046\053\054\100" +
    "\057\103\053\001\002\000\004\104\341\001\002\000\004" +
    "\061\342\001\002\000\004\060\343\001\002\000\004\104" +
    "\344\001\002\000\074\004\uff66\006\uff66\015\uff66\017\uff66" +
    "\020\uff66\025\uff66\026\uff66\037\uff66\040\uff66\041\uff66\042" +
    "\uff66\043\uff66\044\uff66\046\uff66\047\uff66\051\uff66\052\uff66" +
    "\053\uff66\054\uff66\055\uff66\056\uff66\060\uff66\062\uff66\070" +
    "\uff66\071\uff66\072\uff66\073\uff66\100\uff66\103\uff66\001\002" +
    "\000\074\004\uff61\006\uff61\015\uff61\017\uff61\020\uff61\025" +
    "\uff61\026\uff61\037\uff61\040\uff61\041\uff61\042\uff61\043\uff61" +
    "\044\uff61\046\uff61\047\uff61\051\uff61\052\uff61\053\uff61\054" +
    "\346\055\uff61\056\uff61\060\uff61\062\uff61\070\uff61\071\uff61" +
    "\072\uff61\073\uff61\100\uff61\103\uff61\001\002\000\004\102" +
    "\350\001\002\000\072\004\uff65\006\uff65\015\uff65\017\uff65" +
    "\020\uff65\025\uff65\026\uff65\037\uff65\040\uff65\041\uff65\042" +
    "\uff65\043\uff65\044\uff65\046\uff65\047\uff65\051\uff65\052\uff65" +
    "\053\uff65\055\uff65\056\uff65\060\uff65\062\uff65\070\uff65\071" +
    "\uff65\072\uff65\073\uff65\100\uff65\103\uff65\001\002\000\004" +
    "\016\351\001\002\000\070\003\303\004\320\006\044\015" +
    "\047\020\030\025\050\026\233\037\064\040\265\041\313" +
    "\042\261\043\031\044\015\046\027\047\026\051\021\052" +
    "\046\053\054\055\270\056\274\060\276\070\306\071\277" +
    "\072\263\073\262\100\057\103\053\001\002\000\070\004" +
    "\320\006\044\015\047\017\353\020\030\025\050\026\233" +
    "\037\064\040\265\041\313\042\261\043\031\044\015\046" +
    "\027\047\026\051\021\052\046\053\054\055\270\056\274" +
    "\060\276\070\367\071\363\072\263\073\262\100\057\103" +
    "\053\001\002\000\072\004\uff62\006\uff62\015\uff62\017\uff62" +
    "\020\uff62\025\uff62\026\uff62\037\uff62\040\uff62\041\uff62\042" +
    "\uff62\043\uff62\044\uff62\046\uff62\047\uff62\051\uff62\052\uff62" +
    "\053\uff62\055\uff62\056\uff62\060\uff62\062\uff62\070\uff62\071" +
    "\uff62\072\uff62\073\uff62\100\uff62\103\uff62\001\002\000\072" +
    "\004\uffec\006\uffec\015\uffec\017\uffec\020\uffec\025\uffec\026" +
    "\uffec\037\uffec\040\uffec\041\uffec\042\uffec\043\uffec\044\uffec" +
    "\046\uffec\047\uffec\051\uffec\052\uffec\053\uffec\055\uffec\056" +
    "\uffec\060\uffec\062\uffec\070\uffec\071\uffec\072\uffec\073\uffec" +
    "\100\uffec\103\uffec\001\002\000\072\004\uffe0\006\uffe0\015" +
    "\uffe0\017\uffe0\020\uffe0\025\uffe0\026\uffe0\037\uffe0\040\uffe0" +
    "\041\uffe0\042\uffe0\043\uffe0\044\uffe0\046\uffe0\047\uffe0\051" +
    "\uffe0\052\uffe0\053\uffe0\055\uffe0\056\uffe0\060\uffe0\062\uffe0" +
    "\070\uffe0\071\uffe0\072\uffe0\073\uffe0\100\uffe0\103\uffe0\001" +
    "\002\000\072\004\uffe2\006\uffe2\015\uffe2\017\uffe2\020\uffe2" +
    "\025\uffe2\026\uffe2\037\uffe2\040\uffe2\041\uffe2\042\uffe2\043" +
    "\uffe2\044\uffe2\046\uffe2\047\uffe2\051\uffe2\052\uffe2\053\uffe2" +
    "\055\uffe2\056\uffe2\060\uffe2\062\uffe2\070\uffe2\071\uffe2\072" +
    "\uffe2\073\uffe2\100\uffe2\103\uffe2\001\002\000\072\004\uffe7" +
    "\006\uffe7\015\uffe7\017\uffe7\020\uffe7\025\uffe7\026\uffe7\037" +
    "\uffe7\040\uffe7\041\uffe7\042\uffe7\043\uffe7\044\uffe7\046\uffe7" +
    "\047\uffe7\051\uffe7\052\uffe7\053\uffe7\055\uffe7\056\uffe7\060" +
    "\uffe7\062\uffe7\070\uffe7\071\uffe7\072\uffe7\073\uffe7\100\uffe7" +
    "\103\uffe7\001\002\000\010\004\035\026\034\104\u010a\001" +
    "\002\000\004\104\u0108\001\002\000\072\004\uffe3\006\uffe3" +
    "\015\uffe3\017\uffe3\020\uffe3\025\uffe3\026\uffe3\037\uffe3\040" +
    "\uffe3\041\uffe3\042\uffe3\043\uffe3\044\uffe3\046\uffe3\047\uffe3" +
    "\051\uffe3\052\uffe3\053\uffe3\055\uffe3\056\uffe3\060\uffe3\062" +
    "\uffe3\070\uffe3\071\uffe3\072\uffe3\073\uffe3\100\uffe3\103\uffe3" +
    "\001\002\000\030\004\056\006\044\015\047\025\050\037" +
    "\064\041\061\052\046\053\054\100\057\103\053\104\u0105" +
    "\001\002\000\072\004\uffe8\006\uffe8\015\uffe8\017\uffe8\020" +
    "\uffe8\025\uffe8\026\uffe8\037\uffe8\040\uffe8\041\uffe8\042\uffe8" +
    "\043\uffe8\044\uffe8\046\uffe8\047\uffe8\051\uffe8\052\uffe8\053" +
    "\uffe8\055\uffe8\056\uffe8\060\uffe8\062\uffe8\070\uffe8\071\uffe8" +
    "\072\uffe8\073\uffe8\100\uffe8\103\uffe8\001\002\000\072\004" +
    "\uffe9\006\uffe9\015\uffe9\017\uffe9\020\uffe9\025\uffe9\026\uffe9" +
    "\037\uffe9\040\uffe9\041\uffe9\042\uffe9\043\uffe9\044\uffe9\046" +
    "\uffe9\047\uffe9\051\uffe9\052\uffe9\053\uffe9\055\uffe9\056\uffe9" +
    "\060\uffe9\062\uffe9\070\uffe9\071\uffe9\072\uffe9\073\uffe9\100" +
    "\uffe9\103\uffe9\001\002\000\010\004\235\026\233\104\u0104" +
    "\001\002\000\004\104\u0103\001\002\000\004\104\u0102\001" +
    "\002\000\072\004\uffde\006\uffde\015\uffde\017\uffde\020\uffde" +
    "\025\uffde\026\uffde\037\uffde\040\uffde\041\uffde\042\uffde\043" +
    "\uffde\044\uffde\046\uffde\047\uffde\051\uffde\052\uffde\053\uffde" +
    "\055\uffde\056\uffde\060\uffde\062\uffde\070\uffde\071\uffde\072" +
    "\uffde\073\uffde\100\uffde\103\uffde\001\002\000\072\004\uffe6" +
    "\006\uffe6\015\uffe6\017\uffe6\020\uffe6\025\uffe6\026\uffe6\037" +
    "\uffe6\040\uffe6\041\uffe6\042\uffe6\043\uffe6\044\uffe6\046\uffe6" +
    "\047\uffe6\051\uffe6\052\uffe6\053\uffe6\055\uffe6\056\uffe6\060" +
    "\uffe6\062\uffe6\070\uffe6\071\uffe6\072\uffe6\073\uffe6\100\uffe6" +
    "\103\uffe6\001\002\000\072\004\uffdf\006\uffdf\015\uffdf\017" +
    "\uffdf\020\uffdf\025\uffdf\026\uffdf\037\uffdf\040\uffdf\041\uffdf" +
    "\042\uffdf\043\uffdf\044\uffdf\046\uffdf\047\uffdf\051\uffdf\052" +
    "\uffdf\053\uffdf\055\uffdf\056\uffdf\060\uffdf\062\uffdf\070\uffdf" +
    "\071\uffdf\072\uffdf\073\uffdf\100\uffdf\103\uffdf\001\002\000" +
    "\010\004\235\026\233\104\u0101\001\002\000\010\004\035" +
    "\026\034\104\u0100\001\002\000\072\004\uffd9\006\uffd9\015" +
    "\uffd9\017\uffd9\020\uffd9\025\uffd9\026\uffd9\037\uffd9\040\uffd9" +
    "\041\uffd9\042\uffd9\043\uffd9\044\uffd9\046\uffd9\047\uffd9\051" +
    "\uffd9\052\uffd9\053\uffd9\055\uffd9\056\uffd9\060\uffd9\062\uffd9" +
    "\070\uffd9\071\uffd9\072\uffd9\073\uffd9\100\uffd9\103\uffd9\001" +
    "\002\000\072\004\uffe4\006\uffe4\015\uffe4\017\uffe4\020\uffe4" +
    "\025\uffe4\026\uffe4\037\uffe4\040\uffe4\041\uffe4\042\uffe4\043" +
    "\uffe4\044\uffe4\046\uffe4\047\uffe4\051\uffe4\052\uffe4\053\uffe4" +
    "\055\uffe4\056\uffe4\060\uffe4\062\uffe4\070\uffe4\071\uffe4\072" +
    "\uffe4\073\uffe4\100\uffe4\103\uffe4\001\002\000\072\004\uffeb" +
    "\006\uffeb\015\uffeb\017\uffeb\020\uffeb\025\uffeb\026\uffeb\037" +
    "\uffeb\040\uffeb\041\uffeb\042\uffeb\043\uffeb\044\uffeb\046\uffeb" +
    "\047\uffeb\051\uffeb\052\uffeb\053\uffeb\055\uffeb\056\uffeb\060" +
    "\uffeb\062\uffeb\070\uffeb\071\uffeb\072\uffeb\073\uffeb\100\uffeb" +
    "\103\uffeb\001\002\000\072\004\uffea\006\uffea\015\uffea\017" +
    "\uffea\020\uffea\025\uffea\026\uffea\037\uffea\040\uffea\041\uffea" +
    "\042\uffea\043\uffea\044\uffea\046\uffea\047\uffea\051\uffea\052" +
    "\uffea\053\uffea\055\uffea\056\uffea\060\uffea\062\uffea\070\uffea" +
    "\071\uffea\072\uffea\073\uffea\100\uffea\103\uffea\001\002\000" +
    "\072\004\uffed\006\uffed\015\uffed\017\uffed\020\uffed\025\uffed" +
    "\026\uffed\037\uffed\040\uffed\041\uffed\042\uffed\043\uffed\044" +
    "\uffed\046\uffed\047\uffed\051\uffed\052\uffed\053\uffed\055\uffed" +
    "\056\uffed\060\uffed\062\uffed\070\uffed\071\uffed\072\uffed\073" +
    "\uffed\100\uffed\103\uffed\001\002\000\072\004\uffdc\006\uffdc" +
    "\015\uffdc\017\uffdc\020\uffdc\025\uffdc\026\uffdc\037\uffdc\040" +
    "\uffdc\041\uffdc\042\uffdc\043\uffdc\044\uffdc\046\uffdc\047\uffdc" +
    "\051\uffdc\052\uffdc\053\uffdc\055\uffdc\056\uffdc\060\uffdc\062" +
    "\uffdc\070\uffdc\071\uffdc\072\uffdc\073\uffdc\100\uffdc\103\uffdc" +
    "\001\002\000\072\004\uffe5\006\uffe5\015\uffe5\017\uffe5\020" +
    "\uffe5\025\uffe5\026\uffe5\037\uffe5\040\uffe5\041\uffe5\042\uffe5" +
    "\043\uffe5\044\uffe5\046\uffe5\047\uffe5\051\uffe5\052\uffe5\053" +
    "\uffe5\055\uffe5\056\uffe5\060\uffe5\062\uffe5\070\uffe5\071\uffe5" +
    "\072\uffe5\073\uffe5\100\uffe5\103\uffe5\001\002\000\072\004" +
    "\uffda\006\uffda\015\uffda\017\uffda\020\uffda\025\uffda\026\uffda" +
    "\037\uffda\040\uffda\041\uffda\042\uffda\043\uffda\044\uffda\046" +
    "\uffda\047\uffda\051\uffda\052\uffda\053\uffda\055\uffda\056\uffda" +
    "\060\uffda\062\uffda\070\uffda\071\uffda\072\uffda\073\uffda\100" +
    "\uffda\103\uffda\001\002\000\004\104\u0107\001\002\000\072" +
    "\004\uffdb\006\uffdb\015\uffdb\017\uffdb\020\uffdb\025\uffdb\026" +
    "\uffdb\037\uffdb\040\uffdb\041\uffdb\042\uffdb\043\uffdb\044\uffdb" +
    "\046\uffdb\047\uffdb\051\uffdb\052\uffdb\053\uffdb\055\uffdb\056" +
    "\uffdb\060\uffdb\062\uffdb\070\uffdb\071\uffdb\072\uffdb\073\uffdb" +
    "\100\uffdb\103\uffdb\001\002\000\072\004\uffdd\006\uffdd\015" +
    "\uffdd\017\uffdd\020\uffdd\025\uffdd\026\uffdd\037\uffdd\040\uffdd" +
    "\041\uffdd\042\uffdd\043\uffdd\044\uffdd\046\uffdd\047\uffdd\051" +
    "\uffdd\052\uffdd\053\uffdd\055\uffdd\056\uffdd\060\uffdd\062\uffdd" +
    "\070\uffdd\071\uffdd\072\uffdd\073\uffdd\100\uffdd\103\uffdd\001" +
    "\002\000\072\004\uff51\006\uff51\015\uff51\017\uff51\020\uff51" +
    "\025\uff51\026\uff51\037\uff51\040\uff51\041\uff51\042\uff51\043" +
    "\uff51\044\uff51\046\uff51\047\uff51\051\uff51\052\uff51\053\uff51" +
    "\055\uff51\056\uff51\060\uff51\062\uff51\070\uff51\071\uff51\072" +
    "\uff51\073\uff51\100\uff51\103\uff51\001\002\000\072\004\uffe1" +
    "\006\uffe1\015\uffe1\017\uffe1\020\uffe1\025\uffe1\026\uffe1\037" +
    "\uffe1\040\uffe1\041\uffe1\042\uffe1\043\uffe1\044\uffe1\046\uffe1" +
    "\047\uffe1\051\uffe1\052\uffe1\053\uffe1\055\uffe1\056\uffe1\060" +
    "\uffe1\062\uffe1\070\uffe1\071\uffe1\072\uffe1\073\uffe1\100\uffe1" +
    "\103\uffe1\001\002\000\076\002\uff72\003\uff72\004\uff72\006" +
    "\uff72\015\uff72\017\uff72\020\uff72\025\uff72\026\uff72\037\uff72" +
    "\040\uff72\041\uff72\042\uff72\043\uff72\044\uff72\046\uff72\047" +
    "\uff72\051\uff72\052\uff72\053\uff72\055\uff72\056\uff72\060\uff72" +
    "\062\uff72\070\uff72\071\uff72\072\uff72\073\uff72\100\uff72\103" +
    "\uff72\001\002\000\030\004\uff70\006\uff70\015\uff70\025\uff70" +
    "\037\uff70\041\uff70\052\uff70\053\uff70\054\uff70\100\uff70\103" +
    "\uff70\001\002\000\030\004\056\006\044\015\047\025\050" +
    "\037\064\041\061\052\046\053\054\054\u010e\100\057\103" +
    "\053\001\002\000\004\102\u011c\001\002\000\032\004\056" +
    "\006\044\015\047\025\050\037\064\041\061\052\046\053" +
    "\054\054\u010e\061\u0118\100\057\103\053\001\002\000\004" +
    "\102\uff68\001\002\000\032\004\uff6d\006\uff6d\015\uff6d\025" +
    "\uff6d\037\uff6d\041\uff6d\052\uff6d\053\uff6d\054\uff6d\061\uff6d" +
    "\100\uff6d\103\uff6d\001\002\000\004\102\u0113\001\002\000" +
    "\004\016\u0114\001\002\000\070\003\uff6c\004\uff6c\006\uff6c" +
    "\015\uff6c\020\uff6c\025\uff6c\026\uff6c\037\uff6c\040\uff6c\041" +
    "\uff6c\042\uff6c\043\uff6c\044\uff6c\046\uff6c\047\uff6c\051\uff6c" +
    "\052\uff6c\053\uff6c\055\uff6c\056\uff6c\060\uff6c\070\uff6c\071" +
    "\uff6c\072\uff6c\073\uff6c\100\uff6c\103\uff6c\001\002\000\070" +
    "\003\303\004\320\006\044\015\047\020\030\025\050\026" +
    "\233\037\064\040\265\041\313\042\261\043\031\044\015" +
    "\046\027\047\026\051\021\052\046\053\054\055\270\056" +
    "\274\060\276\070\306\071\277\072\263\073\262\100\057" +
    "\103\053\001\002\000\070\004\320\006\044\015\047\017" +
    "\u0117\020\030\025\050\026\233\037\064\040\265\041\313" +
    "\042\261\043\031\044\015\046\027\047\026\051\021\052" +
    "\046\053\054\055\270\056\274\060\276\070\367\071\363" +
    "\072\263\073\262\100\057\103\053\001\002\000\032\004" +
    "\uff6b\006\uff6b\015\uff6b\025\uff6b\037\uff6b\041\uff6b\052\uff6b" +
    "\053\uff6b\054\uff6b\061\uff6b\100\uff6b\103\uff6b\001\002\000" +
    "\004\056\u011a\001\002\000\032\004\uff6e\006\uff6e\015\uff6e" +
    "\025\uff6e\037\uff6e\041\uff6e\052\uff6e\053\uff6e\054\uff6e\061" +
    "\uff6e\100\uff6e\103\uff6e\001\002\000\004\104\u011b\001\002" +
    "\000\072\004\uff6f\006\uff6f\015\uff6f\017\uff6f\020\uff6f\025" +
    "\uff6f\026\uff6f\037\uff6f\040\uff6f\041\uff6f\042\uff6f\043\uff6f" +
    "\044\uff6f\046\uff6f\047\uff6f\051\uff6f\052\uff6f\053\uff6f\055" +
    "\uff6f\056\uff6f\060\uff6f\062\uff6f\070\uff6f\071\uff6f\072\uff6f" +
    "\073\uff6f\100\uff6f\103\uff6f\001\002\000\004\016\u011d\001" +
    "\002\000\070\003\uff6a\004\uff6a\006\uff6a\015\uff6a\020\uff6a" +
    "\025\uff6a\026\uff6a\037\uff6a\040\uff6a\041\uff6a\042\uff6a\043" +
    "\uff6a\044\uff6a\046\uff6a\047\uff6a\051\uff6a\052\uff6a\053\uff6a" +
    "\055\uff6a\056\uff6a\060\uff6a\070\uff6a\071\uff6a\072\uff6a\073" +
    "\uff6a\100\uff6a\103\uff6a\001\002\000\070\003\303\004\320" +
    "\006\044\015\047\020\030\025\050\026\233\037\064\040" +
    "\265\041\313\042\261\043\031\044\015\046\027\047\026" +
    "\051\021\052\046\053\054\055\270\056\274\060\276\070" +
    "\306\071\277\072\263\073\262\100\057\103\053\001\002" +
    "\000\070\004\320\006\044\015\047\017\u0120\020\030\025" +
    "\050\026\233\037\064\040\265\041\313\042\261\043\031" +
    "\044\015\046\027\047\026\051\021\052\046\053\054\055" +
    "\270\056\274\060\276\070\367\071\363\072\263\073\262" +
    "\100\057\103\053\001\002\000\032\004\uff69\006\uff69\015" +
    "\uff69\025\uff69\037\uff69\041\uff69\052\uff69\053\uff69\054\uff69" +
    "\061\uff69\100\uff69\103\uff69\001\002\000\072\004\uffc9\006" +
    "\uffc9\015\uffc9\017\uffc9\020\uffc9\025\uffc9\026\uffc9\037\uffc9" +
    "\040\uffc9\041\uffc9\042\uffc9\043\uffc9\044\uffc9\046\uffc9\047" +
    "\uffc9\051\uffc9\052\uffc9\053\uffc9\055\uffc9\056\uffc9\060\uffc9" +
    "\062\uffc9\070\uffc9\071\uffc9\072\uffc9\073\uffc9\100\uffc9\103" +
    "\uffc9\001\002\000\072\004\uffd7\006\uffd7\015\uffd7\017\uffd7" +
    "\020\uffd7\025\uffd7\026\uffd7\037\uffd7\040\uffd7\041\uffd7\042" +
    "\uffd7\043\uffd7\044\uffd7\046\uffd7\047\uffd7\051\uffd7\052\uffd7" +
    "\053\uffd7\055\uffd7\056\uffd7\060\uffd7\062\uffd7\070\uffd7\071" +
    "\uffd7\072\uffd7\073\uffd7\100\uffd7\103\uffd7\001\002\000\004" +
    "\064\u012a\001\002\000\004\026\u0128\001\002\000\006\026" +
    "\u0126\076\130\001\002\000\026\004\056\006\044\015\047" +
    "\025\050\037\064\041\061\052\046\053\054\100\057\103" +
    "\053\001\002\000\004\064\uff5c\001\002\000\026\004\056" +
    "\006\044\015\047\025\050\037\064\041\061\052\046\053" +
    "\054\100\057\103\053\001\002\000\004\064\uff5b\001\002" +
    "\000\026\004\056\006\044\015\047\025\050\037\064\041" +
    "\061\052\046\053\054\100\057\103\053\001\002\000\006" +
    "\065\uff5a\066\uff5a\001\002\000\006\065\u012d\066\u012e\001" +
    "\002\000\026\004\056\006\044\015\047\025\050\037\064" +
    "\041\061\052\046\053\054\100\057\103\053\001\002\000" +
    "\026\004\056\006\044\015\047\025\050\037\064\041\061" +
    "\052\046\053\054\100\057\103\053\001\002\000\004\067" +
    "\u0130\001\002\000\004\016\uff5e\001\002\000\004\016\256" +
    "\001\002\000\070\003\303\004\320\006\044\015\047\020" +
    "\030\025\050\026\233\037\064\040\265\041\313\042\261" +
    "\043\031\044\015\046\027\047\026\051\021\052\046\053" +
    "\054\055\270\056\274\060\276\070\306\071\277\072\263" +
    "\073\262\100\057\103\053\001\002\000\070\004\320\006" +
    "\044\015\047\017\u0134\020\030\025\050\026\233\037\064" +
    "\040\265\041\313\042\261\043\031\044\015\046\027\047" +
    "\026\051\021\052\046\053\054\055\270\056\274\060\276" +
    "\070\367\071\363\072\263\073\262\100\057\103\053\001" +
    "\002\000\072\004\uff5d\006\uff5d\015\uff5d\017\uff5d\020\uff5d" +
    "\025\uff5d\026\uff5d\037\uff5d\040\uff5d\041\uff5d\042\uff5d\043" +
    "\uff5d\044\uff5d\046\uff5d\047\uff5d\051\uff5d\052\uff5d\053\uff5d" +
    "\055\uff5d\056\uff5d\060\uff5d\062\uff5d\070\uff5d\071\uff5d\072" +
    "\uff5d\073\uff5d\100\uff5d\103\uff5d\001\002\000\004\067\u0136" +
    "\001\002\000\004\016\uff60\001\002\000\004\016\256\001" +
    "\002\000\070\003\303\004\320\006\044\015\047\020\030" +
    "\025\050\026\233\037\064\040\265\041\313\042\261\043" +
    "\031\044\015\046\027\047\026\051\021\052\046\053\054" +
    "\055\270\056\274\060\276\070\306\071\277\072\263\073" +
    "\262\100\057\103\053\001\002\000\070\004\320\006\044" +
    "\015\047\017\u013a\020\030\025\050\026\233\037\064\040" +
    "\265\041\313\042\261\043\031\044\015\046\027\047\026" +
    "\051\021\052\046\053\054\055\270\056\274\060\276\070" +
    "\367\071\363\072\263\073\262\100\057\103\053\001\002" +
    "\000\072\004\uff5f\006\uff5f\015\uff5f\017\uff5f\020\uff5f\025" +
    "\uff5f\026\uff5f\037\uff5f\040\uff5f\041\uff5f\042\uff5f\043\uff5f" +
    "\044\uff5f\046\uff5f\047\uff5f\051\uff5f\052\uff5f\053\uff5f\055" +
    "\uff5f\056\uff5f\060\uff5f\062\uff5f\070\uff5f\071\uff5f\072\uff5f" +
    "\073\uff5f\100\uff5f\103\uff5f\001\002\000\006\016\uff8b\100" +
    "\uff8b\001\002\000\004\004\u013d\001\002\000\004\076\u013e" +
    "\001\002\000\004\015\u013f\001\002\000\004\077\u0140\001" +
    "\002\000\010\004\uff59\026\uff59\104\uff59\001\002\000\004" +
    "\004\u0142\001\002\000\004\101\u0143\001\002\000\004\104" +
    "\u0144\001\002\000\072\004\uffa7\006\uffa7\015\uffa7\017\uffa7" +
    "\020\uffa7\025\uffa7\026\uffa7\037\uffa7\040\uffa7\041\uffa7\042" +
    "\uffa7\043\uffa7\044\uffa7\046\uffa7\047\uffa7\051\uffa7\052\uffa7" +
    "\053\uffa7\055\uffa7\056\uffa7\060\uffa7\062\uffa7\070\uffa7\071" +
    "\uffa7\072\uffa7\073\uffa7\100\uffa7\103\uffa7\001\002\000\026" +
    "\004\056\006\044\015\047\025\050\037\064\041\061\052" +
    "\046\053\054\100\057\103\053\001\002\000\004\101\u0147" +
    "\001\002\000\004\104\uff47\001\002\000\006\016\uff8a\100" +
    "\uff8a\001\002\000\004\004\u014a\001\002\000\004\076\u014b" +
    "\001\002\000\004\015\u014c\001\002\000\004\077\u014d\001" +
    "\002\000\010\004\uff58\026\uff58\104\uff58\001\002\000\006" +
    "\016\uff81\101\u0153\001\002\000\004\004\u015d\001\002\000" +
    "\010\016\uff80\024\u015b\101\uff80\001\002\000\004\004\u015a" +
    "\001\002\000\004\004\u0159\001\002\000\004\016\uff82\001" +
    "\002\000\004\016\uff84\001\002\000\004\004\u0158\001\002" +
    "\000\004\004\u0157\001\002\000\010\016\uff7c\024\uff7c\101" +
    "\uff7c\001\002\000\010\016\uff7d\024\uff7d\101\uff7d\001\002" +
    "\000\010\016\uff7a\024\uff7a\101\uff7a\001\002\000\010\016" +
    "\uff7b\024\uff7b\101\uff7b\001\002\000\014\040\u014f\041\u0156" +
    "\042\u0155\043\u0151\044\u0152\001\002\000\006\016\uff7f\101" +
    "\uff7f\001\002\000\010\016\uff7e\024\uff7e\101\uff7e\001\002" +
    "\000\004\016\uff85\001\002\000\004\016\256\001\002\000" +
    "\070\003\303\004\320\006\044\015\047\020\030\025\050" +
    "\026\233\037\064\040\265\041\313\042\261\043\031\044" +
    "\015\046\027\047\026\051\021\052\046\053\054\055\270" +
    "\056\274\060\276\070\306\071\277\072\263\073\262\100" +
    "\057\103\053\001\002\000\070\004\320\006\044\015\047" +
    "\017\u0162\020\030\025\050\026\233\037\064\040\265\041" +
    "\313\042\261\043\031\044\015\046\027\047\026\051\021" +
    "\052\046\053\054\055\270\056\274\060\276\070\367\071" +
    "\363\072\263\073\262\100\057\103\053\001\002\000\076" +
    "\002\uff86\003\uff86\004\uff86\006\uff86\015\uff86\017\uff86\020" +
    "\uff86\025\uff86\026\uff86\037\uff86\040\uff86\041\uff86\042\uff86" +
    "\043\uff86\044\uff86\046\uff86\047\uff86\051\uff86\052\uff86\053" +
    "\uff86\055\uff86\056\uff86\060\uff86\062\uff86\070\uff86\071\uff86" +
    "\072\uff86\073\uff86\100\uff86\103\uff86\001\002\000\004\002" +
    "\ufff0\001\002" });

  /** Access to parse-action table. */
  public short[][] action_table() {return _action_table;}

  /** <code>reduce_goto</code> table. */
  protected static final short[][] _reduce_table = 
    unpackFromStrings(new String[] {
    "\000\u0161\000\006\003\004\065\003\001\001\000\030\004" +
    "\024\012\021\013\022\035\012\036\007\045\016\046\032" +
    "\047\017\051\031\052\013\063\006\001\001\000\002\001" +
    "\001\000\002\001\001\000\030\004\024\012\021\013\022" +
    "\035\012\036\007\045\u0162\046\032\047\017\051\031\052" +
    "\013\063\006\001\001\000\004\053\u015e\001\001\000\002" +
    "\001\001\000\002\001\001\000\004\053\253\001\001\000" +
    "\030\004\024\012\021\013\022\035\012\036\007\045\251" +
    "\046\032\047\017\051\031\052\013\063\006\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\006" +
    "\005\231\042\233\001\001\000\002\001\001\000\030\004" +
    "\024\012\021\013\022\035\012\036\007\045\230\046\032" +
    "\047\017\051\031\052\013\063\006\001\001\000\030\004" +
    "\024\012\021\013\022\035\012\036\007\045\227\046\032" +
    "\047\017\051\031\052\013\063\006\001\001\000\030\004" +
    "\024\012\021\013\022\035\012\036\007\045\226\046\032" +
    "\047\017\051\031\052\013\063\006\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\004\064\160" +
    "\001\001\000\002\001\001\000\030\004\024\012\021\013" +
    "\022\035\012\036\007\045\154\046\032\047\017\051\031" +
    "\052\013\063\006\001\001\000\004\021\035\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\030" +
    "\004\024\012\021\013\022\035\012\036\007\045\037\046" +
    "\032\047\017\051\031\052\013\063\006\001\001\000\002" +
    "\001\001\000\002\001\001\000\016\007\050\010\054\011" +
    "\044\023\051\024\057\042\042\001\001\000\002\001\001" +
    "\000\004\024\144\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\022\007\062\010\054" +
    "\011\044\024\057\037\061\040\065\041\064\042\042\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\016\007\062\010\054\011\044\024" +
    "\057\041\072\042\042\001\001\000\002\001\001\000\002" +
    "\001\001\000\016\007\062\010\054\011\044\024\057\041" +
    "\071\042\042\001\001\000\016\007\062\010\054\011\044" +
    "\024\057\041\070\042\042\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\012\010\054\011\122" +
    "\024\057\042\042\001\001\000\014\007\121\010\054\011" +
    "\044\024\057\042\042\001\001\000\014\007\120\010\054" +
    "\011\044\024\057\042\042\001\001\000\012\010\054\011" +
    "\107\024\057\042\042\001\001\000\014\007\106\010\054" +
    "\011\044\024\057\042\042\001\001\000\014\007\105\010" +
    "\054\011\044\024\057\042\042\001\001\000\014\007\104" +
    "\010\054\011\044\024\057\042\042\001\001\000\014\007" +
    "\103\010\054\011\044\024\057\042\042\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\010\010\117\024\057\042\042" +
    "\001\001\000\010\010\116\024\057\042\042\001\001\000" +
    "\010\010\115\024\057\042\042\001\001\000\010\010\114" +
    "\024\057\042\042\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\026\007\062\010\054\011\044\024\057" +
    "\037\132\040\065\041\064\042\042\057\134\060\133\001" +
    "\001\000\002\001\001\000\014\007\130\010\054\011\044" +
    "\024\057\042\042\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\024\007\062\010\054\011\044\024" +
    "\057\037\132\040\065\041\064\042\042\060\137\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\016\007\050\010\054\011\044\023\143\024\057\042\042" +
    "\001\001\000\002\001\001\000\002\001\001\000\022\007" +
    "\062\010\054\011\044\024\057\037\146\040\065\041\064" +
    "\042\042\001\001\000\002\001\001\000\002\001\001\000" +
    "\016\007\050\010\054\011\044\023\151\024\057\042\042" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\030\004\024\012\021\013\022" +
    "\035\012\036\007\045\225\046\032\047\017\051\031\052" +
    "\013\063\006\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\022\007\062\010\054\011\044\024\057\037\245\040\065" +
    "\041\064\042\042\001\001\000\002\001\001\000\002\001" +
    "\001\000\030\004\024\012\021\013\022\035\012\036\007" +
    "\045\236\046\032\047\017\051\031\052\013\063\006\001" +
    "\001\000\002\001\001\000\022\007\062\010\054\011\044" +
    "\024\057\037\240\040\065\041\064\042\042\001\001\000" +
    "\002\001\001\000\002\001\001\000\022\007\062\010\054" +
    "\011\044\024\057\037\243\040\065\041\064\042\042\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\010\054\u0153\055\u014d\056\u014f\001\001" +
    "\000\004\015\254\001\001\000\072\004\303\005\263\006" +
    "\274\007\062\010\054\011\044\012\307\013\270\014\272" +
    "\020\271\022\310\024\057\027\316\030\277\032\266\034" +
    "\306\035\012\036\007\037\304\040\065\041\064\042\311" +
    "\046\314\047\313\050\265\051\301\052\300\063\315\001" +
    "\001\000\004\016\257\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\006\042\u0123\061\u0122\001\001\000" +
    "\002\001\001\000\004\021\u0108\001\001\000\002\001\001" +
    "\000\002\001\001\000\070\004\365\005\353\007\062\010" +
    "\054\011\044\012\371\013\356\014\360\020\357\022\372" +
    "\024\057\027\376\030\361\032\355\034\370\035\012\036" +
    "\007\037\367\040\065\041\064\042\311\046\374\047\373" +
    "\050\354\051\364\052\363\063\375\001\001\000\004\071" +
    "\331\001\001\000\022\007\062\010\054\011\044\024\057" +
    "\037\327\040\065\041\064\042\042\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\006\005\324\042\233\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\006\005" +
    "\231\042\233\001\001\000\004\021\035\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\074\004\303\005\263" +
    "\006\332\007\062\010\054\011\044\012\307\013\270\014" +
    "\272\017\334\020\271\022\310\024\057\027\316\030\277" +
    "\032\266\034\306\035\012\036\007\037\333\040\065\041" +
    "\064\042\311\046\314\047\313\050\265\051\301\052\300" +
    "\063\315\001\001\000\070\004\365\005\353\007\062\010" +
    "\054\011\044\012\371\013\356\014\360\020\357\022\372" +
    "\024\057\027\376\030\361\032\355\034\370\035\012\036" +
    "\007\037\367\040\065\041\064\042\311\046\374\047\373" +
    "\050\354\051\364\052\363\063\375\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\022\007\062" +
    "\010\054\011\044\024\057\037\337\040\065\041\064\042" +
    "\042\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\004\072\344\001\001\000" +
    "\004\031\346\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\072\004\303\005\263\006\351\007" +
    "\062\010\054\011\044\012\307\013\270\014\272\020\271" +
    "\022\310\024\057\027\316\030\277\032\266\034\306\035" +
    "\012\036\007\037\304\040\065\041\064\042\311\046\314" +
    "\047\313\050\265\051\301\052\300\063\315\001\001\000" +
    "\070\004\365\005\353\007\062\010\054\011\044\012\371" +
    "\013\356\014\360\020\357\022\372\024\057\027\376\030" +
    "\361\032\355\034\370\035\012\036\007\037\367\040\065" +
    "\041\064\042\311\046\374\047\373\050\354\051\364\052" +
    "\363\063\375\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\004\021\u0108\001\001\000\002\001\001\000\002\001\001" +
    "\000\022\007\062\010\054\011\044\024\057\037\u0105\040" +
    "\065\041\064\042\042\001\001\000\002\001\001\000\002" +
    "\001\001\000\006\005\324\042\233\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\006\005\231\042\233\001\001\000" +
    "\004\021\035\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\004\066\u010c" +
    "\001\001\000\030\007\062\010\054\011\044\024\057\025" +
    "\u010e\026\u0110\033\u0111\037\u010f\040\065\041\064\042\042" +
    "\001\001\000\002\001\001\000\026\007\062\010\054\011" +
    "\044\024\057\026\u0118\033\u0111\037\u010f\040\065\041\064" +
    "\042\042\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\004\067\u0114\001\001" +
    "\000\072\004\303\005\263\006\u0115\007\062\010\054\011" +
    "\044\012\307\013\270\014\272\020\271\022\310\024\057" +
    "\027\316\030\277\032\266\034\306\035\012\036\007\037" +
    "\304\040\065\041\064\042\311\046\314\047\313\050\265" +
    "\051\301\052\300\063\315\001\001\000\070\004\365\005" +
    "\353\007\062\010\054\011\044\012\371\013\356\014\360" +
    "\020\357\022\372\024\057\027\376\030\361\032\355\034" +
    "\370\035\012\036\007\037\367\040\065\041\064\042\311" +
    "\046\374\047\373\050\354\051\364\052\363\063\375\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\004\070\u011d\001\001\000\072\004\303\005\263\006\u011e" +
    "\007\062\010\054\011\044\012\307\013\270\014\272\020" +
    "\271\022\310\024\057\027\316\030\277\032\266\034\306" +
    "\035\012\036\007\037\304\040\065\041\064\042\311\046" +
    "\314\047\313\050\265\051\301\052\300\063\315\001\001" +
    "\000\070\004\365\005\353\007\062\010\054\011\044\012" +
    "\371\013\356\014\360\020\357\022\372\024\057\027\376" +
    "\030\361\032\355\034\370\035\012\036\007\037\367\040" +
    "\065\041\064\042\311\046\374\047\373\050\354\051\364" +
    "\052\363\063\375\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\022\007\062\010\054\011\044\024" +
    "\057\037\u0126\040\065\041\064\042\042\001\001\000\002" +
    "\001\001\000\022\007\062\010\054\011\044\024\057\037" +
    "\u0128\040\065\041\064\042\042\001\001\000\002\001\001" +
    "\000\024\007\062\010\054\011\044\024\057\037\u012a\040" +
    "\065\041\064\042\042\062\u012b\001\001\000\002\001\001" +
    "\000\002\001\001\000\022\007\062\010\054\011\044\024" +
    "\057\037\u0134\040\065\041\064\042\042\001\001\000\022" +
    "\007\062\010\054\011\044\024\057\037\u012e\040\065\041" +
    "\064\042\042\001\001\000\002\001\001\000\004\074\u0130" +
    "\001\001\000\004\015\u0131\001\001\000\072\004\303\005" +
    "\263\006\u0132\007\062\010\054\011\044\012\307\013\270" +
    "\014\272\020\271\022\310\024\057\027\316\030\277\032" +
    "\266\034\306\035\012\036\007\037\304\040\065\041\064" +
    "\042\311\046\314\047\313\050\265\051\301\052\300\063" +
    "\315\001\001\000\070\004\365\005\353\007\062\010\054" +
    "\011\044\012\371\013\356\014\360\020\357\022\372\024" +
    "\057\027\376\030\361\032\355\034\370\035\012\036\007" +
    "\037\367\040\065\041\064\042\311\046\374\047\373\050" +
    "\354\051\364\052\363\063\375\001\001\000\002\001\001" +
    "\000\002\001\001\000\004\073\u0136\001\001\000\004\015" +
    "\u0137\001\001\000\072\004\303\005\263\006\u0138\007\062" +
    "\010\054\011\044\012\307\013\270\014\272\020\271\022" +
    "\310\024\057\027\316\030\277\032\266\034\306\035\012" +
    "\036\007\037\304\040\065\041\064\042\311\046\314\047" +
    "\313\050\265\051\301\052\300\063\315\001\001\000\070" +
    "\004\365\005\353\007\062\010\054\011\044\012\371\013" +
    "\356\014\360\020\357\022\372\024\057\027\376\030\361" +
    "\032\355\034\370\035\012\036\007\037\367\040\065\041" +
    "\064\042\311\046\374\047\373\050\354\051\364\052\363" +
    "\063\375\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\022\007\062" +
    "\010\054\011\044\024\057\037\u0145\040\065\041\064\042" +
    "\042\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\004\054\u015d" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\006" +
    "\055\u015b\056\u014f\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\004\015\u015f\001\001\000\072" +
    "\004\303\005\263\006\u0160\007\062\010\054\011\044\012" +
    "\307\013\270\014\272\020\271\022\310\024\057\027\316" +
    "\030\277\032\266\034\306\035\012\036\007\037\304\040" +
    "\065\041\064\042\311\046\314\047\313\050\265\051\301" +
    "\052\300\063\315\001\001\000\070\004\365\005\353\007" +
    "\062\010\054\011\044\012\371\013\356\014\360\020\357" +
    "\022\372\024\057\027\376\030\361\032\355\034\370\035" +
    "\012\036\007\037\367\040\065\041\064\042\311\046\374" +
    "\047\373\050\354\051\364\052\363\063\375\001\001\000" +
    "\002\001\001\000\002\001\001" });

  /** Access to <code>reduce_goto</code> table. */
  public short[][] reduce_table() {return _reduce_table;}

  /** Instance of action encapsulation class. */
  protected CUP$Parser$actions action_obj;

  /** Action encapsulation object initializer. */
  protected void init_actions()
    {
      action_obj = new CUP$Parser$actions(this);
    }

  /** Invoke a user supplied parse action. */
  public java_cup.runtime.Symbol do_action(
    int                        act_num,
    java_cup.runtime.lr_parser parser,
    java.util.Stack            stack,
    int                        top)
    throws java.lang.Exception
  {
    /* call code in generated class */
    return action_obj.CUP$Parser$do_action(act_num, parser, stack, top);
  }

  /** Indicates start state. */
  public int start_state() {return 0;}
  /** Indicates start production. */
  public int start_production() {return 0;}

  /** <code>EOF</code> Symbol index. */
  public int EOF_sym() {return 0;}

  /** <code>error</code> Symbol index. */
  public int error_sym() {return 1;}


  /** User initialization code. */
  public void user_init() throws java.lang.Exception
    {

    }

  /** Scan to get the next Symbol. */
  public java_cup.runtime.Symbol scan()
    throws java.lang.Exception
    {
return lex.next_token();
    }


    Lexer lex;
    HashMap<String, ArrayList<String>> scopePrograma = new HashMap<>();
    HashMap<String, LinkedHashMap<String, SymbolInfo>> semanticScopes = new HashMap<>();
    HashMap<String, FunctionInfo> functionTable = new HashMap<>();
    ArrayDeque<String> decideEndStack = new ArrayDeque<>();
    ArrayDeque<String> decideNextStack = new ArrayDeque<>();
    ArrayDeque<String> loopStartStack = new ArrayDeque<>();
    ArrayDeque<String> loopEndStack = new ArrayDeque<>();
    ArrayList<String> semanticErrors = new ArrayList<>();
    StringBuilder cod3D = new StringBuilder();
    String currentHash;
    String globalHash = "SCOPE GLOBAL";
    int tempCounter = 0;
    int labelCounter = 0;
    boolean artifactsExported = false;

    static class SymbolInfo {
        final String name;
        final String type;
        final boolean isArray;
        final int arraySize;
        final boolean isParam;
        final boolean isGlobal;
        final int line;
        final int col;

        SymbolInfo(String name, String type, boolean isArray, int arraySize,
                   boolean isParam, boolean isGlobal, int line, int col) {
            this.name = name;
            this.type = type;
            this.isArray = isArray;
            this.arraySize = arraySize;
            this.isParam = isParam;
            this.isGlobal = isGlobal;
            this.line = line;
            this.col = col;
        }
    }

    static class FunctionInfo {
        final String name;
        final String returnType;
        final ArrayList<SymbolInfo> params = new ArrayList<>();
        boolean hasReturn = false;

        FunctionInfo(String name, String returnType) {
            this.name = name;
            this.returnType = returnType;
        }
    }

    static class ExprAttr {
        final String place;
        final String type;
        final boolean constant;
        final String location;      // l-value textual descriptor (e.g., arr[idx]) when aplica
        final SymbolInfo symbolInfo; // referencia al simbolo propietario (para arreglos)
        final String indexPlace;    // expresion utilizada para indexar arreglos

        ExprAttr(String place, String type, boolean constant) {
            this(place, type, constant, null, null, null);
        }

        ExprAttr(String place, String type, boolean constant, String location,
                 SymbolInfo symbolInfo, String indexPlace) {
            this.place = place;
            this.type = type;
            this.constant = constant;
            this.location = location;
            this.symbolInfo = symbolInfo;
            this.indexPlace = indexPlace;
        }

        static ExprAttr invalid() {
            return new ExprAttr("__err", "ERROR", true);
        }

        boolean isValid() {
            return place != null && type != null && !"ERROR".equals(type);
        }

        boolean isNumeric() {
            return "INT".equals(type) || "FLOAT".equals(type);
        }

        boolean isBoolean() {
            return "BOOL".equals(type);
        }

        boolean isArrayReference() {
            return location != null && symbolInfo != null && indexPlace != null;
        }
    }

    static class ForContext {
        final String target;
        final String type;
        final ExprAttr step;
        final ExprAttr limit;
        final boolean downto;
        final String condLabel;
        final String endLabel;

        ForContext(String target, String type, ExprAttr step, ExprAttr limit, boolean downto, String condLabel, String endLabel) {
            this.target = target;
            this.type = type;
            this.step = step;
            this.limit = limit;
            this.downto = downto;
            this.condLabel = condLabel;
            this.endLabel = endLabel;
        }
    }

    ArrayDeque<ForContext> forStack = new ArrayDeque<>();

    /**
     * Proposito: construir el parser e inicializar las estructuras de alcance.
     * Entradas: instancia de Lexer generada por JFlex que entrega los tokens.
     * Salidas: parser listo para usarse con fabrica de simbolos y alcance global cargado.
     * Restricciones: la referencia al lexer no debe ser nula.
     */
    @SuppressWarnings("deprecation")
    public Parser(Lexer lex) {
        this.lex = lex;
        this.symbolFactory = new DefaultSymbolFactory();
        initializeGlobalScope();
    }

    /**
     * Proposito: garantizar que el alcance global exista antes de cualquier declaracion.
     * Entradas: ninguna; usa los campos internos del parser.
     * Salidas: registros creados para globalHash dentro de scopePrograma y semanticScopes.
     * Restricciones: idealmente se ejecuta una sola vez en la inicializacion.
     */
    private void initializeGlobalScope() {
        if (!scopePrograma.containsKey(globalHash)) {
            scopePrograma.put(globalHash, new ArrayList<>());
        }
        if (!semanticScopes.containsKey(globalHash)) {
            semanticScopes.put(globalHash, new LinkedHashMap<>());
        }
    }

    /**
     * Proposito: crear bajo demanda los contenedores asociados a un alcance.
     * Entradas: nombre del alcance que se desea preparar.
     * Salidas: registros inicializados en scopePrograma y semanticScopes.
     * Restricciones: el nombre del alcance no debe ser null.
     */
    private void ensureScopeBucket(String scope) {
        if (!scopePrograma.containsKey(scope)) {
            scopePrograma.put(scope, new ArrayList<>());
        }
        if (!semanticScopes.containsKey(scope)) {
            semanticScopes.put(scope, new LinkedHashMap<>());
        }
    }

    /**
     * Proposito: convertir un simbolo CUP en linea 1-based para diagnosticos.
     * Entradas: simbolo sintactico proveniente de las acciones de la gramatica.
     * Salidas: numero de linea >=1 o -1 cuando no hay coordenadas.
     * Restricciones: depende del atributo left proporcionado por CUP.
     */
    private int toLine(Symbol sym) {
        return (sym == null || sym.left < 0) ? -1 : sym.left + 1;
    }

    /**
     * Proposito: obtener la posicion de columna (1-based) de un simbolo CUP.
     * Entradas: simbolo a inspeccionar.
     * Salidas: numero de columna >=1 o -1 si no existe informacion.
     * Restricciones: usa el atributo right calculado por CUP.
     */
    private int toColumn(Symbol sym) {
        return (sym == null || sym.right < 0) ? -1 : sym.right + 1;
    }

    /**
     * Proposito: formatear una cadena legible con la posicion del simbolo.
     * Entradas: simbolo que contiene metadatos de linea/columna.
     * Salidas: texto " (linea X, columna Y)" o cadena vacia si faltan datos.
     * Restricciones: solo tiene sentido cuando el simbolo tiene coordenadas.
     */
    private String posString(Symbol sym) {
        int line = toLine(sym);
        int col = toColumn(sym);
        if (line < 0 || col < 0) {
            return "";
        }
        return " (linea " + line + ", columna " + col + ")";
    }

    /**
     * Proposito: centralizar el registro y almacenamiento de errores semanticos.
     * Entradas: mensaje descriptivo y simbolo relacionado para la posicion.
     * Salidas: linea en stderr y adicion a la lista semanticErrors.
     * Restricciones: protege contra simbolos nulos antes de usar sus datos.
     */
    private void reportSemanticError(String message, Symbol sym) {
        String formatted = "[SEMANTICO] " + message + posString(sym);
        semanticErrors.add(formatted);
        System.err.println(formatted);
    }

    /**
     * Proposito: detectar si la ejecucion ocurre en la raiz del repo o dentro de /programa.
     * Entradas: ninguna; se basa en el directorio de trabajo actual.
     * Salidas: Path base que contiene las carpetas src y output.
     * Restricciones: si no se puede detectar, regresa el directorio actual.
     */
    private Path resolveProjectBaseDir() {
        Path cwd = Paths.get(System.getProperty("user.dir")).toAbsolutePath();
        if (Files.isDirectory(cwd.resolve("src")) && Files.isDirectory(cwd.resolve("output"))) {
            return cwd;
        }
        Path nested = cwd.resolve("programa");
        if (Files.isDirectory(nested) && Files.isDirectory(nested.resolve("src"))) {
            return nested;
        }
        return cwd;
    }

    /**
     * Proposito: obtener la tabla semantica de un alcance, creandola si no existe.
     * Entradas: nombre textual del alcance solicitado.
     * Salidas: LinkedHashMap con los SymbolInfo del alcance.
     * Restricciones: el nombre no debe ser null; la creacion es idempotente.
     */
    private LinkedHashMap<String, SymbolInfo> semanticScope(String scopeName) {
        ensureScopeBucket(scopeName);
        return semanticScopes.get(scopeName);
    }

    /**
     * Proposito: declarar un simbolo dentro del alcance correspondiente y registrar su metadata.
     * Entradas: alcance propietario, lexema, tipo, indicadores de arreglo, bandera de parametro/global y token para ubicacion.
     * Salidas: SymbolInfo almacenado en semanticScopes y linea resumen en scopePrograma.
     * Restricciones: evita duplicados por alcance y usa el global cuando owner es null.
     */
    private SymbolInfo declareSymbol(String ownerScope, String name, String type,
                                     boolean isArray, int arraySize, boolean isParam,
                                     boolean forceGlobal, Symbol token) {
        String scopeName = forceGlobal ? globalHash : (ownerScope != null ? ownerScope : globalHash);
        ensureScopeBucket(scopeName);
        LinkedHashMap<String, SymbolInfo> table = semanticScopes.get(scopeName);
        if (table.containsKey(name)) {
            reportSemanticError("El identificador '" + name + "' ya existe en el alcance '" + scopeName + "'", token);
            return null;
        }
        SymbolInfo info = new SymbolInfo(name, type, isArray, arraySize, isParam,
                                         scopeName.equals(globalHash), toLine(token), toColumn(token));
        table.put(name, info);

        ArrayList<String> bucket = scopePrograma.get(scopeName);
        if (bucket == null) {
            bucket = new ArrayList<>();
            scopePrograma.put(scopeName, bucket);
        }
        String lineStr = info.line >= 0 ? Integer.toString(info.line) : "n/a";
        String colStr = info.col >= 0 ? Integer.toString(info.col) : "n/a";
        String prefix;
        if (isParam) {
            prefix = "Parametro";
        } else if (scopeName.equals(globalHash)) {
            prefix = "Instancia GLOBAL";
        } else {
            prefix = "Instancia";
        }
        String typeLabel = isArray ? ("ARR:" + type) : type;
        bucket.add(prefix + ": " + name + ":" + typeLabel + ":line=" + lineStr + ":col=" + colStr);
        return info;
    }

    /**
     * Proposito: resolver identificadores buscando primero en el alcance actual y luego en el global.
     * Entradas: lexema a localizar.
     * Salidas: SymbolInfo encontrado o null si no existe declaracion.
     * Restricciones: depende de currentHash para conocer el alcance activo.
     */
    private SymbolInfo lookupSymbol(String name) {
        if (currentHash != null) {
            LinkedHashMap<String, SymbolInfo> local = semanticScopes.get(currentHash);
            if (local != null && local.containsKey(name)) {
                return local.get(name);
            }
        }
        LinkedHashMap<String, SymbolInfo> global = semanticScopes.get(globalHash);
        if (global != null && global.containsKey(name)) {
            return global.get(name);
        }
        return null;
    }

    /**
     * Proposito: construir los atributos de una expresion basada en un identificador simple.
     * Entradas: lexema y simbolo que origina la referencia.
     * Salidas: ExprAttr con place/type o un marcador invalido si hay errores.
     * Restricciones: los arreglos requieren indice y se rechazan aqui.
     */
    private ExprAttr identifierExpr(String name, Symbol token) {
        SymbolInfo info = lookupSymbol(name);
        if (info == null) {
            reportSemanticError("El identificador '" + name + "' no ha sido declarado", token);
            return ExprAttr.invalid();
        }
        if (info.isArray) {
            reportSemanticError("El identificador '" + name + "' es un arreglo, se requiere indice", token);
            return ExprAttr.invalid();
        }
        return new ExprAttr(name, info.type, false);
    }

    /**
     * Proposito: validar y describir el acceso a un elemento de arreglo generando TAC explicito.
     * Entradas: nombre del arreglo, expresion de indice y simbolos para diagnosticos.
     * Salidas: ExprAttr con el temporal cargado desde memoria y los metadatos necesarios para reasignaciones.
     * Restricciones: requiere arreglo declarado, indice INT valido y verifica limites cuando sea posible.
     */
    private ExprAttr arrayAccess(String name, ExprAttr index, Symbol idSym, Symbol idxSym) {
        SymbolInfo info = lookupSymbol(name);
        if (info == null) {
            reportSemanticError("El arreglo '" + name + "' no ha sido declarado", idSym);
            return ExprAttr.invalid();
        }
        if (!info.isArray) {
            reportSemanticError("El identificador '" + name + "' no es un arreglo", idSym);
            return ExprAttr.invalid();
        }
        if (index == null || !index.isValid()) {
            reportSemanticError("El indice para '" + name + "' es invalido", idxSym != null ? idxSym : idSym);
            return ExprAttr.invalid();
        }
        if (!"INT".equals(index.type)) {
            reportSemanticError("El indice para '" + name + "' debe ser de tipo INT", idxSym != null ? idxSym : idSym);
            return ExprAttr.invalid();
        }
        if (info.arraySize > 0 && index.constant) {
            try {
                int idxVal = Integer.parseInt(index.place);
                if (idxVal < 0 || idxVal >= info.arraySize) {
                    reportSemanticError("Indice fuera de rango para '" + name + "' (0.." + (info.arraySize - 1) + ")", idxSym != null ? idxSym : idSym);
                }
            } catch (NumberFormatException ignore) {
                // Si no se puede evaluar en tiempo de compilacion no se aplica la verificacion
            }
        }

        String loadTemp = newTemp(info.type);
        emit("aload " + loadTemp + ", " + name + ", " + index.place);
        String location = name + "[" + index.place + "]";
        return new ExprAttr(loadTemp, info.type, false, location, info, index.place);
    }

    /**
     * Proposito: centralizar la escritura de valores dentro de un arreglo en el TAC.
     * Entradas: referencia al ExprAttr que apunta al elemento, valor evaluado y simbolo para diagnosticos.
     * Salidas: instruccion 'astore' que refleja la asignacion.
     * Restricciones: el ExprAttr debe representar un elemento de arreglo y los tipos deben coincidir.
     */
    private void emitArrayStore(ExprAttr target, ExprAttr value, Symbol token) {
        if (target == null || !target.isArrayReference()) {
            reportSemanticError("Se intento asignar a un destino que no es un arreglo", token);
            return;
        }
        if (value == null || !value.isValid()) {
            reportSemanticError("Expresion invalida al asignar a arreglo", token);
            return;
        }
        if (!target.type.equals(value.type)) {
            reportSemanticError("Tipos incompatibles al asignar a arreglo: se esperaba '" + target.type + "' y se recibio '" + value.type + "'", token);
            return;
        }
        emit("astore " + target.symbolInfo.name + ", " + target.indexPlace + ", " + value.place);
    }

    /**
     * Proposito: verificar que una lista de inicializacion de arreglos no mezcle tipos diferentes.
     * Entradas: lista de ExprAttr y simbolo para diagnosticos.
     * Salidas: true cuando todos los elementos comparten el mismo tipo; false en caso contrario.
     * Restricciones: ignora entradas nulas o invalidas para evitar duplicar mensajes previos.
     */
    private boolean ensureHomogeneousElements(ArrayList<ExprAttr> list, Symbol token) {
        if (list == null || list.isEmpty()) {
            return true;
        }
        String baseType = null;
        boolean ok = true;
        for (ExprAttr expr : list) {
            if (expr == null || !expr.isValid()) {
                continue;
            }
            if (baseType == null) {
                baseType = expr.type;
            } else if (!baseType.equals(expr.type)) {
                reportSemanticError("Los elementos del arreglo deben ser del mismo tipo; se encontro '" + expr.type + "' y '" + baseType + "'", token);
                ok = false;
            }
        }
        return ok;
    }

    /**
     * Proposito: realizar las validaciones semanticas de una llamada e imprimir el codigo 3D correspondiente.
     * Entradas: nombre de la funcion, lista de argumentos evaluados y simbolo del sitio de llamada.
     * Salidas: ExprAttr que referencia el temporal de retorno; registra errores si algo no coincide.
     * Restricciones: la funcion debe existir previamente y los tipos de los argumentos deben coincidir de forma exacta.
     */
    private ExprAttr invokeFunction(String name, ArrayList<ExprAttr> args, Symbol token) {
        FunctionInfo fun = functionTable.get(name);
        if (fun == null) {
            reportSemanticError("La funcion '" + name + "' no ha sido declarada", token);
            return ExprAttr.invalid();
        }
        if (args == null) {
            args = new ArrayList<>();
        }
        if (fun.params.size() != args.size()) {
            reportSemanticError("La funcion '" + name + "' espera " + fun.params.size() + " parametros y recibe " + args.size(), token);
        } else {
            for (int i = 0; i < fun.params.size(); i++) {
                SymbolInfo param = fun.params.get(i);
                ExprAttr provided = args.get(i);
                if (provided == null || !provided.isValid()) {
                    reportSemanticError("Parametro " + (i+1) + " invalido al invocar '" + name + "'", token);
                    continue;
                }
                if (!param.type.equals(provided.type)) {
                    reportSemanticError("Parametro " + (i+1) + " de '" + name + "' espera '" + param.type + "' y recibe '" + provided.type + "'", token);
                }
            }
        }
        for (ExprAttr expr : args) {
            if (expr != null && expr.isValid()) {
                emit("param " + expr.place);
            }
        }
        String temp = newTemp(fun.returnType);
        emit(temp + " = call " + name + ", " + args.size());
        return new ExprAttr(temp, fun.returnType, false);
    }

    /**
     * Proposito: preparar las estructuras internas para una nueva declaracion de funcion.
     * Entradas: nombre de la funcion, tipo de retorno y simbolo de declaracion.
     * Salidas: registros en functionTable/scopePrograma y emision del bloque begin_func.
     * Restricciones: reporta error si la funcion ya existia.
     */
    private void startFunctionScope(String name, String returnType, Symbol token) {
        if (functionTable.containsKey(name)) {
            reportSemanticError("La funcion '" + name + "' ya fue declarada", token);
            return;
        }
        FunctionInfo info = new FunctionInfo(name, returnType);
        functionTable.put(name, info);
        currentHash = name;
        ArrayList<String> bucket = new ArrayList<>();
        bucket.add("tipo:func:" + returnType);
        scopePrograma.put(name, bucket);
        semanticScopes.put(name, new LinkedHashMap<>());
    }

    /**
     * Proposito: abandonar el alcance de funcion en el que se estaba trabajando.
     * Entradas: ninguna (usa currentHash).
     * Salidas: restablece currentHash para que las declaraciones regresen al alcance global.
     * Restricciones: debe invocarse una sola vez por startFunctionScope.
     */
    private void closeCurrentScope() {
        currentHash = null;
    }

    /**
     * Proposito: recuperar la metadata de la funcion que se esta procesando.
     * Entradas: ninguna.
     * Salidas: instancia FunctionInfo o null si no estamos dentro de una funcion.
     * Restricciones: depende de que currentHash refleje el alcance real.
     */
    private FunctionInfo currentFunction() {
        if (currentHash == null) {
            return null;
        }
        return functionTable.get(currentHash);
    }

    /**
     * Proposito: registrar un parametro formal tanto en la tabla semantica como en la metadata de la funcion.
     * Entradas: nombre/tipo del parametro y coordenadas del token original.
     * Salidas: SymbolInfo almacenado en el alcance actual y agregado a la lista de parametros.
     * Restricciones: asume que currentHash apunta a la funcion propietaria.
     */
    private void registrarParametroEnScope(String nombre, String tipo, int left, int right) {
        Symbol fake = new Symbol(sym.IDENTIFIER, left, right, nombre);
        SymbolInfo info = declareSymbol(currentHash, nombre, tipo, false, 0, true, false, fake);
        FunctionInfo fun = currentFunction();
        if (fun != null && info != null) {
            fun.params.add(info);
        }
    }

    /**
     * Proposito: encapsular literales o valores por defecto dentro de un ExprAttr.
     * Entradas: simbolo CUP (puede ser null), texto por defecto y tipo semantico.
     * Salidas: ExprAttr marcado como constante con el place/type correspondiente.
     * Restricciones: quien llama debe asegurarse de que el tipo sea compatible con el lenguaje.
     */
    private ExprAttr literalAttr(Symbol sym, String fallback, String type) {
        String raw = sym != null && sym.value != null ? sym.value.toString() : fallback;
        if (raw == null) {
            raw = fallback != null ? fallback : "0";
        }
        return new ExprAttr(raw, type, true);
    }

    /**
     * Proposito: asegurar que una expresion sea numerica antes de usarla en aritmetica.
     * Entradas: ExprAttr a validar, simbolo para reportar el error y descripcion textual del contexto.
     * Salidas: el mismo ExprAttr si es valido o un marcador invalido con registro de error.
     * Restricciones: se espera que expr no sea null y que ya tenga tipo asociado.
     */
    private ExprAttr ensureNumeric(ExprAttr expr, Symbol token, String context) {
        if (expr == null || !expr.isValid() || !expr.isNumeric()) {
            reportSemanticError("Se esperaba expresion numerica en " + context, token);
            return ExprAttr.invalid();
        }
        return expr;
    }

    /**
     * Proposito: aplicar las reglas semanticas de operadores aritmeticos binarios y emitir su TAC.
     * Entradas: lexema del operador, operandos izquierdo/derecho y simbolo para diagnosticos.
     * Salidas: ExprAttr que apunta al nuevo temporal generado; invalido si ocurre algun error.
     * Restricciones: ambos operandos deben ser numericos; se promociona a FLOAT si es necesario.
     */
    private ExprAttr numericBinary(String op, ExprAttr left, ExprAttr right, Symbol token) {
        if (left == null) left = ExprAttr.invalid();
        if (right == null) right = ExprAttr.invalid();
        if (!left.isValid() || !right.isValid()) {
            reportSemanticError("Operacion aritmetica invalida", token);
            return ExprAttr.invalid();
        }
        if (!left.isNumeric() || !right.isNumeric()) {
            reportSemanticError("Operacion '" + op + "' solo soporta INT/FLOAT", token);
            return ExprAttr.invalid();
        }
        if (!left.type.equals(right.type)) {
            reportSemanticError("No se puede operar '" + left.type + "' con '" + right.type + "' usando '" + op + "'", token);
            return ExprAttr.invalid();
        }
        String resultType = left.type;
        String temp = newTemp(resultType);
        emit(temp + " = " + left.place + " " + op + " " + right.place);
        return new ExprAttr(temp, resultType, false);
    }

    /**
     * Proposito: procesar operadores numericos unarios y emitir su TAC.
     * Entradas: lexema del operador, expresion operando y simbolo para diagnosticos.
     * Salidas: ExprAttr que referencia el temporal resultante.
     * Restricciones: el operando debe ser numerico; los errores propagan expresiones invalidas.
     */
    private ExprAttr numericUnary(String op, ExprAttr value, Symbol token) {
        if (value == null || !value.isValid() || !value.isNumeric()) {
            reportSemanticError("Operacion '" + op + "' requiere un numerico", token);
            return ExprAttr.invalid();
        }
        String temp = newTemp(value.type);
        emit(temp + " = " + op + value.place);
        return new ExprAttr(temp, value.type, false);
    }

    /**
     * Proposito: aplicar las reglas de comparacion y generar temporales booleanos.
     * Entradas: operador, operandos izquierdo/derecho y simbolo CUP para los mensajes.
     * Salidas: ExprAttr de tipo BOOL que referencia el codigo emitido.
     * Restricciones: si los operandos no son numericos deben compartir exactamente el mismo tipo.
     */
    private ExprAttr compareBinary(String op, ExprAttr left, ExprAttr right, Symbol token) {
        if (left == null) left = ExprAttr.invalid();
        if (right == null) right = ExprAttr.invalid();
        if (!left.isValid() || !right.isValid()) {
            reportSemanticError("Comparacion invalida", token);
            return ExprAttr.invalid();
        }
        if (!left.type.equals(right.type)) {
            reportSemanticError("Comparacion requiere operandos del mismo tipo; se obtuvo '" + left.type + "' y '" + right.type + "'", token);
            return ExprAttr.invalid();
        }
        boolean equalityOp = "==".equals(op) || "!=".equals(op);
        if (equalityOp) {
            if (!left.isNumeric() && !left.isBoolean() && !"CHAR".equals(left.type) && !"STRING".equals(left.type)) {
                reportSemanticError("Comparacion no soportada para tipo '" + left.type + "'", token);
                return ExprAttr.invalid();
            }
        } else if (!left.isNumeric()) {
            reportSemanticError("El operador '" + op + "' solo admite operandos numericos del mismo tipo", token);
            return ExprAttr.invalid();
        }
        String temp = newTemp("BOOL");
        emit(temp + " = " + left.place + " " + op + " " + right.place);
        return new ExprAttr(temp, "BOOL", false);
    }

    /**
     * Proposito: validar operaciones logicas tipo AND/OR a nivel semantico.
     * Entradas: operador logico, operandos booleanos y simbolo con datos de error.
     * Salidas: ExprAttr booleano ligado al temporal que almacena el resultado.
     * Restricciones: ambos operandos deben ser BOOL.
     */
    private ExprAttr logicalBinary(String op, ExprAttr left, ExprAttr right, Symbol token) {
        if (left == null || right == null || !left.isBoolean() || !right.isBoolean()) {
            reportSemanticError("Operacion logica requiere booleanos", token);
            return ExprAttr.invalid();
        }
        String temp = newTemp("BOOL");
        emit(temp + " = " + left.place + " " + op + " " + right.place);
        return new ExprAttr(temp, "BOOL", false);
    }

    /**
     * Proposito: procesar operadores logicos unarios como la negacion.
     * Entradas: operador, expresion operando y simbolo fuente.
     * Salidas: ExprAttr booleano cuando el operando es valido.
     * Restricciones: solo acepta entradas booleanas.
     */
    private ExprAttr logicalUnary(String op, ExprAttr value, Symbol token) {
        if (value == null || !value.isBoolean()) {
            reportSemanticError("Operacion logica requiere booleano", token);
            return ExprAttr.invalid();
        }
        String temp = newTemp("BOOL");
        emit(temp + " = " + op + " " + value.place);
        return new ExprAttr(temp, "BOOL", false);
    }

    /**
     * Proposito: salvaguardar sentencias que dependen de expresiones booleanas.
     * Entradas: ExprAttr evaluado, simbolo para ubicar el error y descripcion del contexto.
     * Salidas: ninguna; solo reporta el error cuando la condicion no se cumple.
     * Restricciones: aun con el reporte, quien llama debe manejar expresiones invalidas.
     */
    private void ensureBoolean(ExprAttr expr, Symbol token, String context) {
        if (expr == null || !expr.isBoolean()) {
            reportSemanticError("La expresion en " + context + " debe ser BOOL", token);
        }
    }

    /**
     * Proposito: centralizar las validaciones de asignaciones escalares y la emision de TAC.
     * Entradas: metadata del destino, expresion evaluada y simbolo '='.
     * Salidas: emite el codigo de asignacion cuando los tipos coinciden.
     * Restricciones: el destino no puede ser arreglo y los tipos tienen que ser identicos.
     */
    private void recordAssignment(SymbolInfo target, ExprAttr value, Symbol token) {
        if (target == null || value == null || !value.isValid()) {
            reportSemanticError("Asignacion invalida", token);
            return;
        }
        if (!target.type.equals(value.type)) {
            reportSemanticError("Tipos incompatibles en asignacion para '" + target.name + "'", token);
            return;
        }
        emit(target.name + " = " + value.place);
    }

    /**
     * Proposito: validar las sentencias return y marcar que la funcion retorno.
     * Entradas: expresion opcional, simbolo y bandera que indica si hay valor explicito.
     * Salidas: emite el TAC del return cuando los tipos coinciden; reporta errores cuando falta.
     * Restricciones: no puede usarse fuera de los alcances de funcion.
     */
    private void recordReturn(ExprAttr value, Symbol token, boolean hasValue) {
        FunctionInfo fun = currentFunction();
        if (fun == null) {
            reportSemanticError("Return fuera de una funcin", token);
            return;
        }
        fun.hasReturn = true;
        if (!hasValue) {
            reportSemanticError("Return requiere una expresin para funcin '" + fun.name + "'", token);
            return;
        }
        if (value == null || !value.isValid()) {
            reportSemanticError("Return invlido", token);
            return;
        }
        if (!fun.returnType.equals(value.type)) {
            reportSemanticError("El return espera tipo '" + fun.returnType + "' y recibe '" + value.type + "'", token);
        }
        emit("return " + value.place);
    }

    /**
     * Proposito: generar identificadores unicos para temporales.
     * Entradas: etiqueta de tipo solo para fines descriptivos.
     * Salidas: nombre de cadena para usarse en el TAC.
     * Restricciones: no depender del prefijo mas alla de la legibilidad.
     */
    private String newTemp(String type) {
        tempCounter++;
        return ("FLOAT".equals(type) ? "f" : "t") + tempCounter;
    }

    /**
     * Proposito: crear etiquetas unicas para estructuras de control.
     * Entradas: prefijo textual que describe la construccion.
     * Salidas: etiqueta con un contador incremental.
     * Restricciones: el prefijo debe ser descriptivo para ayudar al depurado.
     */
    private String newLabel(String prefix) {
        labelCounter++;
        return prefix + "_" + labelCounter;
    }

    /**
     * Proposito: agregar una instruccion al buffer de codigo 3D.
     * Entradas: linea de TAC ya formateada.
     * Salidas: actualiza cod3D con la linea mas un salto de linea.
     * Restricciones: quien llama debe evitar cadenas nulas o vacias.
     */
    private void emit(String codeLine) {
        cod3D.append(codeLine).append("\n");
    }

    /**
     * Proposito: imprimir la declaracion de una etiqueta dentro del codigo 3D.
     * Entradas: etiqueta generada previamente.
     * Salidas: escribe "label:" seguido de salto de linea en cod3D.
     * Restricciones: solo debe llamarse con etiquetas unicas.
     */
    private void emitLabel(String label) {
        cod3D.append(label).append(":\n");
    }

    /**
     * Proposito: convertir literales CUP en enteros primitivos para tamanos de arreglo.
     * Entradas: simbolo que contiene digitos.
     * Salidas: valor entero o 0 si la conversion falla.
     * Restricciones: pensado para literales decimales no negativos.
     */
    private int literalToInt(Symbol sym) {
        if (sym != null && sym.value != null) {
            try {
                return Integer.parseInt(sym.value.toString());
            } catch (NumberFormatException ex) {
                reportSemanticError("Valor numrico invlido", sym);
            }
        }
        return 0;
    }

    /**
     * Proposito: construir simbolos CUP sinteticos para llamadas auxiliares internas.
     * Entradas: valor bruto, coordenadas y el id del simbolo.
     * Salidas: Symbol con la metadata proporcionada.
     * Restricciones: usar solo para diagnostico, nunca para devolverlo al lexer.
     */
    private Symbol tokenFrom(Object value, int left, int right, int symId) {
        return new Symbol(symId, left, right, value);
    }

    /**
     * Proposito: convertir valores arbitrarios de tokens en cadenas seguras y no nulas.
     * Entradas: referencia proveniente del lexer o de auxiliares.
     * Salidas: representacion en cadena o vacio si es null.
     * Restricciones: utilidad simple; quien llama puede aplicar trim si lo requiere.
     */
    private String lexeme(Object value) {
        return value != null ? value.toString() : "";
    }

    /**
     * Proposito: inicializar las pilas antes de procesar un decide-of.
     * Entradas: ninguna.
     * Salidas: apila la etiqueta de cierre para usarla en las ramas.
     * Restricciones: debe emparejarse con endDecideStructure.
     */
    private void beginDecideStructure() {
        decideEndStack.push(newLabel("decide_end"));
    }

    /**
     * Proposito: cerrar la estructura decide-of y emitir su etiqueta final.
     * Entradas: ninguna.
     * Salidas: imprime la etiqueta pendiente y limpia las pilas.
     * Restricciones: asume que beginDecideStructure ya se invoco.
     */
    private void endDecideStructure() {
        if (!decideEndStack.isEmpty()) {
            emitLabel(decideEndStack.pop());
        }
    }

    /**
     * Proposito: iniciar un caso dentro de decide-of validando su condicion y preparando los saltos.
     * Entradas: expresion condicional y simbolo para diagnosticos.
     * Salidas: emite los saltos condicionales y apila la etiqueta de continuacion.
     * Restricciones: la condicion debe ser booleana o se reporta error.
     */
    private void beginDecideCase(ExprAttr condition, Symbol token) {
        if (condition == null || !condition.isBoolean()) {
            reportSemanticError("La condicin de decide debe ser BOOL", token);
            return;
        }
        String hitLabel = newLabel("case_hit");
        String nextLabel = newLabel("case_next");
        emit("if " + condition.place + " goto " + hitLabel);
        emit("goto " + nextLabel);
        emitLabel(hitLabel);
        decideNextStack.push(nextLabel);
    }

    /**
     * Proposito: cerrar el caso activo de decide y ajustar el flujo de control.
     * Entradas: ninguna.
     * Salidas: emite el salto hacia la etiqueta final y declara la etiqueta siguiente almacenada.
     * Restricciones: requiere que beginDecideCase haya colocado una etiqueta en la pila.
     */
    private void endDecideCase() {
        String endLabel = decideEndStack.peek();
        String nextLabel = decideNextStack.isEmpty() ? newLabel("case_next") : decideNextStack.pop();
        emit("goto " + endLabel);
        emitLabel(nextLabel);
    }

    /**
     * Proposito: preparar la rama else del decide-of.
     * Entradas: ninguna.
     * Salidas: emite un comentario para claridad y reutiliza las etiquetas en pila.
     * Restricciones: se debe invocar una sola vez por cada decide-of.
     */
    private void beginDecideElse() {
        emit("// else branch");
    }

    /**
     * Proposito: cerrar la rama else saltando hacia la etiqueta final del decide.
     * Entradas: ninguna.
     * Salidas: emite un goto hacia la etiqueta de cierre.
     * Restricciones: asume que decideEndStack tiene una entrada vigente.
     */
    private void endDecideElse() {
        String endLabel = decideEndStack.peek();
        emit("goto " + endLabel);
    }

    /**
     * Proposito: inicializar las pilas de control para una estructura loop.
     * Entradas: ninguna.
     * Salidas: apila etiquetas de inicio/fin y emite la cabecera del ciclo.
     * Restricciones: debe emparejarse con endLoopStructure.
     */
    private void beginLoopStructure() {
        String start = newLabel("loop_begin");
        String end = newLabel("loop_end");
        loopStartStack.push(start);
        loopEndStack.push(end);
        emitLabel(start);
    }

    /**
     * Proposito: cerrar una estructura loop y desapilar sus etiquetas de control.
     * Entradas: ninguna.
     * Salidas: emite la etiqueta de fin y limpia las pilas.
     * Restricciones: solo es valido si beginLoopStructure fue invocado.
     */
    private void endLoopStructure() {
        if (!loopEndStack.isEmpty()) {
            emitLabel(loopEndStack.pop());
        }
        if (!loopStartStack.isEmpty()) {
            loopStartStack.pop();
        }
    }

    /**
     * Proposito: emitir la condicion de salida que abandona el cuerpo de un loop.
     * Entradas: expresion booleana de salida y simbolo relacionado.
     * Salidas: genera el salto condicional al final del loop y el retorno al inicio.
     * Restricciones: la expresion debe evaluar a BOOL.
     */
    private void finalizeLoopBody(ExprAttr exitExpr, Symbol token) {
        if (exitExpr == null || !exitExpr.isBoolean()) {
            reportSemanticError("La condicin de salida del loop debe ser BOOL", token);
            return;
        }
        String start = loopStartStack.peek();
        String end = loopEndStack.peek();
        emit("if " + exitExpr.place + " goto " + end);
        emit("goto " + start);
    }

    /**
     * Proposito: validar y emitir la estructura base de los ciclos FOR/DOWNTO.
     * Entradas: expresion de la variable control, paso, limite y bandera de direccion.
     * Salidas: emite etiquetas de condicion/cuerpo y almacena el contexto del ciclo.
     * Restricciones: todas las expresiones deben ser numericas y el destino asignable.
     */
    private void beginForLoop(ExprAttr target, ExprAttr step, ExprAttr limit, boolean downto) {
        if (target == null || !target.isNumeric()) {
            reportSemanticError("La variable de control del for debe ser numrica", null);
            return;
        }
        if (step == null || !step.isNumeric()) {
            reportSemanticError("El paso del for debe ser numrico", null);
            return;
        }
        if (limit == null || !limit.isNumeric()) {
            reportSemanticError("El lmite del for debe ser numrico", null);
            return;
        }
        String condLabel = newLabel("for_cond");
        String bodyLabel = newLabel("for_body");
        String endLabel = newLabel("for_end");
        emitLabel(condLabel);
        String comparator = downto ? "<" : ">";
        emit("if " + target.place + " " + comparator + " " + limit.place + " goto " + endLabel);
        emitLabel(bodyLabel);
        loopStartStack.push(condLabel);
        loopEndStack.push(endLabel);
        forStack.push(new ForContext(target.place, target.type, step, limit, downto, condLabel, endLabel));
    }

    /**
     * Proposito: cerrar los ciclos FOR emitiendo el incremento/decremento y limpiando el estado.
     * Entradas: ninguna (usa la pila de contexto).
     * Salidas: actualiza la variable de control, regresa a la condicion y emite la etiqueta final.
     * Restricciones: asume que beginForLoop inserto un contexto en forStack.
     */
    private void endForLoop() {
        if (forStack.isEmpty()) {
            return;
        }
        ForContext ctx = forStack.pop();
        String op = ctx.downto ? "-" : "+";
        emit(ctx.target + " = " + ctx.target + " " + op + " " + ctx.step.place);
        emit("goto " + ctx.condLabel);
        emitLabel(ctx.endLabel);
        if (!loopEndStack.isEmpty()) loopEndStack.pop();
        if (!loopStartStack.isEmpty()) loopStartStack.pop();
    }

    /**
     * Proposito: volcar las tablas de simbolos en CSV y mostrar un resumen en consola.
     * Entradas: ninguna (usa el mapa scopePrograma).
     * Salidas: escribe TablaSimbolos.txt dentro del directorio de salida determinado.
     * Restricciones: garantiza que el directorio exista y maneja alcances vacios sin fallar.
     */
    public void imprimirscopePrograma () {
        System.out.println("\nTABLA DE SIMBOLOS (resumen)");
        try {
            Path outDir = resolveProjectBaseDir().resolve("output");
            Files.createDirectories(outDir);

            if (scopePrograma.isEmpty()) {
                scopePrograma.put(globalHash, new ArrayList<>());
            }

            Path tablaFile = outDir.resolve("TablaSimbolos.txt");
            Pattern p = Pattern.compile(".*:\\s*([^:]+):([^:]+)(:line=(\\d+):col=(\\d+))?.*");
            try (FileWriter fw = new FileWriter(tablaFile.toFile())) {
                fw.write("Scope,Name,Type,Line,Column\n");
                for (Map.Entry<String, ArrayList<String>> entry : scopePrograma.entrySet()) {
                    String key = entry.getKey();
                    System.out.println("Scope: " + key + "  (" + entry.getValue().size() + " entradas)");
                    for (String item : entry.getValue()) {
                        String name="", type="", line="n/a", col="n/a";
                        String[] parts = item.split(":");
                        if (parts.length >= 2) {
                            name = parts[1].trim();
                        }
                        if (parts.length >= 3) {
                            for (int i = 2; i < parts.length; i++) {
                                String part = parts[i].trim();
                                if (part.equals("INT") || part.equals("CHAR") || part.equals("FLOAT") || part.equals("BOOL") || part.equals("STRING") || part.startsWith("ARR") || part.startsWith("tipo:")) {
                                    type = part;
                                    break;
                                }
                            }
                            if (type.isEmpty()) {
                                type = parts[2].trim();
                            }
                        }
                        Matcher ml = Pattern.compile("line=(\\d+)").matcher(item);
                        if (ml.find()) line = ml.group(1);
                        Matcher mc = Pattern.compile("col=(\\d+)").matcher(item);
                        if (mc.find()) col = mc.group(1);
                        fw.write(key + "," + name + "," + type + "," + line + "," + col + "\n");
                    }
                }
            }

            System.out.println("Tablas de simbolos exportadas a: " + outDir.toAbsolutePath());
        } catch (Exception e) {
            System.err.println("Error al exportar tablas de simbolos: " + e.getMessage());
        }
    }

    /**
     * Proposito: persistir el codigo 3D generado en Codigo3D.txt.
     * Entradas: ninguna (usa el buffer cod3D).
     * Salidas: escribe el archivo y muestra el destino; avisa cuando no hay codigo.
     * Restricciones: crea el directorio de salida si falta y captura excepciones de IO.
     */
    private void exportarCodigo3D() {
        try {
            Path outDir = resolveProjectBaseDir().resolve("output");
            Files.createDirectories(outDir);
            Path cod3DFile = outDir.resolve("Codigo3D.txt");
            try (FileWriter fw = new FileWriter(cod3DFile.toFile())) {
                String codigo = cod3D.toString().trim();
                if (codigo.isEmpty()) {
                    fw.write("// No se genero codigo 3D\n");
                    System.out.println("Advertencia: No se genero codigo 3D");
                } else {
                    fw.write(codigo + "\n");
                    System.out.println("Codigo 3D exportado a: " + cod3DFile.toAbsolutePath());
                }
            }
        } catch (Exception e) {
            System.err.println("Error al exportar codigo 3D: " + e.getMessage());
        }
    }

    /**
     * Proposito: exportar tablas y codigo 3D solo una vez por ejecucion del parser.
     * Entradas: ninguna.
     * Salidas: invoca imprimirscopePrograma y exportarCodigo3D si aun no se han generado.
     * Restricciones: controlado por la bandera artifactsExported para evitar duplicados.
     */
    public void exportarResultados() {
        if (artifactsExported) {
            return;
        }
        imprimirscopePrograma();
        exportarCodigo3D();
        artifactsExported = true;
    }

    // recuperacin de errores de sintaxis (mejorada)
    /**
     * Proposito: ofrecer un gancho detallado para el manejo de errores sintacticos de CUP.
     * Entradas: simbolo que ocasiono el error (puede ser null en EOF).
     * Salidas: mensaje detallado en stderr con id de token, yytext y coordenadas.
     * Restricciones: no debe lanzar excepciones; se protege contra fallos del lexer.
     */
    public void syntax_error(Symbol s) {
        try {
            if (s == null) {
                String yy = "";
                try { yy = lex.yytext(); } catch (Exception e) { yy = "<no-yytext>"; }
                System.err.println("!!Error de Sintaxis: smbolo nulo (fin de fichero probable). yytext='" + yy + "'");
                return;
            }

            int symId = s.sym;
            Object val = s.value;
            int left = s.left;
            int right = s.right;
            String yytext = "";
            try { yytext = lex.yytext(); } catch (Exception e) { yytext = "<no-yytext>"; }

            System.err.println("!!Error de Sintaxis: tokenId=" + symId + " value=" + val + " yytext='" + yytext + "' linea:" + (left>=0 ? (left+1) : "n/a") + " columna:" + (right>=0 ? (right+1) : "n/a"));

        } catch (Exception e) {
            System.err.println("!!Error de Sintaxis (excepcin al informar): " + e.getMessage());
        }
    }

    /**
     * Proposito: informar errores sintacticos fatales cuando CUP no puede recuperarse.
     * Entradas: simbolo problematico o null.
     * Salidas: mensaje en stderr similar a syntax_error pero marcado como fatal.
     * Restricciones: no debe lanzar excepciones para permitir un cierre limpio del parser.
     */
    public void unrecovered_syntax_error(Symbol s) {
        try {
            if (s == null) {
                String yy = "";
                try { yy = lex.yytext(); } catch (Exception e) { yy = "<no-yytext>"; }
                System.err.println("!!Error fatal: smbolo nulo. yytext='" + yy + "'");
                return;
            }

            int symId = s.sym;
            Object val = s.value;
            int left = s.left;
            int right = s.right;
            String yytext = "";
            try { yytext = lex.yytext(); } catch (Exception e) { yytext = "<no-yytext>"; }

            System.err.println("!!Error fatal: tokenId=" + symId + " value=" + val + " yytext='" + yytext + "' linea:" + (left>=0 ? (left+1) : "n/a") + " columna:" + (right>=0 ? (right+1) : "n/a"));

        } catch (Exception e) {
            System.err.println("!!Error fatal (excepcin al informar): " + e.getMessage());
        }
    }


/** Cup generated class to encapsulate user supplied action code.*/
@SuppressWarnings({"rawtypes", "unchecked", "unused"})
class CUP$Parser$actions {
  private final Parser parser;

  /** Constructor */
  CUP$Parser$actions(Parser parser) {
    this.parser = parser;
  }

  /** Method 0 with the actual generated action code for actions 0 to 300. */
  public final java_cup.runtime.Symbol CUP$Parser$do_action_part00000000(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack            CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      /* Symbol object for return from actions */
      java_cup.runtime.Symbol CUP$Parser$result;

      /* select the action based on the action number */
      switch (CUP$Parser$act_num)
        {
          /*. . . . . . . . . . . . . . . . . . . .*/
          case 0: // $START ::= PROGRAMA EOF 
            {
              Object RESULT =null;
		int start_valleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int start_valright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Object start_val = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		RESULT = start_val;
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("$START",0, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          /* ACCEPT */
          CUP$Parser$parser.done_parsing();
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 1: // NT$0 ::= 
            {
              Object RESULT =null;
 initializeGlobalScope(); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("NT$0",51, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 2: // PROGRAMA ::= NT$0 PROGRAM_ITEMS 
            {
              Object RESULT =null;
              // propagate RESULT from NT$0
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		 exportarResultados(); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("PROGRAMA",1, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 3: // PROGRAM_ITEMS ::= mainStruct PROGRAM_ITEMS 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("PROGRAM_ITEMS",35, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 4: // PROGRAM_ITEMS ::= mainStruct 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("PROGRAM_ITEMS",35, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 5: // PROGRAM_ITEMS ::= funcStruct PROGRAM_ITEMS 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("PROGRAM_ITEMS",35, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 6: // PROGRAM_ITEMS ::= funcStruct 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("PROGRAM_ITEMS",35, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 7: // PROGRAM_ITEMS ::= arrayInsGl DOLLAR PROGRAM_ITEMS 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("PROGRAM_ITEMS",35, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 8: // PROGRAM_ITEMS ::= arrayInsGl DOLLAR 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("PROGRAM_ITEMS",35, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 9: // PROGRAM_ITEMS ::= varInsGl DOLLAR PROGRAM_ITEMS 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("PROGRAM_ITEMS",35, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 10: // PROGRAM_ITEMS ::= varInsGl DOLLAR 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("PROGRAM_ITEMS",35, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 11: // PROGRAM_ITEMS ::= varIns DOLLAR PROGRAM_ITEMS 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("PROGRAM_ITEMS",35, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 12: // PROGRAM_ITEMS ::= varIns DOLLAR 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("PROGRAM_ITEMS",35, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 13: // PROGRAM_ITEMS ::= varInsAsigGl PROGRAM_ITEMS 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("PROGRAM_ITEMS",35, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 14: // PROGRAM_ITEMS ::= varInsAsigGl 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("PROGRAM_ITEMS",35, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 15: // PROGRAM_ITEMS ::= arrayInsAsignGl PROGRAM_ITEMS 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("PROGRAM_ITEMS",35, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 16: // PROGRAM_ITEMS ::= arrayInsAsignGl 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("PROGRAM_ITEMS",35, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 17: // PROGRAM_ITEMS ::= commentBlock PROGRAM_ITEMS 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("PROGRAM_ITEMS",35, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 18: // PROGRAM_ITEMS ::= commentBlock 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("PROGRAM_ITEMS",35, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 19: // PROGRAM_ITEMS ::= error PROGRAM_ITEMS 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("PROGRAM_ITEMS",35, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 20: // BLOCK ::= BLOCK exprP DOLLAR 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("BLOCK",4, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 21: // BLOCK ::= BLOCK varAsig 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("BLOCK",4, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 22: // BLOCK ::= BLOCK arrayInsGl DOLLAR 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("BLOCK",4, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 23: // BLOCK ::= BLOCK varInsGl DOLLAR 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("BLOCK",4, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 24: // BLOCK ::= BLOCK varInsAsigGl 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("BLOCK",4, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 25: // BLOCK ::= BLOCK arrayInsAsignGl 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("BLOCK",4, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 26: // BLOCK ::= BLOCK mainStruct 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("BLOCK",4, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 27: // BLOCK ::= BLOCK funcStruct 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("BLOCK",4, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 28: // BLOCK ::= BLOCK varIns DOLLAR 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("BLOCK",4, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 29: // BLOCK ::= BLOCK decideOfStruct 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("BLOCK",4, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 30: // BLOCK ::= BLOCK loopStruct 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("BLOCK",4, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 31: // BLOCK ::= BLOCK forStruct 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("BLOCK",4, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 32: // BLOCK ::= BLOCK arrayIns DOLLAR 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("BLOCK",4, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 33: // BLOCK ::= BLOCK varInsAsig 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("BLOCK",4, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 34: // BLOCK ::= BLOCK arrayInsAsign 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("BLOCK",4, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 35: // BLOCK ::= BLOCK inputStruct 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("BLOCK",4, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 36: // BLOCK ::= BLOCK outPutStruct DOLLAR 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("BLOCK",4, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 37: // BLOCK ::= BLOCK BREAK DOLLAR 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("BLOCK",4, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 38: // BLOCK ::= BLOCK RETURN exprP DOLLAR 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("BLOCK",4, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 39: // BLOCK ::= BLOCK RETURN DOLLAR 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("BLOCK",4, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 40: // BLOCK ::= BLOCK commentBlock 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("BLOCK",4, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 41: // BLOCK ::= exprP DOLLAR 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("BLOCK",4, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 42: // BLOCK ::= arrayIns DOLLAR 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("BLOCK",4, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 43: // BLOCK ::= arrayInsAsign 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("BLOCK",4, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 44: // BLOCK ::= mainStruct 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("BLOCK",4, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 45: // BLOCK ::= funcStruct 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("BLOCK",4, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 46: // BLOCK ::= varAsig 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("BLOCK",4, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 47: // BLOCK ::= arrayInsGl DOLLAR 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("BLOCK",4, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 48: // BLOCK ::= varInsGl DOLLAR 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("BLOCK",4, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 49: // BLOCK ::= varInsAsigGl 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("BLOCK",4, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 50: // BLOCK ::= arrayInsAsignGl 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("BLOCK",4, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 51: // BLOCK ::= varInsAsig 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("BLOCK",4, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 52: // BLOCK ::= varIns DOLLAR 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("BLOCK",4, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 53: // BLOCK ::= decideOfStruct 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("BLOCK",4, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 54: // BLOCK ::= forStruct 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("BLOCK",4, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 55: // BLOCK ::= loopStruct 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("BLOCK",4, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 56: // BLOCK ::= outPutStruct DOLLAR 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("BLOCK",4, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 57: // BLOCK ::= BREAK DOLLAR 
            {
              Object RESULT =null;
		int brkleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int brkright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Object brk = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		 Symbol brkSym = tokenFrom(brk, brkleft, brkright, sym.BREAK); if (loopEndStack.isEmpty()) { reportSemanticError("'break' fuera de ciclo", brkSym); } else { emit("goto " + loopEndStack.peek()); } 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("BLOCK",4, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 58: // BLOCK ::= RETURN exprP DOLLAR 
            {
              Object RESULT =null;
		int retTokleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int retTokright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		Object retTok = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int expleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int expright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Object exp = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		 Symbol retSym = tokenFrom(retTok, retTokleft, retTokright, sym.RETURN); recordReturn((ExprAttr)exp, retSym, true); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("BLOCK",4, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 59: // BLOCK ::= RETURN DOLLAR 
            {
              Object RESULT =null;
		int retTokleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int retTokright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Object retTok = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		 Symbol retSym = tokenFrom(retTok, retTokleft, retTokright, sym.RETURN); recordReturn(null, retSym, false); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("BLOCK",4, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 60: // BLOCK ::= inputStruct 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("BLOCK",4, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 61: // BLOCK ::= commentBlock 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("BLOCK",4, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 62: // BLOCK ::= error 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("BLOCK",4, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 63: // commentBlock ::= INIT_COMMENT commentBody END_COMMENT 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("commentBlock",49, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 64: // commentBlock ::= INIT_COMMENT END_COMMENT 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("commentBlock",49, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 65: // commentBody ::= commentBody COMMENT 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("commentBody",50, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 66: // commentBody ::= COMMENT 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("commentBody",50, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 67: // numbers ::= INT_LITERAL 
            {
              Object RESULT =null;
		int litleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int litright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object lit = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 Symbol litSym = tokenFrom(lit, litleft, litright, sym.INT_LITERAL); RESULT = literalAttr(litSym, "0", "INT"); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("numbers",18, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 68: // numbers ::= FLOAT 
            {
              Object RESULT =null;
		int litleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int litright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object lit = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 Symbol litSym = tokenFrom(lit, litleft, litright, sym.FLOAT); RESULT = literalAttr(litSym, "0.0", "FLOAT"); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("numbers",18, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 69: // compAritOp ::= term 
            {
              Object RESULT =null;
		int tleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int tright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object t = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 RESULT = t; 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("compAritOp",5, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 70: // compAritOp ::= compAritOp MAS term 
            {
              Object RESULT =null;
		int lleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int lright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		Object l = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int opleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int opright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Object op = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int rleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int rright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object r = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 Symbol opSym = tokenFrom(op, opleft, opright, sym.MAS); RESULT = numericBinary("+", (ExprAttr)l, (ExprAttr)r, opSym); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("compAritOp",5, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 71: // compAritOp ::= compAritOp MENOS term 
            {
              Object RESULT =null;
		int lleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int lright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		Object l = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int opleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int opright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Object op = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int rleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int rright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object r = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 Symbol opSym = tokenFrom(op, opleft, opright, sym.MENOS); RESULT = numericBinary("-", (ExprAttr)l, (ExprAttr)r, opSym); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("compAritOp",5, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 72: // term ::= factor 
            {
              Object RESULT =null;
		int fleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int fright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object f = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 RESULT = f; 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("term",7, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 73: // term ::= term MULTI factor 
            {
              Object RESULT =null;
		int lleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int lright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		Object l = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int opleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int opright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Object op = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int rleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int rright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object r = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 Symbol opSym = tokenFrom(op, opleft, opright, sym.MULTI); RESULT = numericBinary("*", (ExprAttr)l, (ExprAttr)r, opSym); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("term",7, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 74: // term ::= term DIV factor 
            {
              Object RESULT =null;
		int lleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int lright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		Object l = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int opleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int opright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Object op = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int rleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int rright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object r = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 Symbol opSym = tokenFrom(op, opleft, opright, sym.DIV); RESULT = numericBinary("/", (ExprAttr)l, (ExprAttr)r, opSym); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("term",7, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 75: // term ::= term POTENCIA factor 
            {
              Object RESULT =null;
		int lleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int lright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		Object l = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int opleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int opright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Object op = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int rleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int rright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object r = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 Symbol opSym = tokenFrom(op, opleft, opright, sym.POTENCIA); RESULT = numericBinary("^", (ExprAttr)l, (ExprAttr)r, opSym); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("term",7, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 76: // term ::= term FLOAT_DIV factor 
            {
              Object RESULT =null;
		int lleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int lright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		Object l = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int opleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int opright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Object op = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int rleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int rright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object r = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 Symbol opSym = tokenFrom(op, opleft, opright, sym.FLOAT_DIV); RESULT = numericBinary("%", (ExprAttr)l, (ExprAttr)r, opSym); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("term",7, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 77: // factor ::= numbers 
            {
              Object RESULT =null;
		int nleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int nright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object n = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 RESULT = n; 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("factor",6, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 78: // factor ::= MENOS numbers 
            {
              Object RESULT =null;
		int opleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int opright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Object op = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int nleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int nright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object n = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 Symbol opSym = tokenFrom(op, opleft, opright, sym.MENOS); RESULT = numericUnary("-", (ExprAttr)n, opSym); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("factor",6, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 79: // factor ::= STRING_LITERAL 
            {
              Object RESULT =null;
		int litleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int litright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object lit = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 Symbol litSym = tokenFrom(lit, litleft, litright, sym.STRING_LITERAL); RESULT = literalAttr(litSym, "\"\"", "STRING"); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("factor",6, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 80: // factor ::= CHARSTR 
            {
              Object RESULT =null;
		int chleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int chright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object ch = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 Symbol chSym = tokenFrom(ch, chleft, chright, sym.CHARSTR); RESULT = literalAttr(chSym, "'?'", "CHAR"); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("factor",6, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 81: // factor ::= IDENTIFIER 
            {
              Object RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int idright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object id = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 Symbol idSym = tokenFrom(id, idleft, idright, sym.IDENTIFIER); RESULT = identifierExpr(lexeme(id), idSym); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("factor",6, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 82: // factor ::= IDENTIFIER DMENOS 
            {
              Object RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Object id = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int opleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int opright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object op = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 
                    Symbol idSym = tokenFrom(id, idleft, idright, sym.IDENTIFIER);
                    Symbol opSym = tokenFrom(op, opleft, opright, sym.DMENOS);
                    ExprAttr base = identifierExpr(lexeme(id), idSym);
                    String step = "FLOAT".equals(base.type) ? "1.0" : "1";
                    ExprAttr result = numericBinary("-", base, literalAttr(null, step, base.type), opSym);
                    emit(lexeme(id) + " = " + result.place);
                    RESULT = result;
                
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("factor",6, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 83: // factor ::= IDENTIFIER DMAS 
            {
              Object RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Object id = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int opleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int opright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object op = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 
                    Symbol idSym = tokenFrom(id, idleft, idright, sym.IDENTIFIER);
                    Symbol opSym = tokenFrom(op, opleft, opright, sym.DMAS);
                    ExprAttr base = identifierExpr(lexeme(id), idSym);
                    String step = "FLOAT".equals(base.type) ? "1.0" : "1";
                    ExprAttr result = numericBinary("+", base, literalAttr(null, step, base.type), opSym);
                    emit(lexeme(id) + " = " + result.place);
                    RESULT = result;
                
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("factor",6, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 84: // factor ::= IDENTIFIER UKRA argListOpt RUSS 
            {
              Object RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).right;
		Object id = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-3)).value;
		int argsleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int argsright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Object args = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		 Symbol idSym = tokenFrom(id, idleft, idright, sym.IDENTIFIER); RESULT = invokeFunction(lexeme(id), (ArrayList)args, idSym); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("factor",6, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 85: // factor ::= arrayElement 
            {
              Object RESULT =null;
		int arrleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int arrright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object arr = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 RESULT = arr; 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("factor",6, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 86: // factor ::= MENOS UKRA exprP RUSS 
            {
              Object RESULT =null;
		int opleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).left;
		int opright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).right;
		Object op = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-3)).value;
		int eleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int eright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Object e = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		 Symbol opSym = tokenFrom(op, opleft, opright, sym.MENOS); RESULT = numericUnary("-", (ExprAttr)e, opSym); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("factor",6, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 87: // factor ::= UKRA exprP RUSS 
            {
              Object RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int eright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Object e = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		 RESULT = e; 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("factor",6, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 88: // factor ::= TRUE 
            {
              Object RESULT =null;
		 RESULT = new ExprAttr("true", "BOOL", true); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("factor",6, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 89: // factor ::= FALSE 
            {
              Object RESULT =null;
		 RESULT = new ExprAttr("false", "BOOL", true); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("factor",6, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 90: // inputStruct ::= INPUT UKRA IDENTIFIER RUSS DOLLAR 
            {
              Object RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		Object id = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		 
                    Symbol idSym = tokenFrom(id, idleft, idright, sym.IDENTIFIER);
                    String name = lexeme(id);
                    SymbolInfo info = lookupSymbol(name);
                    if (info == null) {
                        reportSemanticError("Variable '" + name + "' no declarada", idSym);
                    } else if (info.isArray) {
                        reportSemanticError("No se puede leer directamente un arreglo", idSym);
                    } else {
                        emit("read " + name);
                    }
                
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("inputStruct",26, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-4)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 91: // exprP ::= exprLog 
            {
              Object RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int eright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object e = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 RESULT = e; 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("exprP",29, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 92: // exprLog ::= exprLog AND exprRel 
            {
              Object RESULT =null;
		int lleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int lright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		Object l = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int opleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int opright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Object op = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int rleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int rright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object r = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 Symbol opSym = tokenFrom(op, opleft, opright, sym.AND); RESULT = logicalBinary("&&", (ExprAttr)l, (ExprAttr)r, opSym); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("exprLog",30, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 93: // exprLog ::= exprLog OR exprRel 
            {
              Object RESULT =null;
		int lleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int lright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		Object l = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int opleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int opright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Object op = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int rleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int rright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object r = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 Symbol opSym = tokenFrom(op, opleft, opright, sym.OR); RESULT = logicalBinary("||", (ExprAttr)l, (ExprAttr)r, opSym); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("exprLog",30, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 94: // exprLog ::= exprRel 
            {
              Object RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int eright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object e = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 RESULT = e; 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("exprLog",30, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 95: // exprRel ::= compAritOp GREATHER compAritOp 
            {
              Object RESULT =null;
		int lleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int lright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		Object l = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int opleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int opright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Object op = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int rleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int rright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object r = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 Symbol opSym = tokenFrom(op, opleft, opright, sym.GREATHER); RESULT = compareBinary(">", (ExprAttr)l, (ExprAttr)r, opSym); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("exprRel",31, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 96: // exprRel ::= compAritOp LESS compAritOp 
            {
              Object RESULT =null;
		int lleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int lright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		Object l = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int opleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int opright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Object op = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int rleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int rright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object r = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 Symbol opSym = tokenFrom(op, opleft, opright, sym.LESS); RESULT = compareBinary("<", (ExprAttr)l, (ExprAttr)r, opSym); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("exprRel",31, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 97: // exprRel ::= compAritOp MORE compAritOp 
            {
              Object RESULT =null;
		int lleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int lright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		Object l = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int opleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int opright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Object op = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int rleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int rright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object r = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 Symbol opSym = tokenFrom(op, opleft, opright, sym.MORE); RESULT = compareBinary(">=", (ExprAttr)l, (ExprAttr)r, opSym); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("exprRel",31, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 98: // exprRel ::= compAritOp LOWER compAritOp 
            {
              Object RESULT =null;
		int lleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int lright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		Object l = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int opleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int opright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Object op = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int rleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int rright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object r = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 Symbol opSym = tokenFrom(op, opleft, opright, sym.LOWER); RESULT = compareBinary("<=", (ExprAttr)l, (ExprAttr)r, opSym); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("exprRel",31, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 99: // exprRel ::= compAritOp DIFF compAritOp 
            {
              Object RESULT =null;
		int lleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int lright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		Object l = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int opleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int opright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Object op = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int rleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int rright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object r = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 Symbol opSym = tokenFrom(op, opleft, opright, sym.DIFF); RESULT = compareBinary("!=", (ExprAttr)l, (ExprAttr)r, opSym); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("exprRel",31, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 100: // exprRel ::= compAritOp COMPARA compAritOp 
            {
              Object RESULT =null;
		int lleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int lright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		Object l = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int opleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int opright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Object op = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int rleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int rright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object r = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 Symbol opSym = tokenFrom(op, opleft, opright, sym.COMPARA); RESULT = compareBinary("==", (ExprAttr)l, (ExprAttr)r, opSym); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("exprRel",31, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 101: // exprRel ::= NEGA exprRel 
            {
              Object RESULT =null;
		int opleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int opright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Object op = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int eleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int eright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object e = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 Symbol opSym = tokenFrom(op, opleft, opright, sym.NEGA); RESULT = logicalUnary("!", (ExprAttr)e, opSym); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("exprRel",31, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 102: // exprRel ::= compAritOp 
            {
              Object RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int eright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object e = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 RESULT = e; 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("exprRel",31, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 103: // varAsig ::= IDENTIFIER EQ exprP DOLLAR 
            {
              Object RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).right;
		Object id = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-3)).value;
		int eqleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int eqright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		Object eq = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int expleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int expright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Object exp = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		
                    Symbol idSym = tokenFrom(id, idleft, idright, sym.IDENTIFIER);
                    Symbol eqSym = tokenFrom(eq, eqleft, eqright, sym.EQ);
                    String name = lexeme(id);
                    SymbolInfo target = lookupSymbol(name);
                    if (target == null) {
                        reportSemanticError("Variable '" + name + "' no declarada", idSym);
                    } else if (target.isArray) {
                        reportSemanticError("No se puede asignar a un arreglo completo sin indice", idSym);
                    } else {
                        recordAssignment(target, (ExprAttr)exp, eqSym);
                    }
                
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("varAsig",3, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 104: // varAsig ::= arrayElement EQ exprP DOLLAR 
            {
              Object RESULT =null;
		int elemleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).left;
		int elemright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).right;
		Object elem = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-3)).value;
		int eqleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int eqright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		Object eq = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int expleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int expright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Object exp = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		
                    Symbol eqSym = tokenFrom(eq, eqleft, eqright, sym.EQ);
                    ExprAttr lhs = (ExprAttr)elem;
                    ExprAttr rhs = (ExprAttr)exp;
                    emitArrayStore(lhs, rhs, eqSym);
                
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("varAsig",3, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 105: // varAsig ::= EQ exprP DOLLAR 
            {
              Object RESULT =null;
		int eqleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int eqright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		Object eq = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		 Symbol eqSym = tokenFrom(eq, eqleft, eqright, sym.EQ); reportSemanticError("Asignacion sin destino", eqSym); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("varAsig",3, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 106: // varIns ::= LET INT IDENTIFIER 
            {
              Object RESULT =null;
		int IDleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int IDright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object ID = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 Symbol idSym = tokenFrom(ID, IDleft, IDright, sym.IDENTIFIER); String name = lexeme(ID); SymbolInfo info = declareSymbol(currentHash, name, "INT", false, 0, false, false, idSym); if (info != null) emit("declare " + name + ":INT"); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("varIns",2, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 107: // varIns ::= LET CHAR IDENTIFIER 
            {
              Object RESULT =null;
		int IDleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int IDright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object ID = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 Symbol idSym = tokenFrom(ID, IDleft, IDright, sym.IDENTIFIER); String name = lexeme(ID); SymbolInfo info = declareSymbol(currentHash, name, "CHAR", false, 0, false, false, idSym); if (info != null) emit("declare " + name + ":CHAR"); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("varIns",2, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 108: // varIns ::= LET FLOAT IDENTIFIER 
            {
              Object RESULT =null;
		int IDleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int IDright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object ID = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 Symbol idSym = tokenFrom(ID, IDleft, IDright, sym.IDENTIFIER); String name = lexeme(ID); SymbolInfo info = declareSymbol(currentHash, name, "FLOAT", false, 0, false, false, idSym); if (info != null) emit("declare " + name + ":FLOAT"); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("varIns",2, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 109: // varIns ::= LET BOOL IDENTIFIER 
            {
              Object RESULT =null;
		int IDleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int IDright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object ID = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 Symbol idSym = tokenFrom(ID, IDleft, IDright, sym.IDENTIFIER); String name = lexeme(ID); SymbolInfo info = declareSymbol(currentHash, name, "BOOL", false, 0, false, false, idSym); if (info != null) emit("declare " + name + ":BOOL"); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("varIns",2, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 110: // varIns ::= LET STRING IDENTIFIER 
            {
              Object RESULT =null;
		int IDleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int IDright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object ID = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 Symbol idSym = tokenFrom(ID, IDleft, IDright, sym.IDENTIFIER); String name = lexeme(ID); SymbolInfo info = declareSymbol(currentHash, name, "STRING", false, 0, false, false, idSym); if (info != null) emit("declare " + name + ":STRING"); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("varIns",2, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 111: // varInsGl ::= GLOBAL LET INT IDENTIFIER 
            {
              Object RESULT =null;
		int IDleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int IDright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object ID = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 Symbol idSym = tokenFrom(ID, IDleft, IDright, sym.IDENTIFIER); String name = lexeme(ID); SymbolInfo info = declareSymbol(globalHash, name, "INT", false, 0, false, true, idSym); if (info != null) emit("declare_global " + name + ":INT"); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("varInsGl",37, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 112: // varInsGl ::= GLOBAL LET CHAR IDENTIFIER 
            {
              Object RESULT =null;
		int IDleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int IDright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object ID = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 Symbol idSym = tokenFrom(ID, IDleft, IDright, sym.IDENTIFIER); String name = lexeme(ID); SymbolInfo info = declareSymbol(globalHash, name, "CHAR", false, 0, false, true, idSym); if (info != null) emit("declare_global " + name + ":CHAR"); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("varInsGl",37, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 113: // varInsGl ::= GLOBAL LET FLOAT IDENTIFIER 
            {
              Object RESULT =null;
		int IDleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int IDright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object ID = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 Symbol idSym = tokenFrom(ID, IDleft, IDright, sym.IDENTIFIER); String name = lexeme(ID); SymbolInfo info = declareSymbol(globalHash, name, "FLOAT", false, 0, false, true, idSym); if (info != null) emit("declare_global " + name + ":FLOAT"); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("varInsGl",37, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 114: // varInsGl ::= GLOBAL LET STRING IDENTIFIER 
            {
              Object RESULT =null;
		int IDleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int IDright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object ID = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 Symbol idSym = tokenFrom(ID, IDleft, IDright, sym.IDENTIFIER); String name = lexeme(ID); SymbolInfo info = declareSymbol(globalHash, name, "STRING", false, 0, false, true, idSym); if (info != null) emit("declare_global " + name + ":STRING"); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("varInsGl",37, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 115: // varInsGl ::= GLOBAL LET BOOL IDENTIFIER 
            {
              Object RESULT =null;
		int IDleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int IDright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object ID = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 Symbol idSym = tokenFrom(ID, IDleft, IDright, sym.IDENTIFIER); String name = lexeme(ID); SymbolInfo info = declareSymbol(globalHash, name, "BOOL", false, 0, false, true, idSym); if (info != null) emit("declare_global " + name + ":BOOL"); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("varInsGl",37, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 116: // varInsAsig ::= varIns varAsig 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("varInsAsig",38, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 117: // varInsAsigGl ::= varInsGl varAsig 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("varInsAsigGl",39, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 118: // funInitial ::= INT IDENTIFIER 
            {
              Object RESULT =null;
		int IDleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int IDright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object ID = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		   Symbol idSym = tokenFrom(ID, IDleft, IDright, sym.IDENTIFIER); String name = lexeme(ID); startFunctionScope(name, "INT", idSym); emit("begin_func " + name); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("funInitial",28, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 119: // funInitial ::= CHAR IDENTIFIER 
            {
              Object RESULT =null;
		int IDleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int IDright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object ID = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		   Symbol idSym = tokenFrom(ID, IDleft, IDright, sym.IDENTIFIER); String name = lexeme(ID); startFunctionScope(name, "CHAR", idSym); emit("begin_func " + name); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("funInitial",28, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 120: // funInitial ::= BOOL IDENTIFIER 
            {
              Object RESULT =null;
		int IDleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int IDright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object ID = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		   Symbol idSym = tokenFrom(ID, IDleft, IDright, sym.IDENTIFIER); String name = lexeme(ID); startFunctionScope(name, "BOOL", idSym); emit("begin_func " + name); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("funInitial",28, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 121: // funInitial ::= STRING IDENTIFIER 
            {
              Object RESULT =null;
		int IDleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int IDright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object ID = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		   Symbol idSym = tokenFrom(ID, IDleft, IDright, sym.IDENTIFIER); String name = lexeme(ID); startFunctionScope(name, "STRING", idSym); emit("begin_func " + name); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("funInitial",28, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 122: // funInitial ::= FLOAT IDENTIFIER 
            {
              Object RESULT =null;
		int IDleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int IDright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object ID = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		   Symbol idSym = tokenFrom(ID, IDleft, IDright, sym.IDENTIFIER); String name = lexeme(ID); startFunctionScope(name, "FLOAT", idSym); emit("begin_func " + name); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("funInitial",28, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 123: // funcStruct ::= funInitial paramSection blockStart BLOCK END_BLOCK 
            {
              Object RESULT =null;
		 String finished = currentHash; emit("end_func " + (finished != null ? finished : "?")); FunctionInfo info = finished != null ? functionTable.get(finished) : null; if (info != null && !info.hasReturn) { reportSemanticError("La funcion '" + finished + "' no retorna", null); } closeCurrentScope(); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("funcStruct",8, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-4)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 124: // paramSection ::= UKRA paramDeclList paramSectionClose 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("paramSection",41, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 125: // paramSection ::= UKRA paramSectionClose 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("paramSection",41, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 126: // paramSection ::= 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("paramSection",41, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 127: // paramSectionClose ::= RUSS 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("paramSectionClose",42, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 128: // paramSectionClose ::= 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("paramSectionClose",42, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 129: // paramDeclList ::= paramDecl 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("paramDeclList",43, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 130: // paramDeclList ::= paramDecl COMA paramDeclList 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("paramDeclList",43, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 131: // paramDecl ::= INT IDENTIFIER 
            {
              Object RESULT =null;
		int IDleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int IDright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object ID = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 registrarParametroEnScope(lexeme(ID), "INT", IDleft, IDright); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("paramDecl",44, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 132: // paramDecl ::= CHAR IDENTIFIER 
            {
              Object RESULT =null;
		int IDleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int IDright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object ID = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 registrarParametroEnScope(lexeme(ID), "CHAR", IDleft, IDright); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("paramDecl",44, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 133: // paramDecl ::= FLOAT IDENTIFIER 
            {
              Object RESULT =null;
		int IDleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int IDright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object ID = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 registrarParametroEnScope(lexeme(ID), "FLOAT", IDleft, IDright); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("paramDecl",44, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 134: // paramDecl ::= BOOL IDENTIFIER 
            {
              Object RESULT =null;
		int IDleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int IDright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object ID = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 registrarParametroEnScope(lexeme(ID), "BOOL", IDleft, IDright); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("paramDecl",44, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 135: // paramDecl ::= STRING IDENTIFIER 
            {
              Object RESULT =null;
		int IDleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int IDright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object ID = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 registrarParametroEnScope(lexeme(ID), "STRING", IDleft, IDright); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("paramDecl",44, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 136: // blockStart ::= INIT_BLOCK blockStartClose 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("blockStart",11, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 137: // blockStartClose ::= RUSS 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("blockStartClose",12, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 138: // blockStartClose ::= 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("blockStartClose",12, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 139: // argListOpt ::= argList 
            {
              Object RESULT =null;
		int lleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int lright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object l = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 RESULT = l; 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("argListOpt",45, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 140: // argListOpt ::= 
            {
              Object RESULT =null;
		 RESULT = new ArrayList(); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("argListOpt",45, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 141: // argList ::= exprP 
            {
              Object RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int eright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object e = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 ArrayList tmp = new ArrayList(); tmp.add((ExprAttr)e); RESULT = tmp; 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("argList",46, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 142: // argList ::= exprP COMA argList 
            {
              Object RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int eright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		Object e = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int restleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int restright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object rest = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 ArrayList tmp = new ArrayList(); tmp.add((ExprAttr)e); tmp.addAll((ArrayList)rest); RESULT = tmp; 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("argList",46, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 143: // mainStruct ::= mainInitial paramSection blockStart BLOCK END_BLOCK 
            {
              Object RESULT =null;
		 emit("end_main"); closeCurrentScope(); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("mainStruct",9, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-4)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 144: // mainInitial ::= PRINCIPAL 
            {
              Object RESULT =null;
		int KWleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int KWright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object KW = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 Symbol kwSym = tokenFrom(KW, KWleft, KWright, sym.PRINCIPAL);
                                                     startFunctionScope("MAIN", "INT", kwSym);
                                                     emit("begin_main");
                                                 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("mainInitial",27, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 145: // NT$1 ::= 
            {
              Object RESULT =null;
 beginDecideStructure(); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("NT$1",52, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 146: // decideOfStruct ::= DECIDE OF NT$1 decideClauseList END DECIDE DOLLAR 
            {
              Object RESULT =null;
              // propagate RESULT from NT$1
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-4)).value;
		 endDecideStructure(); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("decideOfStruct",21, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-6)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 147: // decideClauseList ::= decideClauseList decideClause 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("decideClauseList",19, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 148: // decideClauseList ::= decideClause 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("decideClauseList",19, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 149: // NT$2 ::= 
            {
              Object RESULT =null;
		int condleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int condright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		Object cond = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
 beginDecideCase((ExprAttr)cond, null); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("NT$2",53, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 150: // decideClause ::= caseCondition ARROW INIT_BLOCK NT$2 BLOCK END_BLOCK 
            {
              Object RESULT =null;
              // propagate RESULT from NT$2
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int condleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-5)).left;
		int condright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-5)).right;
		Object cond = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-5)).value;
		 endDecideCase(); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("decideClause",20, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-5)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 151: // NT$3 ::= 
            {
              Object RESULT =null;
 beginDecideElse(); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("NT$3",54, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 152: // decideClause ::= ELSE ARROW INIT_BLOCK NT$3 BLOCK END_BLOCK 
            {
              Object RESULT =null;
              // propagate RESULT from NT$3
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		 endDecideElse(); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("decideClause",20, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-5)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 153: // caseCondition ::= exprP 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("caseCondition",25, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 154: // NT$4 ::= 
            {
              Object RESULT =null;
 beginLoopStructure(); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("NT$4",55, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 155: // NT$5 ::= 
            {
              Object RESULT =(Object) ((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-8)).value;
		int exitTokleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-6)).left;
		int exitTokright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-6)).right;
		Object exitTok = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-6)).value;
		int exitCondleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-4)).left;
		int exitCondright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-4)).right;
		Object exitCond = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-4)).value;
 Symbol exitSym = tokenFrom(exitTok, exitTokleft, exitTokright, sym.EXIT); finalizeLoopBody((ExprAttr)exitCond, exitSym); endLoopStructure(); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("NT$5",56, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 156: // loopStruct ::= LOOP NT$4 loopBody EXIT WHEN exprP DOLLAR END LOOP DOLLAR NT$5 loopElseOpt 
            {
              Object RESULT =null;
              // propagate RESULT from NT$5
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int exitTokleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-8)).left;
		int exitTokright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-8)).right;
		Object exitTok = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-8)).value;
		int exitCondleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-6)).left;
		int exitCondright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-6)).right;
		Object exitCond = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-6)).value;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("loopStruct",22, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-11)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 157: // loopBody ::= exprP 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("loopBody",13, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 158: // loopBody ::= BLOCK 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("loopBody",13, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 159: // loopElseOpt ::= ELSE ARROW INIT_BLOCK BLOCK END_BLOCK 
            {
              Object RESULT =null;
		 emit("// loop else branch"); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("loopElseOpt",23, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-4)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 160: // loopElseOpt ::= 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("loopElseOpt",23, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 161: // NT$6 ::= 
            {
              Object RESULT =null;
		int initleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-5)).left;
		int initright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-5)).right;
		Object init = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-5)).value;
		int stepleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).left;
		int stepright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).right;
		Object step = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-3)).value;
		int limitleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int limitright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Object limit = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
 beginForLoop((ExprAttr)init, (ExprAttr)step, (ExprAttr)limit, false); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("NT$6",57, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 162: // forStruct ::= FOR forInit STEP stepValue TO exprP DO NT$6 blockStart BLOCK END_BLOCK 
            {
              Object RESULT =null;
              // propagate RESULT from NT$6
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-3)).value;
		int initleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-9)).left;
		int initright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-9)).right;
		Object init = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-9)).value;
		int stepleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-7)).left;
		int stepright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-7)).right;
		Object step = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-7)).value;
		int limitleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-5)).left;
		int limitright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-5)).right;
		Object limit = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-5)).value;
		 endForLoop(); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("forStruct",24, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-10)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 163: // NT$7 ::= 
            {
              Object RESULT =null;
		int initleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-5)).left;
		int initright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-5)).right;
		Object init = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-5)).value;
		int stepleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).left;
		int stepright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).right;
		Object step = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-3)).value;
		int limitleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int limitright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Object limit = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
 beginForLoop((ExprAttr)init, (ExprAttr)step, (ExprAttr)limit, true); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("NT$7",58, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 164: // forStruct ::= FOR forInit STEP stepValue DOWNTO exprP DO NT$7 blockStart BLOCK END_BLOCK 
            {
              Object RESULT =null;
              // propagate RESULT from NT$7
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-3)).value;
		int initleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-9)).left;
		int initright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-9)).right;
		Object init = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-9)).value;
		int stepleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-7)).left;
		int stepright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-7)).right;
		Object step = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-7)).value;
		int limitleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-5)).left;
		int limitright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-5)).right;
		Object limit = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-5)).value;
		 endForLoop(); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("forStruct",24, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-10)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 165: // forInit ::= IDENTIFIER EQ exprP 
            {
              Object RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		Object id = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int eqleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int eqright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Object eq = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int expleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int expright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object exp = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
              Symbol idSym = tokenFrom(id, idleft, idright, sym.IDENTIFIER);
              Symbol eqSym = tokenFrom(eq, eqleft, eqright, sym.EQ);
              String name = lexeme(id);
              SymbolInfo info = lookupSymbol(name);
              ExprAttr rhs = (ExprAttr)exp;
              if (info == null) {
                  reportSemanticError("Variable '" + name + "' no declarada", idSym);
                  RESULT = ExprAttr.invalid();
              } else {
                  recordAssignment(info, rhs, eqSym);
                  RESULT = new ExprAttr(info.name, info.type, false);
              }
          
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("forInit",47, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 166: // forInit ::= arrayElement EQ exprP 
            {
              Object RESULT =null;
		int elemleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int elemright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		Object elem = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int eqleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int eqright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Object eq = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int expleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int expright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object exp = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
              Symbol eqSym = tokenFrom(eq, eqleft, eqright, sym.EQ);
              reportSemanticError("Los ciclos FOR requieren una variable ESCALAR como control", eqSym);
              RESULT = ExprAttr.invalid();
          
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("forInit",47, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 167: // stepValue ::= exprP 
            {
              Object RESULT =null;
		int expleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int expright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object exp = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 RESULT = ensureNumeric((ExprAttr)exp, null, "step value"); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("stepValue",48, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 168: // arrayIns ::= INT ARRAY IDENTIFIER SQUARES INT_LITERAL SQUAREC 
            {
              Object RESULT =null;
		int IDleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).left;
		int IDright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).right;
		Object ID = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-3)).value;
		int SZleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int SZright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Object SZ = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		 Symbol idSym = tokenFrom(ID, IDleft, IDright, sym.IDENTIFIER); Symbol szSym = tokenFrom(SZ, SZleft, SZright, sym.INT_LITERAL); String name = lexeme(ID); int len = Math.max(0, literalToInt(szSym)); SymbolInfo info = declareSymbol(currentHash, name, "INT", true, len, false, false, idSym); if (info != null) { emit("declare_arr " + name + "[" + len + "] INT"); if (len > 0) emit("arr_pad_zero " + name + ", 0, " + len); } 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("arrayIns",14, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-5)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 169: // arrayIns ::= CHAR ARRAY IDENTIFIER SQUARES INT_LITERAL SQUAREC 
            {
              Object RESULT =null;
		int IDleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).left;
		int IDright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).right;
		Object ID = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-3)).value;
		int SZleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int SZright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Object SZ = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		 Symbol idSym = tokenFrom(ID, IDleft, IDright, sym.IDENTIFIER); Symbol szSym = tokenFrom(SZ, SZleft, SZright, sym.INT_LITERAL); String name = lexeme(ID); int len = Math.max(0, literalToInt(szSym)); SymbolInfo info = declareSymbol(currentHash, name, "CHAR", true, len, false, false, idSym); if (info != null) { emit("declare_arr " + name + "[" + len + "] CHAR"); if (len > 0) emit("arr_pad_zero " + name + ", 0, " + len); } 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("arrayIns",14, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-5)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 170: // arrayInsGl ::= GLOBAL INT ARRAY IDENTIFIER SQUARES INT_LITERAL SQUAREC 
            {
              Object RESULT =null;
		int IDleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).left;
		int IDright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).right;
		Object ID = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-3)).value;
		int SZleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int SZright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Object SZ = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		 Symbol idSym = tokenFrom(ID, IDleft, IDright, sym.IDENTIFIER); Symbol szSym = tokenFrom(SZ, SZleft, SZright, sym.INT_LITERAL); String name = lexeme(ID); int len = Math.max(0, literalToInt(szSym)); SymbolInfo info = declareSymbol(globalHash, name, "INT", true, len, false, true, idSym); if (info != null) { emit("declare_global_arr " + name + "[" + len + "] INT"); if (len > 0) emit("arr_pad_zero " + name + ", 0, " + len); } 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("arrayInsGl",36, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-6)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 171: // arrayInsGl ::= GLOBAL CHAR ARRAY IDENTIFIER SQUARES INT_LITERAL SQUAREC 
            {
              Object RESULT =null;
		int IDleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).left;
		int IDright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).right;
		Object ID = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-3)).value;
		int SZleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int SZright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Object SZ = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		 Symbol idSym = tokenFrom(ID, IDleft, IDright, sym.IDENTIFIER); Symbol szSym = tokenFrom(SZ, SZleft, SZright, sym.INT_LITERAL); String name = lexeme(ID); int len = Math.max(0, literalToInt(szSym)); SymbolInfo info = declareSymbol(globalHash, name, "CHAR", true, len, false, true, idSym); if (info != null) { emit("declare_global_arr " + name + "[" + len + "] CHAR"); if (len > 0) emit("arr_pad_zero " + name + ", 0, " + len); } 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("arrayInsGl",36, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-6)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 172: // arrayAsig ::= IDENTIFIER EQ SQUARES elementos SQUAREC DOLLAR 
            {
              Object RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-5)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-5)).right;
		Object id = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-5)).value;
		int eqleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-4)).left;
		int eqright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-4)).right;
		Object eq = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-4)).value;
		int valsleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int valsright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		Object vals = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		 
                    Symbol idSym = tokenFrom(id, idleft, idright, sym.IDENTIFIER);
                    Symbol eqSym = tokenFrom(eq, eqleft, eqright, sym.EQ);
                    String name = lexeme(id);
                    SymbolInfo info = lookupSymbol(name);
                    if (info == null) {
                        reportSemanticError("Arreglo '" + name + "' no declarado", idSym);
                    } else if (!info.isArray) {
                        reportSemanticError("'" + name + "' no es un arreglo", idSym);
                    } else {
                        ArrayList<ExprAttr> list = (ArrayList<ExprAttr>)vals;
                        ensureHomogeneousElements(list, eqSym);
                        if (list != null) {
                            if (info.arraySize > 0 && list.size() > info.arraySize) {
                                reportSemanticError("Demasiados elementos para '" + name + "'", eqSym);
                            }
                            for (int i = 0; i < list.size(); i++) {
                                if (info.arraySize > 0 && i >= info.arraySize) {
                                    break;
                                }
                                ExprAttr expr = list.get(i);
                                if (expr == null || !expr.isValid()) {
                                    reportSemanticError("Elemento invalido en inicializacion de '" + name + "'", eqSym);
                                    continue;
                                }
                                if (!info.type.equals(expr.type)) {
                                    reportSemanticError("Elemento no compatible para arreglo '" + name + "'", eqSym);
                                    continue;
                                }
                                emit("astore " + name + ", " + i + ", " + expr.place);
                            }
                            if (info.arraySize > 0 && list.size() < info.arraySize) {
                                emit("arr_pad_zero " + name + ", " + list.size() + ", " + info.arraySize);
                            }
                        } else if (info.arraySize > 0) {
                            emit("arr_pad_zero " + name + ", 0, " + info.arraySize);
                        }
                    }
                
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("arrayAsig",15, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-5)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 173: // arrayAsig ::= EQ SQUARES elementos SQUAREC DOLLAR 
            {
              Object RESULT =null;
		int eqleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-4)).left;
		int eqright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-4)).right;
		Object eq = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-4)).value;
		 Symbol eqSym = tokenFrom(eq, eqleft, eqright, sym.EQ); reportSemanticError("Se requiere identificador para asignar arreglo", eqSym); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("arrayAsig",15, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-4)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 174: // elementos ::= compAritOp COMA elementos 
            {
              Object RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int eright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		Object e = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int restleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int restright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object rest = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 ArrayList<ExprAttr> tmp = new ArrayList<>(); tmp.add((ExprAttr)e); tmp.addAll((ArrayList<ExprAttr>)rest); RESULT = tmp; 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("elementos",17, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 175: // elementos ::= compAritOp 
            {
              Object RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int eright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object e = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 ArrayList<ExprAttr> tmp = new ArrayList<>(); tmp.add((ExprAttr)e); RESULT = tmp; 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("elementos",17, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 176: // arrayInsAsign ::= arrayIns arrayAsig 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("arrayInsAsign",16, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 177: // arrayInsAsignGl ::= arrayInsGl arrayAsig 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("arrayInsAsignGl",40, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 178: // arrayElement ::= IDENTIFIER SQUARES compAritOp SQUAREC 
            {
              Object RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).right;
		Object id = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-3)).value;
		int exprleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int exprright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Object expr = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		 Symbol idSym = tokenFrom(id, idleft, idright, sym.IDENTIFIER); RESULT = arrayAccess(lexeme(id), (ExprAttr)expr, idSym, null); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("arrayElement",32, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 179: // paramStruct ::= PARAM INT IDENTIFIER 
            {
              Object RESULT =null;
		int IDleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int IDright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object ID = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 String lex = lexeme(ID); String target=(currentHash!=null?currentHash:globalHash); ensureScopeBucket(target); scopePrograma.get(target).add("Instancia PARAM: " + lex + ":" + "INT" + ":line=" + (IDleft+1) + ":col=" + (IDright+1)); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("paramStruct",33, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 180: // paramStruct ::= PARAM CHAR IDENTIFIER 
            {
              Object RESULT =null;
		int IDleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int IDright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object ID = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 String lex = lexeme(ID); String target=(currentHash!=null?currentHash:globalHash); ensureScopeBucket(target); scopePrograma.get(target).add("Instancia PARAM: " + lex + ":" + "CHAR" + ":line=" + (IDleft+1) + ":col=" + (IDright+1)); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("paramStruct",33, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 181: // paramStruct ::= PARAM STRING IDENTIFIER 
            {
              Object RESULT =null;
		int IDleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int IDright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object ID = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 String lex = lexeme(ID); String target=(currentHash!=null?currentHash:globalHash); ensureScopeBucket(target); scopePrograma.get(target).add("Instancia PARAM: " + lex + ":" + "STRING" + ":line=" + (IDleft+1) + ":col=" + (IDright+1)); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("paramStruct",33, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 182: // paramStruct ::= PARAM FLOAT IDENTIFIER 
            {
              Object RESULT =null;
		int IDleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int IDright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object ID = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 String lex = lexeme(ID); String target=(currentHash!=null?currentHash:globalHash); ensureScopeBucket(target); scopePrograma.get(target).add("Instancia PARAM: " + lex + ":" + "FLOAT" + ":line=" + (IDleft+1) + ":col=" + (IDright+1)); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("paramStruct",33, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 183: // paramStruct ::= PARAM BOOL IDENTIFIER 
            {
              Object RESULT =null;
		int IDleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int IDright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object ID = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 String lex = lexeme(ID); String target=(currentHash!=null?currentHash:globalHash); ensureScopeBucket(target); scopePrograma.get(target).add("Instancia PARAM: " + lex + ":" + "BOOL" + ":line=" + (IDleft+1) + ":col=" + (IDright+1)); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("paramStruct",33, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 184: // paramList ::= paramStruct paramList 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("paramList",34, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 185: // paramList ::= paramStruct 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("paramList",34, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 186: // outPutStruct ::= OUTPUT UKRA exprP RUSS 
            {
              Object RESULT =null;
		int expleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int expright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Object exp = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		 ExprAttr value = (ExprAttr)exp; if (value != null && value.isValid()) emit("print " + value.place); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("outPutStruct",10, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /* . . . . . .*/
          default:
            throw new Exception(
               "Invalid action number "+CUP$Parser$act_num+"found in internal parse table");

        }
    } /* end of method */

  /** Method splitting the generated action code into several parts. */
  public final java_cup.runtime.Symbol CUP$Parser$do_action(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack            CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
              return CUP$Parser$do_action_part00000000(
                               CUP$Parser$act_num,
                               CUP$Parser$parser,
                               CUP$Parser$stack,
                               CUP$Parser$top);
    }
}

}
