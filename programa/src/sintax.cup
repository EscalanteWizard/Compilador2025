import java_cup.runtime.*;
import java.util.HashMap; 
import java.util.LinkedHashMap;
import java.util.Map;
import java.util.Deque;
import java.util.ArrayDeque;
import java.util.List;
import java.util.ArrayList;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.regex.Pattern;
import java.util.regex.Matcher;

parser code {:
    Lexer lex;
    HashMap<String, ArrayList<String>> scopePrograma = new HashMap<>();
    HashMap<String, LinkedHashMap<String, SymbolInfo>> semanticScopes = new HashMap<>();
    HashMap<String, FunctionInfo> functionTable = new HashMap<>();
    ArrayDeque<String> decideEndStack = new ArrayDeque<>();
    ArrayDeque<String> decideNextStack = new ArrayDeque<>();
    ArrayDeque<String> loopStartStack = new ArrayDeque<>();
    ArrayDeque<String> loopEndStack = new ArrayDeque<>();
    ArrayList<String> semanticErrors = new ArrayList<>();
    StringBuilder cod3D = new StringBuilder();
    String currentHash;
    String globalHash = "SCOPE GLOBAL";
    int tempCounter = 0;
    int labelCounter = 0;
    boolean artifactsExported = false;
    boolean ciHeaderEmitted = false;

    static class SymbolInfo {
        final String name;
        final String type;
        final boolean isArray;
        final int arraySize;
        final boolean isParam;
        final boolean isGlobal;
        final int line;
        final int col;

        SymbolInfo(String name, String type, boolean isArray, int arraySize,
                   boolean isParam, boolean isGlobal, int line, int col) {
            this.name = name;
            this.type = type;
            this.isArray = isArray;
            this.arraySize = arraySize;
            this.isParam = isParam;
            this.isGlobal = isGlobal;
            this.line = line;
            this.col = col;
        }
    }

    static class FunctionInfo {
        final String name;
        final String returnType;
        final boolean returnsVoid;
        final ArrayList<SymbolInfo> params = new ArrayList<>();
        boolean hasReturn = false;
        boolean paramsMetadataEmitted = false;

        FunctionInfo(String name, String returnType) {
            this.name = name;
            this.returnType = returnType;
            this.returnsVoid = "VOID".equals(returnType);
        }
    }

    static class ComparisonLink {
        final String operator;
        final ExprAttr right;
        final Symbol token;

        ComparisonLink(String operator, ExprAttr right, Symbol token) {
            this.operator = operator;
            this.right = right;
            this.token = token;
        }
    }

    static class ExprAttr {
        final String place;
        final String type;
        final boolean constant;
        final String location;      // describe el l-value (por ejemplo arr[idx]) cuando aplica
        final SymbolInfo symbolInfo; // referencia al simbolo propietario (para arreglos)
        final String indexPlace;    // expresion que se usa para indexar arreglos

        ExprAttr(String place, String type, boolean constant) {
            this(place, type, constant, null, null, null);
        }

        ExprAttr(String place, String type, boolean constant, String location,
                 SymbolInfo symbolInfo, String indexPlace) {
            this.place = place;
            this.type = type;
            this.constant = constant;
            this.location = location;
            this.symbolInfo = symbolInfo;
            this.indexPlace = indexPlace;
        }

        static ExprAttr invalid() {
            return new ExprAttr("__err", "ERROR", true);
        }

        boolean isValid() {
            return place != null && type != null && !"ERROR".equals(type);
        }

        boolean isNumeric() {
            return "INT".equals(type) || "FLOAT".equals(type);
        }

        boolean isBoolean() {
            return "BOOL".equals(type);
        }

        boolean isArrayReference() {
            return location != null && symbolInfo != null && indexPlace != null;
        }
    }

    static class ForContext {
        final String target;
        final String type;
        final ExprAttr step;
        final ExprAttr limit;
        final boolean downto;
        final String condLabel;
        final String endLabel;

        ForContext(String target, String type, ExprAttr step, ExprAttr limit, boolean downto, String condLabel, String endLabel) {
            this.target = target;
            this.type = type;
            this.step = step;
            this.limit = limit;
            this.downto = downto;
            this.condLabel = condLabel;
            this.endLabel = endLabel;
        }
    }

    ArrayDeque<ForContext> forStack = new ArrayDeque<>();

    /**
     * Proposito: construir el parser e inicializar las estructuras de alcance.
     * Entradas: instancia de Lexer generada por JFlex que entrega los tokens.
     * Salidas: parser listo para usarse con fabrica de simbolos y alcance global cargado.
     * Restricciones: la referencia al lexer no debe ser nula.
     */
    @SuppressWarnings("deprecation")
    public Parser(Lexer lex) {
        this.lex = lex;
        this.symbolFactory = new DefaultSymbolFactory();
        initializeGlobalScope();
    }

    /**
     * Proposito: garantizar que el alcance global exista antes de cualquier declaracion.
     * Entradas: ninguna; usa los campos internos del parser.
     * Salidas: registros creados para globalHash dentro de scopePrograma y semanticScopes.
     * Restricciones: idealmente se ejecuta una sola vez en la inicializacion.
     */
    private void initializeGlobalScope() {
        if (!scopePrograma.containsKey(globalHash)) {
            scopePrograma.put(globalHash, new ArrayList<>());
        }
        if (!semanticScopes.containsKey(globalHash)) {
            semanticScopes.put(globalHash, new LinkedHashMap<>());
        }
    }

    /**
     * Proposito: crear bajo demanda los contenedores asociados a un alcance.
     * Entradas: nombre del alcance que se desea preparar.
     * Salidas: registros inicializados en scopePrograma y semanticScopes.
     * Restricciones: el nombre del alcance no debe ser null.
     */
    private void ensureScopeBucket(String scope) {
        if (!scopePrograma.containsKey(scope)) {
            scopePrograma.put(scope, new ArrayList<>());
        }
        if (!semanticScopes.containsKey(scope)) {
            semanticScopes.put(scope, new LinkedHashMap<>());
        }
    }

    /**
     * Proposito: convertir un simbolo CUP en linea 1-based para diagnosticos.
     * Entradas: simbolo sintactico proveniente de las acciones de la gramatica.
     * Salidas: numero de linea >=1 o -1 cuando no hay coordenadas.
     * Restricciones: depende del atributo left proporcionado por CUP.
     */
    private int toLine(Symbol sym) {
        return (sym == null || sym.left < 0) ? -1 : sym.left + 1;
    }

    /**
     * Proposito: obtener la posicion de columna (1-based) de un simbolo CUP.
     * Entradas: simbolo a inspeccionar.
     * Salidas: numero de columna >=1 o -1 si no existe informacion.
     * Restricciones: usa el atributo right calculado por CUP.
     */
    private int toColumn(Symbol sym) {
        return (sym == null || sym.right < 0) ? -1 : sym.right + 1;
    }

    /**
     * Proposito: formatear una cadena legible con la posicion del simbolo.
     * Entradas: simbolo que contiene metadatos de linea/columna.
     * Salidas: texto " (linea X, columna Y)" o cadena vacia si faltan datos.
     * Restricciones: solo tiene sentido cuando el simbolo tiene coordenadas.
     */
    private String posString(Symbol sym) {
        int line = toLine(sym);
        int col = toColumn(sym);
        if (line < 0 || col < 0) {
            return "";
        }
        return " (linea " + line + ", columna " + col + ")";
    }

    /**
     * Proposito: centralizar el registro y almacenamiento de errores semanticos.
     * Entradas: mensaje descriptivo y simbolo relacionado para la posicion.
     * Salidas: linea en stderr y adicion a la lista semanticErrors.
     * Restricciones: protege contra simbolos nulos antes de usar sus datos.
     */
    private void reportSemanticError(String message, Symbol sym) {
        String formatted = "[SEMANTICO] " + message + posString(sym);
        semanticErrors.add(formatted);
        System.err.println(formatted);
    }

    /**
     * Proposito: detectar si la ejecucion ocurre en la raiz del repo o dentro de /programa.
     * Entradas: ninguna; se basa en el directorio de trabajo actual.
     * Salidas: Path base que contiene las carpetas src y output.
     * Restricciones: si no se puede detectar, regresa el directorio actual.
     */
    private Path resolveProjectBaseDir() {
        Path cwd = Paths.get(System.getProperty("user.dir")).toAbsolutePath();
        if (Files.isDirectory(cwd.resolve("src")) && Files.isDirectory(cwd.resolve("output"))) {
            return cwd;
        }
        Path nested = cwd.resolve("programa");
        if (Files.isDirectory(nested) && Files.isDirectory(nested.resolve("src"))) {
            return nested;
        }
        return cwd;
    }

    /**
     * Proposito: obtener la tabla semantica de un alcance, creandola si no existe.
     * Entradas: nombre textual del alcance solicitado.
     * Salidas: LinkedHashMap con los SymbolInfo del alcance.
     * Restricciones: el nombre no debe ser null; la creacion es idempotente.
     */
    private LinkedHashMap<String, SymbolInfo> semanticScope(String scopeName) {
        ensureScopeBucket(scopeName);
        return semanticScopes.get(scopeName);
    }

    /**
     * Proposito: declarar un simbolo dentro del alcance correspondiente y registrar su metadata.
     * Entradas: alcance propietario, lexema, tipo, indicadores de arreglo, bandera de parametro/global y token para ubicacion.
     * Salidas: SymbolInfo almacenado en semanticScopes y linea resumen en scopePrograma.
     * Restricciones: evita duplicados por alcance y usa el global cuando owner es null.
     */
    private SymbolInfo declareSymbol(String ownerScope, String name, String type,
                                     boolean isArray, int arraySize, boolean isParam,
                                     boolean forceGlobal, Symbol token) {
        String scopeName = forceGlobal ? globalHash : (ownerScope != null ? ownerScope : globalHash);
        ensureScopeBucket(scopeName);
        LinkedHashMap<String, SymbolInfo> table = semanticScopes.get(scopeName);
        if (table.containsKey(name)) {
            reportSemanticError("El identificador '" + name + "' ya existe en el alcance '" + scopeName + "'", token);
            return null;
        }
        SymbolInfo info = new SymbolInfo(name, type, isArray, arraySize, isParam,
                                         scopeName.equals(globalHash), toLine(token), toColumn(token));
        table.put(name, info);

        ArrayList<String> bucket = scopePrograma.get(scopeName);
        if (bucket == null) {
            bucket = new ArrayList<>();
            scopePrograma.put(scopeName, bucket);
        }
        String lineStr = info.line >= 0 ? Integer.toString(info.line) : "n/a";
        String colStr = info.col >= 0 ? Integer.toString(info.col) : "n/a";
        String prefix;
        if (isParam) {
            prefix = "Parametro";
        } else if (scopeName.equals(globalHash)) {
            prefix = "Instancia GLOBAL";
        } else {
            prefix = "Instancia";
        }
        String typeLabel = isArray ? ("ARR:" + type) : type;
        bucket.add(prefix + ": " + name + ":" + typeLabel + ":line=" + lineStr + ":col=" + colStr);
        return info;
    }

    /**
     * Proposito: resolver identificadores buscando primero en el alcance actual y luego en el global.
     * Entradas: lexema a localizar.
     * Salidas: SymbolInfo encontrado o null si no existe declaracion.
     * Restricciones: depende de currentHash para conocer el alcance activo.
     */
    private SymbolInfo lookupSymbol(String name) {
        if (currentHash != null) {
            LinkedHashMap<String, SymbolInfo> local = semanticScopes.get(currentHash);
            if (local != null && local.containsKey(name)) {
                return local.get(name);
            }
        }
        LinkedHashMap<String, SymbolInfo> global = semanticScopes.get(globalHash);
        if (global != null && global.containsKey(name)) {
            return global.get(name);
        }
        return null;
    }

    /**
     * Proposito: construir los atributos de una expresion basada en un identificador simple.
     * Entradas: lexema y simbolo que origina la referencia.
     * Salidas: ExprAttr con place/type o un marcador invalido si hay errores.
     * Restricciones: los arreglos requieren indice y se rechazan aqui.
     */
    private ExprAttr identifierExpr(String name, Symbol token) {
        SymbolInfo info = lookupSymbol(name);
        if (info == null) {
            reportSemanticError("El identificador '" + name + "' no ha sido declarado", token);
            return ExprAttr.invalid();
        }
        if (info.isArray) {
            reportSemanticError("El identificador '" + name + "' es un arreglo, se requiere indice", token);
            return ExprAttr.invalid();
        }
        return new ExprAttr(name, info.type, false);
    }

    /**
     * Proposito: validar y describir el acceso a un elemento de arreglo generando codigo de tres direcciones explicito.
     * Entradas: nombre del arreglo, expresion de indice y simbolos para diagnosticos.
     * Salidas: ExprAttr con el temporal cargado desde memoria y los metadatos necesarios para reasignaciones.
     * Restricciones: requiere arreglo declarado, indice INT valido y verifica limites cuando sea posible.
     */
    private ExprAttr arrayAccess(String name, ExprAttr index, Symbol idSym, Symbol idxSym) {
        SymbolInfo info = lookupSymbol(name);
        if (info == null) {
            reportSemanticError("El arreglo '" + name + "' no ha sido declarado", idSym);
            return ExprAttr.invalid();
        }
        if (!info.isArray) {
            reportSemanticError("El identificador '" + name + "' no es un arreglo", idSym);
            return ExprAttr.invalid();
        }
        if (index == null || !index.isValid()) {
            reportSemanticError("El indice para '" + name + "' es invalido", idxSym != null ? idxSym : idSym);
            return ExprAttr.invalid();
        }
        if (!"INT".equals(index.type)) {
            reportSemanticError("El indice para '" + name + "' debe ser de tipo INT", idxSym != null ? idxSym : idSym);
            return ExprAttr.invalid();
        }
        if (info.arraySize > 0 && index.constant) {
            try {
                int idxVal = Integer.parseInt(index.place);
                if (idxVal < 0 || idxVal >= info.arraySize) {
                    reportSemanticError("Indice fuera de rango para '" + name + "' (0.." + (info.arraySize - 1) + ")", idxSym != null ? idxSym : idSym);
                }
            } catch (NumberFormatException ignore) {
                // Si no se puede evaluar en tiempo de compilacion no se aplica la verificacion
            }
        }

        String loadTemp = newTemp(info.type);
        emit("aload " + loadTemp + ", " + name + ", " + index.place);
        String location = name + "[" + index.place + "]";
        return new ExprAttr(loadTemp, info.type, false, location, info, index.place);
    }

    /**
     * Proposito: centralizar la escritura de valores dentro de un arreglo en el codigo de tres direcciones.
     * Entradas: referencia al ExprAttr que apunta al elemento, valor evaluado y simbolo para diagnosticos.
     * Salidas: instruccion 'astore' que refleja la asignacion.
     * Restricciones: el ExprAttr debe representar un elemento de arreglo y los tipos deben coincidir.
     */
    private void emitArrayStore(ExprAttr target, ExprAttr value, Symbol token) {
        if (target == null || !target.isArrayReference()) {
            reportSemanticError("Se intento asignar a un destino que no es un arreglo", token);
            return;
        }
        if (value == null || !value.isValid()) {
            reportSemanticError("Expresion invalida al asignar a arreglo", token);
            return;
        }
        if (!target.type.equals(value.type)) {
            reportSemanticError("Tipos incompatibles al asignar a arreglo: se esperaba '" + target.type + "' y se recibio '" + value.type + "'", token);
            return;
        }
        emit("astore " + target.symbolInfo.name + ", " + target.indexPlace + ", " + value.place);
    }

    /**
     * Proposito: verificar que una lista de inicializacion de arreglos no mezcle tipos diferentes.
     * Entradas: lista de ExprAttr y simbolo para diagnosticos.
     * Salidas: true cuando todos los elementos comparten el mismo tipo; false en caso contrario.
     * Restricciones: ignora entradas nulas o invalidas para evitar duplicar mensajes previos.
     */
    private boolean ensureHomogeneousElements(ArrayList<ExprAttr> list, Symbol token) {
        if (list == null || list.isEmpty()) {
            return true;
        }
        String baseType = null;
        boolean ok = true;
        for (ExprAttr expr : list) {
            if (expr == null || !expr.isValid()) {
                continue;
            }
            if (baseType == null) {
                baseType = expr.type;
            } else if (!baseType.equals(expr.type)) {
                reportSemanticError("Los elementos del arreglo deben ser del mismo tipo; se encontro '" + expr.type + "' y '" + baseType + "'", token);
                ok = false;
            }
        }
        return ok;
    }

    /**
     * Proposito: poblar un arreglo declarado con la lista de expresiones evaluadas durante la inicializacion.
     * Entradas: simbolo del arreglo, lista de ExprAttr y el token para diagnosticos.
     * Salidas: emite las instrucciones 'astore' necesarias y rellena con ceros cuando falten elementos.
     * Restricciones: el arreglo debe haber sido declarado previamente y el tipo de cada elemento debe coincidir.
     */
    private void initializeArrayValues(SymbolInfo info, ArrayList<ExprAttr> values, Symbol token) {
        if (info == null) {
            return;
        }
        if (!info.isArray) {
            reportSemanticError("El identificador '" + info.name + "' no es un arreglo", token);
            return;
        }
        ensureHomogeneousElements(values, token);
        if (values != null) {
            if (info.arraySize > 0 && values.size() > info.arraySize) {
                reportSemanticError("Demasiados elementos para '" + info.name + "'", token);
            }
            for (int i = 0; i < values.size(); i++) {
                if (info.arraySize > 0 && i >= info.arraySize) {
                    break;
                }
                ExprAttr expr = values.get(i);
                if (expr == null || !expr.isValid()) {
                    reportSemanticError("Elemento invalido en inicializacion de '" + info.name + "'", token);
                    continue;
                }
                if (!info.type.equals(expr.type)) {
                    reportSemanticError("Elemento no compatible para arreglo '" + info.name + "'", token);
                    continue;
                }
                emit("astore " + info.name + ", " + i + ", " + expr.place);
            }
            if (info.arraySize > 0 && values.size() < info.arraySize) {
                emit("arr_pad_zero " + info.name + ", " + values.size() + ", " + info.arraySize);
            }
        } else if (info.arraySize > 0) {
            emit("arr_pad_zero " + info.name + ", 0, " + info.arraySize);
        }
    }

    /**
     * Proposito: realizar las validaciones semanticas de una llamada e imprimir el codigo 3D correspondiente.
     * Entradas: nombre de la funcion, lista de argumentos evaluados y simbolo del sitio de llamada.
     * Salidas: ExprAttr que referencia el temporal de retorno; registra errores si algo no coincide.
     * Restricciones: la funcion debe existir previamente y los tipos de los argumentos deben coincidir de forma exacta.
     */
    private ExprAttr invokeFunction(String name, ArrayList<ExprAttr> args, Symbol token) {
        FunctionInfo fun = functionTable.get(name);
        if (fun == null) {
            reportSemanticError("La funcion '" + name + "' no ha sido declarada", token);
            return ExprAttr.invalid();
        }
        if (args == null) {
            args = new ArrayList<>();
        }
        if (fun.params.size() != args.size()) {
            reportSemanticError("La funcion '" + name + "' espera " + fun.params.size() + " parametros y recibe " + args.size(), token);
        } else {
            for (int i = 0; i < fun.params.size(); i++) {
                SymbolInfo param = fun.params.get(i);
                ExprAttr provided = args.get(i);
                if (provided == null || !provided.isValid()) {
                    reportSemanticError("Parametro " + (i+1) + " invalido al invocar '" + name + "'", token);
                    continue;
                }
                if (!param.type.equals(provided.type)) {
                    reportSemanticError("Parametro " + (i+1) + " de '" + name + "' espera '" + param.type + "' y recibe '" + provided.type + "'", token);
                }
            }
        }
        for (ExprAttr expr : args) {
            if (expr != null && expr.isValid()) {
                emit("param " + expr.place);
            }
        }
        String temp = newTemp(fun.returnType);
        emit(temp + " = call " + name + ", " + args.size());
        return new ExprAttr(temp, fun.returnType, false);
    }

    /**
     * Proposito: preparar las estructuras internas para una nueva declaracion de funcion.
     * Entradas: nombre de la funcion, tipo de retorno y simbolo de declaracion.
     * Salidas: registros en functionTable/scopePrograma y emision del bloque begin_func.
     * Restricciones: reporta error si la funcion ya existia.
     */
    private void startFunctionScope(String name, String returnType, Symbol token) {
        if (functionTable.containsKey(name)) {
            reportSemanticError("La funcion '" + name + "' ya fue declarada", token);
            return;
        }
        FunctionInfo info = new FunctionInfo(name, returnType);
        functionTable.put(name, info);
        currentHash = name;
        ArrayList<String> bucket = new ArrayList<>();
        bucket.add("tipo:func:" + returnType);
        scopePrograma.put(name, bucket);
        semanticScopes.put(name, new LinkedHashMap<>());
    }

    /**
     * Proposito: abandonar el alcance de funcion en el que se estaba trabajando.
     * Entradas: ninguna (usa currentHash).
     * Salidas: restablece currentHash para que las declaraciones regresen al alcance global.
     * Restricciones: debe invocarse una sola vez por startFunctionScope.
     */
    private void closeCurrentScope() {
        currentHash = null;
    }

    /**
     * Proposito: recuperar la metadata de la funcion que se esta procesando.
     * Entradas: ninguna.
     * Salidas: instancia FunctionInfo o null si no estamos dentro de una funcion.
     * Restricciones: depende de que currentHash refleje el alcance real.
     */
    private FunctionInfo currentFunction() {
        if (currentHash == null) {
            return null;
        }
        return functionTable.get(currentHash);
    }

    /**
     * Proposito: registrar un parametro formal tanto en la tabla semantica como en la metadata de la funcion.
     * Entradas: nombre/tipo del parametro y coordenadas del token original.
     * Salidas: SymbolInfo almacenado en el alcance actual y agregado a la lista de parametros.
     * Restricciones: asume que currentHash apunta a la funcion propietaria.
     */
    private void registrarParametroEnScope(String nombre, String tipo, int left, int right) {
        Symbol fake = new Symbol(sym.IDENTIFIER, left, right, nombre);
        SymbolInfo info = declareSymbol(currentHash, nombre, tipo, false, 0, true, false, fake);
        FunctionInfo fun = currentFunction();
        if (fun != null && info != null) {
            fun.params.add(info);
        }
    }

    /**
     * Proposito: reflejar en el codigo 3D los parametros formales de la funcion actual.
     * Entradas: ninguna (usa currentFunction para obtener la metadata vigente).
     * Salidas: linea "Parametros_funcion_nombre: [TIPO_param,...]" si existen parametros.
     * Restricciones: se emite una sola vez por funcion para evitar duplicados.
     */
    private void emitFunctionParamMetadata() {
        FunctionInfo fun = currentFunction();
        if (fun == null || fun.paramsMetadataEmitted || fun.params.isEmpty()) {
            return;
        }
        ArrayList<String> descriptors = new ArrayList<>();
        for (SymbolInfo param : fun.params) {
            descriptors.add(param.type + "_" + param.name);
        }
        emit("Parametros_funcion_" + fun.name + ": [" + String.join(", ", descriptors) + "]");
        fun.paramsMetadataEmitted = true;
    }

    /**
     * Proposito: encapsular literales o valores por defecto dentro de un ExprAttr.
     * Entradas: simbolo CUP (puede ser null), texto por defecto y tipo semantico.
     * Salidas: ExprAttr marcado como constante con el place/type correspondiente.
     * Restricciones: quien llama debe asegurarse de que el tipo sea compatible con el lenguaje.
     */
    private ExprAttr literalAttr(Symbol sym, String fallback, String type) {
        String raw = sym != null && sym.value != null ? sym.value.toString() : fallback;
        if (raw == null) {
            raw = fallback != null ? fallback : "0";
        }
        return new ExprAttr(raw, type, true);
    }

    /**
     * Proposito: asegurar que una expresion sea numerica antes de usarla en aritmetica.
     * Entradas: ExprAttr a validar, simbolo para reportar el error y descripcion textual del contexto.
     * Salidas: el mismo ExprAttr si es valido o un marcador invalido con registro de error.
     * Restricciones: se espera que expr no sea null y que ya tenga tipo asociado.
     */
    private ExprAttr ensureNumeric(ExprAttr expr, Symbol token, String context) {
        if (expr == null || !expr.isValid() || !expr.isNumeric()) {
            reportSemanticError("Se esperaba expresion numerica en " + context, token);
            return ExprAttr.invalid();
        }
        return expr;
    }

    private ExprAttr promoteIntToFloat(ExprAttr expr, Symbol token) {
        if (expr == null || !expr.isValid()) {
            return ExprAttr.invalid();
        }
        if (!"INT".equals(expr.type)) {
            reportSemanticError("Solo se pueden promover INT a FLOAT", token);
            return ExprAttr.invalid();
        }
        String temp = newTemp("FLOAT");
        emit(temp + " = itof " + expr.place);
        return new ExprAttr(temp, "FLOAT", false);
    }

    private ExprAttr[] alignNumericTypes(ExprAttr left, ExprAttr right, Symbol token) {
        ExprAttr[] pair = new ExprAttr[]{left, right};
        if (left == null || right == null) {
            return pair;
        }
        if (!left.isNumeric() || !right.isNumeric()) {
            return pair;
        }
        if (left.type.equals(right.type)) {
            return pair;
        }
        if ("INT".equals(left.type) && "FLOAT".equals(right.type)) {
            pair[0] = promoteIntToFloat(left, token);
        } else if ("FLOAT".equals(left.type) && "INT".equals(right.type)) {
            pair[1] = promoteIntToFloat(right, token);
        } else {
            reportSemanticError("Comparacion no soportada entre '" + left.type + "' y '" + right.type + "'", token);
            pair[0] = ExprAttr.invalid();
            pair[1] = ExprAttr.invalid();
        }
        return pair;
    }

    /**
     * Proposito: aplicar las reglas semanticas de operadores aritmeticos binarios y emitir su codigo de tres direcciones.
     * Entradas: lexema del operador, operandos izquierdo/derecho y simbolo para diagnosticos.
     * Salidas: ExprAttr que apunta al nuevo temporal generado; invalido si ocurre algun error.
     * Restricciones: ambos operandos deben ser numericos; se promociona a FLOAT si es necesario.
     */
    private ExprAttr numericBinary(String op, ExprAttr left, ExprAttr right, Symbol token) {
        if (left == null) left = ExprAttr.invalid();
        if (right == null) right = ExprAttr.invalid();
        if (!left.isValid() || !right.isValid()) {
            reportSemanticError("Operacion aritmetica invalida", token);
            return ExprAttr.invalid();
        }
        if (!left.isNumeric() || !right.isNumeric()) {
            reportSemanticError("Operacion '" + op + "' solo soporta INT/FLOAT", token);
            return ExprAttr.invalid();
        }
        if (!left.type.equals(right.type)) {
            reportSemanticError("No se puede operar '" + left.type + "' con '" + right.type + "' usando '" + op + "'", token);
            return ExprAttr.invalid();
        }
        String resultType = left.type;
        String temp = newTemp(resultType);
        emit(temp + " = " + left.place + " " + op + " " + right.place);
        return new ExprAttr(temp, resultType, false);
    }

    /**
     * Proposito: procesar operadores numericos unarios y emitir su codigo de tres direcciones.
     * Entradas: lexema del operador, expresion operando y simbolo para diagnosticos.
     * Salidas: ExprAttr que referencia el temporal resultante.
     * Restricciones: el operando debe ser numerico; los errores propagan expresiones invalidas.
     */
    private ExprAttr numericUnary(String op, ExprAttr value, Symbol token) {
        if (value == null || !value.isValid() || !value.isNumeric()) {
            reportSemanticError("Operacion '" + op + "' requiere un numerico", token);
            return ExprAttr.invalid();
        }
        String temp = newTemp(value.type);
        emit(temp + " = " + op + value.place);
        return new ExprAttr(temp, value.type, false);
    }

    /**
     * Proposito: aplicar las reglas de comparacion y generar temporales booleanos.
     * Entradas: operador, operandos izquierdo/derecho y simbolo CUP para los mensajes.
     * Salidas: ExprAttr de tipo BOOL que referencia el codigo emitido.
     * Restricciones: si los operandos no son numericos deben compartir exactamente el mismo tipo.
     */
    private ExprAttr compareBinary(String op, ExprAttr left, ExprAttr right, Symbol token) {
        if (left == null) left = ExprAttr.invalid();
        if (right == null) right = ExprAttr.invalid();
        if (!left.isValid() || !right.isValid()) {
            reportSemanticError("Comparacion invalida", token);
            return ExprAttr.invalid();
        }
        boolean numericOperands = left.isNumeric() && right.isNumeric();
        if (!left.type.equals(right.type)) {
            if (numericOperands) {
                ExprAttr[] aligned = alignNumericTypes(left, right, token);
                left = aligned[0];
                right = aligned[1];
                if (left == null || right == null || !left.isValid() || !right.isValid()) {
                    return ExprAttr.invalid();
                }
                numericOperands = left.isNumeric() && right.isNumeric();
            } else {
                reportSemanticError("Comparacion requiere operandos del mismo tipo; se obtuvo '" + left.type + "' y '" + right.type + "'", token);
                return ExprAttr.invalid();
            }
        }
        boolean equalityOp = "==".equals(op) || "!=".equals(op);
        if (equalityOp) {
            if (!numericOperands && !left.isBoolean() && !"CHAR".equals(left.type) && !"STRING".equals(left.type)) {
                reportSemanticError("Comparacion no soportada para tipo '" + left.type + "'", token);
                return ExprAttr.invalid();
            }
        } else if (!numericOperands) {
            reportSemanticError("El operador '" + op + "' solo admite operandos numericos del mismo tipo", token);
            return ExprAttr.invalid();
        }
        String temp = newTemp("BOOL");
        emit(temp + " = " + left.place + " " + op + " " + right.place);
        return new ExprAttr(temp, "BOOL", false);
    }

    /**
     * Proposito: evaluar secuencias del tipo a > b > c reduciendolas a una expresion booleana.
     * Entradas: resultado de la primera subexpresion aritmetica y la lista de comparaciones restantes.
     * Salidas: ExprAttr booleano que representa la conjuncion de todas las comparaciones consecutivas.
     * Restricciones: cada comparacion debe ser valida y sus operandos deben compartir tipo compatible.
     */
    private ExprAttr buildChainedComparison(ExprAttr first, ArrayList<ComparisonLink> links) {
        if (first == null || links == null || links.isEmpty()) {
            return ExprAttr.invalid();
        }
        if (!first.isValid()) {
            return ExprAttr.invalid();
        }
        ExprAttr previous = first;
        ExprAttr accumulated = null;
        for (ComparisonLink link : links) {
            if (link == null || link.right == null) {
                return ExprAttr.invalid();
            }
            ExprAttr comparison = compareBinary(link.operator, previous, link.right, link.token);
            if (comparison == null || !comparison.isValid()) {
                return ExprAttr.invalid();
            }
            accumulated = (accumulated == null)
                    ? comparison
                    : logicalBinary("&&", accumulated, comparison, link.token);
            previous = link.right;
            if (accumulated == null || !accumulated.isValid()) {
                return ExprAttr.invalid();
            }
        }
        return accumulated != null ? accumulated : ExprAttr.invalid();
    }

    /**
     * Proposito: validar operaciones logicas tipo AND/OR a nivel semantico.
     * Entradas: operador logico, operandos booleanos y simbolo con datos de error.
     * Salidas: ExprAttr booleano ligado al temporal que almacena el resultado.
     * Restricciones: ambos operandos deben ser BOOL.
     */
    private ExprAttr logicalBinary(String op, ExprAttr left, ExprAttr right, Symbol token) {
        if (left == null || right == null || !left.isBoolean() || !right.isBoolean()) {
            reportSemanticError("Operacion logica requiere booleanos", token);
            return ExprAttr.invalid();
        }
        String temp = newTemp("BOOL");
        emit(temp + " = " + left.place + " " + op + " " + right.place);
        return new ExprAttr(temp, "BOOL", false);
    }

    /**
     * Proposito: procesar operadores logicos unarios como la negacion.
     * Entradas: operador, expresion operando y simbolo fuente.
     * Salidas: ExprAttr booleano cuando el operando es valido.
     * Restricciones: solo acepta entradas booleanas.
     */
    private ExprAttr logicalUnary(String op, ExprAttr value, Symbol token) {
        if (value == null || !value.isBoolean()) {
            reportSemanticError("Operacion logica requiere booleano", token);
            return ExprAttr.invalid();
        }
        String temp = newTemp("BOOL");
        emit(temp + " = " + op + " " + value.place);
        return new ExprAttr(temp, "BOOL", false);
    }

    /**
     * Proposito: salvaguardar sentencias que dependen de expresiones booleanas.
     * Entradas: ExprAttr evaluado, simbolo para ubicar el error y descripcion del contexto.
     * Salidas: ninguna; solo reporta el error cuando la condicion no se cumple.
     * Restricciones: aun con el reporte, quien llama debe manejar expresiones invalidas.
     */
    private void ensureBoolean(ExprAttr expr, Symbol token, String context) {
        if (expr == null || !expr.isBoolean()) {
            reportSemanticError("La expresion en " + context + " debe ser BOOL", token);
        }
    }

    private ExprAttr ensureBooleanExpr(ExprAttr expr, Symbol token, String context) {
        if (expr != null && expr.isBoolean()) {
            return expr;
        }
        reportSemanticError("La expresion en " + context + " debe ser BOOL", token);
        return new ExprAttr("false", "BOOL", true);
    }

    private String peekLabelOrFallback(ArrayDeque<String> stack, String context, String prefix, boolean pushWhenMissing) {
        if (!stack.isEmpty()) {
            return stack.peek();
        }
        reportSemanticError("No existe una etiqueta activa para " + context, null);
        String fallback = newLabel(prefix + "_recovery");
        if (pushWhenMissing) {
            stack.push(fallback);
        }
        return fallback;
    }

    private String popLabelOrFallback(ArrayDeque<String> stack, String context, String prefix) {
        if (!stack.isEmpty()) {
            return stack.pop();
        }
        reportSemanticError("No existe una etiqueta activa para " + context, null);
        return newLabel(prefix + "_recovery");
    }

    /**
     * Proposito: centralizar las validaciones de asignaciones escalares y la emision de codigo de tres direcciones.
     * Entradas: metadata del destino, expresion evaluada y simbolo '='.
     * Salidas: emite el codigo de asignacion cuando los tipos coinciden.
     * Restricciones: el destino no puede ser arreglo y los tipos tienen que ser identicos.
     */
    private void recordAssignment(SymbolInfo target, ExprAttr value, Symbol token) {
        if (target == null || value == null || !value.isValid()) {
            reportSemanticError("Asignacion invalida", token);
            return;
        }
        if (!target.type.equals(value.type)) {
            reportSemanticError("Tipos incompatibles en asignacion para '" + target.name + "'", token);
            return;
        }
        emit(target.name + " = " + value.place);
    }

    /**
     * Proposito: validar las sentencias return y marcar que la funcion retorno.
     * Entradas: expresion opcional, simbolo y bandera que indica si hay valor explicito.
    * Salidas: emite el codigo de tres direcciones del return cuando los tipos coinciden; reporta errores cuando falta.
     * Restricciones: no puede usarse fuera de los alcances de funcion.
     */
    private void recordReturn(ExprAttr value, Symbol token, boolean hasValue) {
        FunctionInfo fun = currentFunction();
        if (fun == null) {
            reportSemanticError("Return fuera de una función", token);
            return;
        }
        boolean expectsValue = !fun.returnsVoid;
        if (expectsValue && !hasValue) {
            reportSemanticError("La función '" + fun.name + "' requiere retornar un valor de tipo '" + fun.returnType + "'", token);
            return;
        }
        if (!expectsValue && hasValue) {
            reportSemanticError("La función '" + fun.name + "' no debe retornar valores", token);
            return;
        }
        if (hasValue) {
            if (value == null || !value.isValid()) {
                reportSemanticError("Return inválido", token);
                return;
            }
            if (!fun.returnType.equals(value.type)) {
                reportSemanticError("El return de '" + fun.name + "' espera tipo '" + fun.returnType + "' y recibe '" + value.type + "'", token);
                return;
            }
            emit("return " + value.place);
        } else {
            emit("return");
        }
        fun.hasReturn = true;
    }

    /**
     * Proposito: generar identificadores unicos para temporales.
     * Entradas: etiqueta de tipo solo para fines descriptivos.
     * Salidas: nombre de cadena para usarse en el codigo de tres direcciones.
     * Restricciones: no depender del prefijo mas alla de la legibilidad.
     */
    private String newTemp(String type) {
        tempCounter++;
        return ("FLOAT".equals(type) ? "f" : "t") + tempCounter;
    }

    /**
     * Proposito: crear etiquetas unicas para estructuras de control.
     * Entradas: prefijo textual que describe la construccion.
     * Salidas: etiqueta con un contador incremental.
     * Restricciones: el prefijo debe ser descriptivo para ayudar al depurado.
     */
    private String newLabel(String prefix) {
        labelCounter++;
        return prefix + "_" + labelCounter;
    }

    /**
     * Proposito: agregar una instruccion al buffer de codigo 3D.
     * Entradas: linea de codigo de tres direcciones ya formateada.
     * Salidas: actualiza cod3D con la linea mas un salto de linea.
     * Restricciones: quien llama debe evitar cadenas nulas o vacias.
     */
    private void emit(String codeLine) {
        cod3D.append(codeLine).append("\n");
    }

    /**
     * Proposito: imprimir la declaracion de una etiqueta dentro del codigo 3D.
     * Entradas: etiqueta generada previamente.
     * Salidas: escribe "label:" seguido de salto de linea en cod3D.
     * Restricciones: solo debe llamarse con etiquetas unicas.
     */
    private void emitLabel(String label) {
        cod3D.append(label).append(":\n");
    }

    /**
     * Proposito: escribir una cabecera estandarizada que describa el formato del codigo intermedio.
     * Entradas: ninguna.
     * Salidas: inserta directivas #!CI_* al inicio del archivo si no se han emitido.
     * Restricciones: se ejecuta una sola vez por ejecucion del parser.
     */
    private void emitCiHeader() {
        if (ciHeaderEmitted) {
            return;
        }
        ciHeaderEmitted = true;
        emit("#!CI_VERSION 1.1");
        emit("#!CI_TARGET MIPS");
        emit("#!CI_FORMAT structured");
    }

    private void emitFunctionEntry(String name, String returnType) {
        emitCiHeader();
        emit("FUNC_BEGIN " + name + " RET " + returnType);
        emitLabel("INICIO_funcion_" + name);
    }

    private void emitFunctionExit(String name) {
        emitLabel("FIN_funcion_" + name);
        emit("FUNC_END " + name);
    }

    /**
     * Proposito: convertir literales CUP en enteros primitivos para tamanos de arreglo.
     * Entradas: simbolo que contiene digitos.
     * Salidas: valor entero o 0 si la conversion falla.
     * Restricciones: pensado para literales decimales no negativos.
     */
    private int literalToInt(Symbol sym) {
        if (sym != null && sym.value != null) {
            try {
                return Integer.parseInt(sym.value.toString());
            } catch (NumberFormatException ex) {
                reportSemanticError("Valor numérico inválido", sym);
            }
        }
        return 0;
    }

    /**
     * Proposito: construir simbolos CUP sinteticos para llamadas auxiliares internas.
     * Entradas: valor bruto, coordenadas y el id del simbolo.
     * Salidas: Symbol con la metadata proporcionada.
     * Restricciones: usar solo para diagnostico, nunca para devolverlo al lexer.
     */
    private Symbol tokenFrom(Object value, int left, int right, int symId) {
        return new Symbol(symId, left, right, value);
    }

    /**
     * Proposito: convertir valores arbitrarios de tokens en cadenas seguras y no nulas.
     * Entradas: referencia proveniente del lexer o de auxiliares.
     * Salidas: representacion en cadena o vacio si es null.
     * Restricciones: utilidad simple; quien llama puede aplicar trim si lo requiere.
     */
    private String lexeme(Object value) {
        return value != null ? value.toString() : "";
    }

    /**
     * Proposito: inicializar las pilas antes de procesar un decide-of.
     * Entradas: ninguna.
     * Salidas: apila la etiqueta de cierre para usarla en las ramas.
     * Restricciones: debe emparejarse con endDecideStructure.
     */
    private void beginDecideStructure() {
        String beginLabel = newLabel("decide_begin");
        emitLabel(beginLabel);
        decideEndStack.push(newLabel("decide_end"));
    }

    /**
     * Proposito: cerrar la estructura decide-of y emitir su etiqueta final.
     * Entradas: ninguna.
     * Salidas: imprime la etiqueta pendiente y limpia las pilas.
     * Restricciones: asume que beginDecideStructure ya se invoco.
     */
    private void endDecideStructure() {
        emitLabel(popLabelOrFallback(decideEndStack, "decide", "decide_end"));
    }

    /**
     * Proposito: iniciar un caso dentro de decide-of validando su condicion y preparando los saltos.
     * Entradas: expresion condicional y simbolo para diagnosticos.
     * Salidas: emite los saltos condicionales y apila la etiqueta de continuacion.
     * Restricciones: la condicion debe ser booleana o se reporta error.
     */
    private void beginDecideCase(ExprAttr condition, Symbol token) {
        ExprAttr guard = ensureBooleanExpr(condition, token, "la condición de decide");
        String hitLabel = newLabel("case_hit");
        String nextLabel = newLabel("case_next");
        emit("if " + guard.place + " goto " + hitLabel);
        emit("goto " + nextLabel);
        emitLabel(hitLabel);
        decideNextStack.push(nextLabel);
    }

    /**
     * Proposito: cerrar el caso activo de decide y ajustar el flujo de control.
     * Entradas: ninguna.
     * Salidas: emite el salto hacia la etiqueta final y declara la etiqueta siguiente almacenada.
     * Restricciones: requiere que beginDecideCase haya colocado una etiqueta en la pila.
     */
    private void endDecideCase() {
        String endLabel = peekLabelOrFallback(decideEndStack, "decide", "decide_end", true);
        String nextLabel = decideNextStack.isEmpty() ? newLabel("case_next_recovery") : decideNextStack.pop();
        emit("goto " + endLabel);
        emitLabel(nextLabel);
    }

    /**
     * Proposito: preparar la rama else del decide-of.
     * Entradas: ninguna.
     * Salidas: emite un comentario para claridad y reutiliza las etiquetas en pila.
     * Restricciones: se debe invocar una sola vez por cada decide-of.
     */
    private void beginDecideElse() {
        emit("// rama else");
    }

    /**
     * Proposito: cerrar la rama else saltando hacia la etiqueta final del decide.
     * Entradas: ninguna.
     * Salidas: emite un goto hacia la etiqueta de cierre.
     * Restricciones: asume que decideEndStack tiene una entrada vigente.
     */
    private void endDecideElse() {
        String endLabel = peekLabelOrFallback(decideEndStack, "decide", "decide_end", true);
        emit("goto " + endLabel);
    }

    /**
     * Proposito: inicializar las pilas de control para una estructura loop.
     * Entradas: ninguna.
     * Salidas: apila etiquetas de inicio/fin y emite la cabecera del ciclo.
     * Restricciones: debe emparejarse con endLoopStructure.
     */
    private void beginLoopStructure() {
        String start = newLabel("loop_begin");
        String end = newLabel("loop_end");
        loopStartStack.push(start);
        loopEndStack.push(end);
        emitLabel(start);
    }

    /**
     * Proposito: cerrar una estructura loop y desapilar sus etiquetas de control.
     * Entradas: ninguna.
     * Salidas: emite la etiqueta de fin y limpia las pilas.
     * Restricciones: solo es valido si beginLoopStructure fue invocado.
     */
    private void endLoopStructure() {
        emitLabel(popLabelOrFallback(loopEndStack, "loop", "loop_end"));
        if (!loopStartStack.isEmpty()) {
            loopStartStack.pop();
        } else {
            reportSemanticError("No existe etiqueta de inicio activa para loop", null);
        }
    }

    /**
     * Proposito: emitir la condicion de salida que abandona el cuerpo de un loop.
     * Entradas: expresion booleana de salida y simbolo relacionado.
     * Salidas: genera el salto condicional al final del loop y el retorno al inicio.
     * Restricciones: la expresion debe evaluar a BOOL.
     */
    private void finalizeLoopBody(ExprAttr exitExpr, Symbol token) {
        ExprAttr guard = ensureBooleanExpr(exitExpr, token, "la condición de salida del loop");
        String start = peekLabelOrFallback(loopStartStack, "loop", "loop_begin", true);
        String end = peekLabelOrFallback(loopEndStack, "loop", "loop_end", true);
        emit("if " + guard.place + " goto " + end);
        emit("goto " + start);
    }

    /**
     * Proposito: validar y emitir la estructura base de los ciclos FOR/DOWNTO.
     * Entradas: expresion de la variable control, paso, limite y bandera de direccion.
     * Salidas: emite etiquetas de condicion/cuerpo y almacena el contexto del ciclo.
     * Restricciones: todas las expresiones deben ser numericas y el destino asignable.
     */
    private void beginForLoop(ExprAttr target, ExprAttr step, ExprAttr limit, boolean downto) {
        if (target == null || !target.isNumeric()) {
            reportSemanticError("La variable de control del for debe ser numérica", null);
            return;
        }
        if (step == null || !step.isNumeric()) {
            reportSemanticError("El paso del for debe ser numérico", null);
            return;
        }
        if (limit == null || !limit.isNumeric()) {
            reportSemanticError("El límite del for debe ser numérico", null);
            return;
        }
        String condLabel = newLabel("for_cond");
        String bodyLabel = newLabel("for_body");
        String endLabel = newLabel("for_end");
        emitLabel(condLabel);
        String comparator = downto ? "<" : ">";
        emit("if " + target.place + " " + comparator + " " + limit.place + " goto " + endLabel);
        emitLabel(bodyLabel);
        loopStartStack.push(condLabel);
        loopEndStack.push(endLabel);
        forStack.push(new ForContext(target.place, target.type, step, limit, downto, condLabel, endLabel));
    }

    /**
     * Proposito: cerrar los ciclos FOR emitiendo el incremento/decremento y limpiando el estado.
     * Entradas: ninguna (usa la pila de contexto).
     * Salidas: actualiza la variable de control, regresa a la condicion y emite la etiqueta final.
     * Restricciones: asume que beginForLoop inserto un contexto en forStack.
     */
    private void endForLoop() {
        if (forStack.isEmpty()) {
            return;
        }
        ForContext ctx = forStack.pop();
        String op = ctx.downto ? "-" : "+";
        emit(ctx.target + " = " + ctx.target + " " + op + " " + ctx.step.place);
        emit("goto " + ctx.condLabel);
        emitLabel(ctx.endLabel);
        if (!loopEndStack.isEmpty()) loopEndStack.pop();
        if (!loopStartStack.isEmpty()) loopStartStack.pop();
    }

    /**
     * Proposito: volcar las tablas de simbolos en CSV y mostrar un resumen en consola.
     * Entradas: ninguna (usa el mapa scopePrograma).
     * Salidas: escribe TablaSimbolos.txt dentro del directorio de salida determinado.
     * Restricciones: garantiza que el directorio exista y maneja alcances vacios sin fallar.
     */
    public void imprimirscopePrograma () {
        System.out.println("\nTABLA DE SIMBOLOS (resumen)");
        try {
            Path outDir = resolveProjectBaseDir().resolve("output");
            Files.createDirectories(outDir);

            if (scopePrograma.isEmpty()) {
                scopePrograma.put(globalHash, new ArrayList<>());
            }

            Path tablaFile = outDir.resolve("TablaSimbolos.txt");
            Pattern p = Pattern.compile(".*:\\s*([^:]+):([^:]+)(:line=(\\d+):col=(\\d+))?.*");
            try (FileWriter fw = new FileWriter(tablaFile.toFile())) {
                fw.write("Scope,Name,Type,Line,Column\n");
                for (Map.Entry<String, ArrayList<String>> entry : scopePrograma.entrySet()) {
                    String key = entry.getKey();
                    System.out.println("Scope: " + key + "  (" + entry.getValue().size() + " entradas)");
                    for (String item : entry.getValue()) {
                        String name="", type="", line="n/a", col="n/a";
                        String[] parts = item.split(":");
                        if (parts.length >= 2) {
                            name = parts[1].trim();
                        }
                        if (parts.length >= 3) {
                            for (int i = 2; i < parts.length; i++) {
                                String part = parts[i].trim();
                                if (part.equals("INT") || part.equals("CHAR") || part.equals("FLOAT") || part.equals("BOOL") || part.equals("STRING") || part.startsWith("ARR") || part.startsWith("tipo:")) {
                                    type = part;
                                    break;
                                }
                            }
                            if (type.isEmpty()) {
                                type = parts[2].trim();
                            }
                        }
                        Matcher ml = Pattern.compile("line=(\\d+)").matcher(item);
                        if (ml.find()) line = ml.group(1);
                        Matcher mc = Pattern.compile("col=(\\d+)").matcher(item);
                        if (mc.find()) col = mc.group(1);
                        fw.write(key + "," + name + "," + type + "," + line + "," + col + "\n");
                    }
                }
            }

            System.out.println("Tablas de simbolos exportadas a: " + outDir.toAbsolutePath());
        } catch (Exception e) {
            System.err.println("Error al exportar tablas de simbolos: " + e.getMessage());
        }
    }

    /**
     * Proposito: persistir el codigo 3D generado en Codigo3D.txt.
     * Entradas: ninguna (usa el buffer cod3D).
     * Salidas: escribe el archivo y muestra el destino; avisa cuando no hay codigo.
     * Restricciones: crea el directorio de salida si falta y captura excepciones de IO.
     */
    private void exportarCodigo3D() {
        try {
            Path outDir = resolveProjectBaseDir().resolve("output");
            Files.createDirectories(outDir);
            Path cod3DFile = outDir.resolve("Codigo3D.txt");
            try (FileWriter fw = new FileWriter(cod3DFile.toFile())) {
                String codigo = cod3D.toString().trim();
                if (codigo.isEmpty()) {
                    fw.write("// No se genero codigo 3D\n");
                    System.out.println("Advertencia: No se genero codigo 3D");
                } else {
                    fw.write(codigo + "\n");
                    System.out.println("Codigo 3D exportado a: " + cod3DFile.toAbsolutePath());
                }
            }
        } catch (Exception e) {
            System.err.println("Error al exportar codigo 3D: " + e.getMessage());
        }
    }

    /**
     * Proposito: exportar tablas y codigo 3D solo una vez por ejecucion del parser.
     * Entradas: ninguna.
     * Salidas: invoca imprimirscopePrograma y exportarCodigo3D si aun no se han generado.
     * Restricciones: controlado por la bandera artifactsExported para evitar duplicados.
     */
    public void exportarResultados() {
        if (artifactsExported) {
            return;
        }
        imprimirscopePrograma();
        exportarCodigo3D();
        artifactsExported = true;
    }

    // recuperación de errores de sintaxis (mejorada)
    /**
     * Proposito: ofrecer un gancho detallado para el manejo de errores sintacticos de CUP.
     * Entradas: simbolo que ocasiono el error (puede ser null en EOF).
     * Salidas: mensaje detallado en stderr con id de token, yytext y coordenadas.
     * Restricciones: no debe lanzar excepciones; se protege contra fallos del lexer.
     */
    public void syntax_error(Symbol s) {
        try {
            if (s == null) {
                String yy = "";
                try { yy = lex.yytext(); } catch (Exception e) { yy = "<no-yytext>"; }
                System.err.println("!!Error de Sintaxis: símbolo nulo (fin de fichero probable). yytext='" + yy + "'");
                return;
            }

            int symId = s.sym;
            Object val = s.value;
            int left = s.left;
            int right = s.right;
            String yytext = "";
            try { yytext = lex.yytext(); } catch (Exception e) { yytext = "<no-yytext>"; }

            System.err.println("!!Error de Sintaxis: tokenId=" + symId + " value=" + val + " yytext='" + yytext + "' linea:" + (left>=0 ? (left+1) : "n/a") + " columna:" + (right>=0 ? (right+1) : "n/a"));

        } catch (Exception e) {
            System.err.println("!!Error de Sintaxis (excepción al informar): " + e.getMessage());
        }
    }

    /**
     * Proposito: informar errores sintacticos fatales cuando CUP no puede recuperarse.
     * Entradas: simbolo problematico o null.
     * Salidas: mensaje en stderr similar a syntax_error pero marcado como fatal.
     * Restricciones: no debe lanzar excepciones para permitir un cierre limpio del parser.
     */
    public void unrecovered_syntax_error(Symbol s) {
        try {
            if (s == null) {
                String yy = "";
                try { yy = lex.yytext(); } catch (Exception e) { yy = "<no-yytext>"; }
                System.err.println("!!Error fatal: símbolo nulo. yytext='" + yy + "'");
                return;
            }

            int symId = s.sym;
            Object val = s.value;
            int left = s.left;
            int right = s.right;
            String yytext = "";
            try { yytext = lex.yytext(); } catch (Exception e) { yytext = "<no-yytext>"; }

            System.err.println("!!Error fatal: tokenId=" + symId + " value=" + val + " yytext='" + yytext + "' linea:" + (left>=0 ? (left+1) : "n/a") + " columna:" + (right>=0 ? (right+1) : "n/a"));

        } catch (Exception e) {
            System.err.println("!!Error fatal (excepción al informar): " + e.getMessage());
        }
    }
:}

/* definicion de como conectar el parser con el escaner */
// inicializar con {: s.init(); :};
// escanear con {: return s.next_token(); :};
init with {::};
scan with {:return lex.next_token();:};


/* Terminales (tokens returned by the scanner). */
terminal            IDENTIFIER, MAS, MENOS, DMENOS, DMAS, MULTI, DIV, FLOAT_DIV, POTENCIA, INT_LITERAL;
terminal            INIT_BLOCK, END_BLOCK, INIT_COMMENT, END_COMMENT, COMMENT, PARAM, COMA, STRING_LITERAL;
terminal            EQ, GREATHER, LOWER, MORE, LESS, COMPARA, DIFF, AND, OR, NEGA;
terminal            INT, FLOAT, CHAR, BOOL, STRING, VOID, ARRAY;
terminal            GLOBAL, LET, DOT, PRINCIPAL;
terminal            TRUE, FALSE;
terminal            ELSE, FOR, DECIDE, OF, LOOP, END, EXIT, WHEN, STEP, TO, DOWNTO, DO;
terminal            BREAK, RETURN, INPUT, OUTPUT;
terminal            PARENTS, PARENTC, SQUARES, SQUAREC;
terminal            UKRA, RUSS, ARROW, CHARSTR;
terminal            DOLLAR; /* end of Expression */

/* No terminales */
non terminal            Integer expr;// almacena resultados intermedios de subexpresiones
non terminal            PROGRAMA, varIns, varAsig, BLOCK, compAritOp, factor, term, funcStruct, mainStruct, outPutStruct, blockStart, blockStartClose, loopBody;
non terminal            arrayIns, arrayAsig, arrayInsAsign, elementos, numbers, varInsInit, arrayLetStmt;
non terminal            decideClauseList, decideClause, decideOfStruct, loopStruct, loopElseOpt, forStruct, caseCondition;
non terminal            inputStruct, mainInitial, funInitial, exprP, exprLog, exprRel, arrayElement, paramStruct, paramList, PROGRAM_ITEMS, arrayInsGl, varInsGl, varInsAsig, varInsAsigGl, arrayInsAsignGl;
non terminal            paramSection, paramSectionClose, paramDeclList, paramDecl, argListOpt, argList, forInit, stepValue, commentBlock, commentBody;
non terminal String scalarType;
non terminal ArrayList arrayLiteral, arrayLiteralItems, relChainSeq, relChainSuffix;
non terminal ComparisonLink relChainLink;

/* Orden de precedencia */
precedence left MAS, MENOS;
precedence left MULTI;
precedence left DIV;

/* The grammar rules */    

start with PROGRAMA;

PROGRAMA ::= {: initializeGlobalScope(); emitCiHeader(); :} 
    PROGRAM_ITEMS {: exportarResultados(); :};

PROGRAM_ITEMS ::= mainStruct PROGRAM_ITEMS 
            | mainStruct
            | funcStruct PROGRAM_ITEMS 
            | funcStruct 
            | arrayInsGl DOLLAR PROGRAM_ITEMS 
            | arrayInsGl DOLLAR
            | varInsGl DOLLAR PROGRAM_ITEMS 
            | varInsGl DOLLAR
            | varInsInit DOLLAR PROGRAM_ITEMS
            | varInsInit DOLLAR
            | varIns DOLLAR PROGRAM_ITEMS 
            | varIns DOLLAR
            | varInsAsigGl PROGRAM_ITEMS 
            | varInsAsigGl
            | arrayInsAsignGl PROGRAM_ITEMS 
            | arrayInsAsignGl
            | arrayLetStmt DOLLAR PROGRAM_ITEMS
            | arrayLetStmt DOLLAR
            | commentBlock PROGRAM_ITEMS
            | commentBlock
            | error PROGRAM_ITEMS;  

//Los distintos tipos que pueden tener una funcion o variable

//Bloque que se usa para el codigo siga un rumbo, vease como la lista de posibles expresiones
BLOCK  ::=  BLOCK exprP DOLLAR
       | BLOCK varAsig 
       | BLOCK arrayInsGl DOLLAR
       | BLOCK varInsGl DOLLAR
       | BLOCK varInsAsigGl
       | BLOCK arrayInsAsignGl
       | BLOCK mainStruct
       | BLOCK funcStruct 
       | BLOCK varIns DOLLAR
         | BLOCK varInsInit DOLLAR
    | BLOCK decideOfStruct 
       | BLOCK loopStruct  
       | BLOCK forStruct 
       | BLOCK arrayIns DOLLAR
         | BLOCK arrayLetStmt DOLLAR
       | BLOCK varInsAsig 
       | BLOCK arrayInsAsign
    | BLOCK inputStruct
       | BLOCK outPutStruct DOLLAR
       | BLOCK BREAK DOLLAR
         | BLOCK RETURN:retTok exprP:exp DOLLAR
                {: Symbol retSym = tokenFrom(retTok, retTokleft, retTokright, sym.RETURN);
                    recordReturn((ExprAttr)exp, retSym, true);
                :}
         | BLOCK RETURN:retTok DOLLAR
                {: Symbol retSym = tokenFrom(retTok, retTokleft, retTokright, sym.RETURN);
                    recordReturn(null, retSym, false);
                :}
     | BLOCK commentBlock
       | exprP DOLLAR
       | arrayIns DOLLAR
       | arrayInsAsign
       | mainStruct
       | funcStruct 
       | varAsig    
       | arrayInsGl DOLLAR
       | varInsGl DOLLAR
       | varInsAsigGl
       | arrayInsAsignGl
       | varInsAsig 
       | varIns DOLLAR
         | varInsInit DOLLAR
         | arrayLetStmt DOLLAR
    | decideOfStruct 
       | forStruct
       | loopStruct
       | outPutStruct DOLLAR
    | BREAK:brk DOLLAR {: Symbol brkSym = tokenFrom(brk, brkleft, brkright, sym.BREAK); if (loopEndStack.isEmpty()) { reportSemanticError("'break' fuera de ciclo", brkSym); } else { emit("goto " + loopEndStack.peek()); } :}
    | RETURN:retTok exprP:exp DOLLAR {: Symbol retSym = tokenFrom(retTok, retTokleft, retTokright, sym.RETURN); recordReturn((ExprAttr)exp, retSym, true); :}
    | RETURN:retTok DOLLAR {: Symbol retSym = tokenFrom(retTok, retTokleft, retTokright, sym.RETURN); recordReturn(null, retSym, false); :}
       | inputStruct
    | commentBlock
       | error;

commentBlock ::= INIT_COMMENT commentBody END_COMMENT
         | INIT_COMMENT END_COMMENT;

commentBody ::= commentBody COMMENT
        | COMMENT;


numbers ::= INT_LITERAL:lit {: Symbol litSym = tokenFrom(lit, litleft, litright, sym.INT_LITERAL); RESULT = literalAttr(litSym, "0", "INT"); :}
         | FLOAT:lit {: Symbol litSym = tokenFrom(lit, litleft, litright, sym.FLOAT); RESULT = literalAttr(litSym, "0.0", "FLOAT"); :};

//Operaciones aritmeticas simples entre dos numeros
/* Reglas de producción para operaciones aritméticas */
compAritOp ::= term:t {: RESULT = t; :}
             | compAritOp:l MAS:op term:r {: Symbol opSym = tokenFrom(op, opleft, opright, sym.MAS); RESULT = numericBinary("+", (ExprAttr)l, (ExprAttr)r, opSym); :}
             | compAritOp:l MENOS:op term:r {: Symbol opSym = tokenFrom(op, opleft, opright, sym.MENOS); RESULT = numericBinary("-", (ExprAttr)l, (ExprAttr)r, opSym); :};

term       ::= factor:f {: RESULT = f; :}
             | term:l MULTI:op factor:r {: Symbol opSym = tokenFrom(op, opleft, opright, sym.MULTI); RESULT = numericBinary("*", (ExprAttr)l, (ExprAttr)r, opSym); :}
             | term:l DIV:op factor:r {: Symbol opSym = tokenFrom(op, opleft, opright, sym.DIV); RESULT = numericBinary("/", (ExprAttr)l, (ExprAttr)r, opSym); :}
             | term:l POTENCIA:op factor:r {: Symbol opSym = tokenFrom(op, opleft, opright, sym.POTENCIA); RESULT = numericBinary("^", (ExprAttr)l, (ExprAttr)r, opSym); :}
             | term:l FLOAT_DIV:op factor:r {: Symbol opSym = tokenFrom(op, opleft, opright, sym.FLOAT_DIV); RESULT = numericBinary("%", (ExprAttr)l, (ExprAttr)r, opSym); :};

factor     ::= numbers:n {: RESULT = n; :}
             | MENOS:op numbers:n {: Symbol opSym = tokenFrom(op, opleft, opright, sym.MENOS); RESULT = numericUnary("-", (ExprAttr)n, opSym); :}
             | STRING_LITERAL:lit {: Symbol litSym = tokenFrom(lit, litleft, litright, sym.STRING_LITERAL); RESULT = literalAttr(litSym, "\"\"", "STRING"); :}
             | CHARSTR:ch {: Symbol chSym = tokenFrom(ch, chleft, chright, sym.CHARSTR); RESULT = literalAttr(chSym, "'?'", "CHAR"); :}
             | IDENTIFIER:id {: Symbol idSym = tokenFrom(id, idleft, idright, sym.IDENTIFIER); RESULT = identifierExpr(lexeme(id), idSym); :}
             | IDENTIFIER:id DMENOS:op {: 
                    Symbol idSym = tokenFrom(id, idleft, idright, sym.IDENTIFIER);
                    Symbol opSym = tokenFrom(op, opleft, opright, sym.DMENOS);
                    ExprAttr base = identifierExpr(lexeme(id), idSym);
                    String step = "FLOAT".equals(base.type) ? "1.0" : "1";
                    ExprAttr result = numericBinary("-", base, literalAttr(null, step, base.type), opSym);
                    emit(lexeme(id) + " = " + result.place);
                    RESULT = result;
                :}
             | IDENTIFIER:id DMAS:op {: 
                    Symbol idSym = tokenFrom(id, idleft, idright, sym.IDENTIFIER);
                    Symbol opSym = tokenFrom(op, opleft, opright, sym.DMAS);
                    ExprAttr base = identifierExpr(lexeme(id), idSym);
                    String step = "FLOAT".equals(base.type) ? "1.0" : "1";
                    ExprAttr result = numericBinary("+", base, literalAttr(null, step, base.type), opSym);
                    emit(lexeme(id) + " = " + result.place);
                    RESULT = result;
                :}
             | IDENTIFIER:id UKRA argListOpt:args RUSS {: Symbol idSym = tokenFrom(id, idleft, idright, sym.IDENTIFIER); RESULT = invokeFunction(lexeme(id), (ArrayList)args, idSym); :}
             | arrayElement:arr {: RESULT = arr; :}
             | MENOS:op UKRA exprP:e RUSS {: Symbol opSym = tokenFrom(op, opleft, opright, sym.MENOS); RESULT = numericUnary("-", (ExprAttr)e, opSym); :}
             | UKRA exprP:e RUSS {: RESULT = e; :}
             | TRUE {: RESULT = new ExprAttr("true", "BOOL", true); :}
             | FALSE {: RESULT = new ExprAttr("false", "BOOL", true); :};


inputStruct ::= INPUT UKRA IDENTIFIER:id RUSS DOLLAR {: 
                    Symbol idSym = tokenFrom(id, idleft, idright, sym.IDENTIFIER);
                    String name = lexeme(id);
                    SymbolInfo info = lookupSymbol(name);
                    if (info == null) {
                        reportSemanticError("Variable '" + name + "' no declarada", idSym);
                    } else if (info.isArray) {
                        reportSemanticError("No se puede leer directamente un arreglo", idSym);
                    } else {
                        emit("read " + name);
                    }
                :};


//Manejo de distintas expresiones de comparacion y union
exprP ::= exprLog:e {: RESULT = e; :};

exprLog ::= exprLog:l AND:op exprRel:r {: Symbol opSym = tokenFrom(op, opleft, opright, sym.AND); RESULT = logicalBinary("&&", (ExprAttr)l, (ExprAttr)r, opSym); :}
        | exprLog:l OR:op exprRel:r {: Symbol opSym = tokenFrom(op, opleft, opright, sym.OR); RESULT = logicalBinary("||", (ExprAttr)l, (ExprAttr)r, opSym); :}
        | exprRel:e {: RESULT = e; :};

exprRel ::= compAritOp:left relChainSeq:seq {: ExprAttr base = (ExprAttr)left; RESULT = (seq != null) ? buildChainedComparison(base, (ArrayList<ComparisonLink>)seq) : base; :}
                    | NEGA:op exprRel:e {: Symbol opSym = tokenFrom(op, opleft, opright, sym.NEGA); RESULT = logicalUnary("!", (ExprAttr)e, opSym); :};

relChainSeq ::= relChainLink:first relChainSuffix:tail
                            {:
                                    ArrayList<ComparisonLink> list = new ArrayList<>();
                                    list.add((ComparisonLink)first);
                                    if (tail != null) list.addAll((ArrayList<ComparisonLink>)tail);
                                    RESULT = list;
                            :}
                        | /* empty */ {: RESULT = null; :};

relChainSuffix ::= relChainLink:first relChainSuffix:tail
                                 {:
                                         ArrayList<ComparisonLink> list = new ArrayList<>();
                                         list.add((ComparisonLink)first);
                                         if (tail != null) list.addAll((ArrayList<ComparisonLink>)tail);
                                         RESULT = list;
                                 :}
                             | /* empty */ {: RESULT = null; :};

relChainLink ::= GREATHER:op compAritOp:right {: Symbol opSym = tokenFrom(op, opleft, opright, sym.GREATHER); RESULT = new ComparisonLink(">", (ExprAttr)right, opSym); :}
                             | LESS:op compAritOp:right {: Symbol opSym = tokenFrom(op, opleft, opright, sym.LESS); RESULT = new ComparisonLink("<=", (ExprAttr)right, opSym); :}
                             | MORE:op compAritOp:right {: Symbol opSym = tokenFrom(op, opleft, opright, sym.MORE); RESULT = new ComparisonLink(">=", (ExprAttr)right, opSym); :}
                             | LOWER:op compAritOp:right {: Symbol opSym = tokenFrom(op, opleft, opright, sym.LOWER); RESULT = new ComparisonLink("<", (ExprAttr)right, opSym); :}
                             | DIFF:op compAritOp:right {: Symbol opSym = tokenFrom(op, opleft, opright, sym.DIFF); RESULT = new ComparisonLink("!=", (ExprAttr)right, opSym); :}
                             | COMPARA:op compAritOp:right {: Symbol opSym = tokenFrom(op, opleft, opright, sym.COMPARA); RESULT = new ComparisonLink("==", (ExprAttr)right, opSym); :};



scalarType ::= INT {: RESULT = "INT"; :}
             | CHAR {: RESULT = "CHAR"; :}
             | FLOAT {: RESULT = "FLOAT"; :}
             | BOOL {: RESULT = "BOOL"; :}
             | STRING {: RESULT = "STRING"; :};




//Asignación de un valor a una variable
varAsig      ::=  IDENTIFIER:id EQ:eq exprP:exp DOLLAR       {:
                    Symbol idSym = tokenFrom(id, idleft, idright, sym.IDENTIFIER);
                    Symbol eqSym = tokenFrom(eq, eqleft, eqright, sym.EQ);
                    String name = lexeme(id);
                    SymbolInfo target = lookupSymbol(name);
                    if (target == null) {
                        reportSemanticError("Variable '" + name + "' no declarada", idSym);
                    } else if (target.isArray) {
                        reportSemanticError("No se puede asignar a un arreglo completo sin indice", idSym);
                    } else {
                        recordAssignment(target, (ExprAttr)exp, eqSym);
                    }
                :}
             | arrayElement:elem EQ:eq exprP:exp DOLLAR       {:
                    Symbol eqSym = tokenFrom(eq, eqleft, eqright, sym.EQ);
                    ExprAttr lhs = (ExprAttr)elem;
                    ExprAttr rhs = (ExprAttr)exp;
                    emitArrayStore(lhs, rhs, eqSym);
                :}
             | EQ:eq exprP DOLLAR {: Symbol eqSym = tokenFrom(eq, eqleft, eqright, sym.EQ); reportSemanticError("Asignacion sin destino", eqSym); :};


//Instanciacion simple de variables
    varIns       ::= LET scalarType:t IDENTIFIER:ID    {: Symbol idSym = tokenFrom(ID, IDleft, IDright, sym.IDENTIFIER); String name = lexeme(ID); String typeName = t != null ? t.toString() : "INT"; SymbolInfo info = declareSymbol(currentHash, name, typeName, false, 0, false, false, idSym); if (info != null) emit("declare " + name + ":" + typeName); :};

    varInsInit   ::= LET scalarType:t IDENTIFIER:ID EQ:eq exprP:exp {:
                        Symbol idSym = tokenFrom(ID, IDleft, IDright, sym.IDENTIFIER);
                        Symbol eqSym = tokenFrom(eq, eqleft, eqright, sym.EQ);
                        String name = lexeme(ID);
                        String typeName = t != null ? t.toString() : "INT";
                        SymbolInfo info = declareSymbol(currentHash, name, typeName, false, 0, false, false, idSym);
                        if (info != null) {
                            emit("declare " + name + ":" + typeName);
                            recordAssignment(info, (ExprAttr)exp, eqSym);
                        }
                    :};



    varInsGl     ::=  GLOBAL LET scalarType:t IDENTIFIER:ID     {: Symbol idSym = tokenFrom(ID, IDleft, IDright, sym.IDENTIFIER); String name = lexeme(ID); String typeName = t != null ? t.toString() : "INT"; SymbolInfo info = declareSymbol(globalHash, name, typeName, false, 0, false, true, idSym); if (info != null) emit("declare_global " + name + ":" + typeName); :};

    varInsAsig   ::= varIns varAsig;

    varInsAsigGl   ::= varInsGl varAsig;

    
    funInitial   ::= INT IDENTIFIER:ID
                            {:   Symbol idSym = tokenFrom(ID, IDleft, IDright, sym.IDENTIFIER); String name = lexeme(ID); startFunctionScope(name, "INT", idSym); emitFunctionEntry(name, "INT"); :}
                 | CHAR IDENTIFIER:ID
                            {:   Symbol idSym = tokenFrom(ID, IDleft, IDright, sym.IDENTIFIER); String name = lexeme(ID); startFunctionScope(name, "CHAR", idSym); emitFunctionEntry(name, "CHAR"); :}
                 | BOOL IDENTIFIER:ID
                            {:   Symbol idSym = tokenFrom(ID, IDleft, IDright, sym.IDENTIFIER); String name = lexeme(ID); startFunctionScope(name, "BOOL", idSym); emitFunctionEntry(name, "BOOL"); :}
                 | STRING IDENTIFIER:ID
                            {:   Symbol idSym = tokenFrom(ID, IDleft, IDright, sym.IDENTIFIER); String name = lexeme(ID); startFunctionScope(name, "STRING", idSym); emitFunctionEntry(name, "STRING"); :}
                 | FLOAT IDENTIFIER:ID
                            {:   Symbol idSym = tokenFrom(ID, IDleft, IDright, sym.IDENTIFIER); String name = lexeme(ID); startFunctionScope(name, "FLOAT", idSym); emitFunctionEntry(name, "FLOAT"); :}
                 | VOID IDENTIFIER:ID
                            {:   Symbol idSym = tokenFrom(ID, IDleft, IDright, sym.IDENTIFIER); String name = lexeme(ID); startFunctionScope(name, "VOID", idSym); emitFunctionEntry(name, "VOID"); :};

    //Declaracion inicial del bloque para las funciones
    funcStruct    ::= funInitial paramSection {: emitFunctionParamMetadata(); :} blockStart BLOCK END_BLOCK {: String finished = currentHash; if (finished != null) { emitFunctionExit(finished); } FunctionInfo info = finished != null ? functionTable.get(finished) : null; if (info != null && !info.returnsVoid && !info.hasReturn) { reportSemanticError("La funcion '" + finished + "' no retorna", null); } closeCurrentScope(); :};  

paramSection ::= UKRA paramDeclList paramSectionClose
               | UKRA paramSectionClose
               | /* empty */;

paramSectionClose ::= RUSS
                    | /* empty */;

paramDeclList ::= paramDecl
                | paramDecl COMA paramDeclList;

paramDecl ::= INT IDENTIFIER:ID   {: registrarParametroEnScope(lexeme(ID), "INT", IDleft, IDright); :}
            | CHAR IDENTIFIER:ID  {: registrarParametroEnScope(lexeme(ID), "CHAR", IDleft, IDright); :}
            | FLOAT IDENTIFIER:ID {: registrarParametroEnScope(lexeme(ID), "FLOAT", IDleft, IDright); :}
            | BOOL IDENTIFIER:ID  {: registrarParametroEnScope(lexeme(ID), "BOOL", IDleft, IDright); :}
            | STRING IDENTIFIER:ID{: registrarParametroEnScope(lexeme(ID), "STRING", IDleft, IDright); :};

blockStart ::= INIT_BLOCK blockStartClose;

blockStartClose ::= RUSS
                  | /* empty */;

argListOpt ::= argList:l {: RESULT = l; :}
             | /* empty */ {: RESULT = new ArrayList(); :};

argList ::= exprP:e {: ArrayList tmp = new ArrayList(); tmp.add((ExprAttr)e); RESULT = tmp; :}
          | exprP:e COMA argList:rest {: ArrayList tmp = new ArrayList(); tmp.add((ExprAttr)e); tmp.addAll((ArrayList)rest); RESULT = tmp; :};

    mainStruct  ::= mainInitial paramSection {: emitFunctionParamMetadata(); :} blockStart BLOCK END_BLOCK {: emitFunctionExit("MAIN"); emitLabel("FIN_main"); emit("MAIN_END"); closeCurrentScope(); :};

      mainInitial  ::= PRINCIPAL:KW 
                                                 {: Symbol kwSym = tokenFrom(KW, KWleft, KWright, sym.PRINCIPAL);
                                                     startFunctionScope("MAIN", "INT", kwSym);
                                                     emit("MAIN_BEGIN");
                                                     emitFunctionEntry("MAIN", "INT");
                                                 :};

//Estructura decide of
decideOfStruct ::= DECIDE OF {: beginDecideStructure(); :} decideClauseList END DECIDE DOLLAR {: endDecideStructure(); :};

decideClauseList ::= decideClauseList decideClause
                   | decideClause;

decideClause ::= caseCondition:cond ARROW:arrowTok INIT_BLOCK {: Symbol arrowSym = tokenFrom(arrowTok, arrowTokleft, arrowTokright, sym.ARROW); beginDecideCase((ExprAttr)cond, arrowSym); :} BLOCK END_BLOCK {: endDecideCase(); :}
               | ELSE ARROW INIT_BLOCK {: beginDecideElse(); :} BLOCK END_BLOCK {: endDecideElse(); :};

caseCondition ::= exprP:e {: RESULT = e; :};

                  
//Produccion loop
loopStruct ::= LOOP {: beginLoopStructure(); :} loopBody EXIT:exitTok WHEN exprP:exitCond DOLLAR END LOOP DOLLAR {: Symbol exitSym = tokenFrom(exitTok, exitTokleft, exitTokright, sym.EXIT); finalizeLoopBody((ExprAttr)exitCond, exitSym); endLoopStructure(); :} loopElseOpt;

loopBody ::= exprP
          | BLOCK;

loopElseOpt ::= ELSE ARROW INIT_BLOCK BLOCK END_BLOCK {: emit("// rama else del loop"); :}
              | /* empty */;
 

//Declaracion de estructura for
forStruct ::= FOR forInit:init STEP stepValue:step TO exprP:limit DO {: beginForLoop((ExprAttr)init, (ExprAttr)step, (ExprAttr)limit, false); :} blockStart BLOCK END_BLOCK {: endForLoop(); :}
           | FOR forInit:init STEP stepValue:step DOWNTO exprP:limit DO {: beginForLoop((ExprAttr)init, (ExprAttr)step, (ExprAttr)limit, true); :} blockStart BLOCK END_BLOCK {: endForLoop(); :};

forInit ::= IDENTIFIER:id EQ:eq exprP:exp
          {:
              Symbol idSym = tokenFrom(id, idleft, idright, sym.IDENTIFIER);
              Symbol eqSym = tokenFrom(eq, eqleft, eqright, sym.EQ);
              String name = lexeme(id);
              SymbolInfo info = lookupSymbol(name);
              ExprAttr rhs = (ExprAttr)exp;
              if (info == null) {
                  reportSemanticError("Variable '" + name + "' no declarada", idSym);
                  RESULT = ExprAttr.invalid();
              } else {
                  recordAssignment(info, rhs, eqSym);
                  RESULT = new ExprAttr(info.name, info.type, false);
              }
          :}
          | arrayElement:elem EQ:eq exprP:exp
          {:
              Symbol eqSym = tokenFrom(eq, eqleft, eqright, sym.EQ);
              reportSemanticError("Los ciclos FOR requieren una variable ESCALAR como control", eqSym);
              RESULT = ExprAttr.invalid();
          :};

stepValue ::= exprP:exp {: RESULT = ensureNumeric((ExprAttr)exp, null, "step value"); :};


//Declaracion, asignacion y acceso a un array
arrayIns ::=  INT ARRAY IDENTIFIER:ID SQUARES INT_LITERAL:SZ SQUAREC {: Symbol idSym = tokenFrom(ID, IDleft, IDright, sym.IDENTIFIER); Symbol szSym = tokenFrom(SZ, SZleft, SZright, sym.INT_LITERAL); String name = lexeme(ID); int len = Math.max(0, literalToInt(szSym)); SymbolInfo info = declareSymbol(currentHash, name, "INT", true, len, false, false, idSym); if (info != null) { emit("declare_arr " + name + "[" + len + "] INT"); if (len > 0) emit("arr_pad_zero " + name + ", 0, " + len); } :}
            | CHAR ARRAY IDENTIFIER:ID SQUARES INT_LITERAL:SZ SQUAREC {: Symbol idSym = tokenFrom(ID, IDleft, IDright, sym.IDENTIFIER); Symbol szSym = tokenFrom(SZ, SZleft, SZright, sym.INT_LITERAL); String name = lexeme(ID); int len = Math.max(0, literalToInt(szSym)); SymbolInfo info = declareSymbol(currentHash, name, "CHAR", true, len, false, false, idSym); if (info != null) { emit("declare_arr " + name + "[" + len + "] CHAR"); if (len > 0) emit("arr_pad_zero " + name + ", 0, " + len); } :};

//Declaracion global de array
arrayInsGl ::=  GLOBAL INT ARRAY IDENTIFIER:ID SQUARES INT_LITERAL:SZ SQUAREC  {: Symbol idSym = tokenFrom(ID, IDleft, IDright, sym.IDENTIFIER); Symbol szSym = tokenFrom(SZ, SZleft, SZright, sym.INT_LITERAL); String name = lexeme(ID); int len = Math.max(0, literalToInt(szSym)); SymbolInfo info = declareSymbol(globalHash, name, "INT", true, len, false, true, idSym); if (info != null) { emit("declare_global_arr " + name + "[" + len + "] INT"); if (len > 0) emit("arr_pad_zero " + name + ", 0, " + len); } :}
            | GLOBAL CHAR ARRAY IDENTIFIER:ID SQUARES INT_LITERAL:SZ SQUAREC {: Symbol idSym = tokenFrom(ID, IDleft, IDright, sym.IDENTIFIER); Symbol szSym = tokenFrom(SZ, SZleft, SZright, sym.INT_LITERAL); String name = lexeme(ID); int len = Math.max(0, literalToInt(szSym)); SymbolInfo info = declareSymbol(globalHash, name, "CHAR", true, len, false, true, idSym); if (info != null) { emit("declare_global_arr " + name + "[" + len + "] CHAR"); if (len > 0) emit("arr_pad_zero " + name + ", 0, " + len); } :};

arrayLetStmt ::= LET scalarType:t IDENTIFIER:ID SQUARES INT_LITERAL:SZ SQUAREC {:
                    Symbol idSym = tokenFrom(ID, IDleft, IDright, sym.IDENTIFIER);
                    Symbol szSym = tokenFrom(SZ, SZleft, SZright, sym.INT_LITERAL);
                    String name = lexeme(ID);
                    String elementType = t != null ? t.toString() : "INT";
                    int len = Math.max(0, literalToInt(szSym));
                    SymbolInfo info = declareSymbol(currentHash, name, elementType, true, len, false, false, idSym);
                    if (info != null) {
                        emit("declare_arr " + name + "[" + len + "] " + elementType);
                        initializeArrayValues(info, null, idSym);
                    }
                :}
              | LET scalarType:t IDENTIFIER:ID SQUARES INT_LITERAL:SZ SQUAREC EQ:eq arrayLiteral:vals {:
                    Symbol idSym = tokenFrom(ID, IDleft, IDright, sym.IDENTIFIER);
                    Symbol szSym = tokenFrom(SZ, SZleft, SZright, sym.INT_LITERAL);
                    Symbol eqSym = tokenFrom(eq, eqleft, eqright, sym.EQ);
                    String name = lexeme(ID);
                    String elementType = t != null ? t.toString() : "INT";
                    int len = Math.max(0, literalToInt(szSym));
                    SymbolInfo info = declareSymbol(currentHash, name, elementType, true, len, false, false, idSym);
                    if (info != null) {
                        emit("declare_arr " + name + "[" + len + "] " + elementType);
                        initializeArrayValues(info, (ArrayList<ExprAttr>)vals, eqSym);
                    }
                :};

//Declaracion de ARRAYS Y TODO LO RELACIONADO
arrayAsig ::= IDENTIFIER:id EQ:eq SQUARES elementos:vals SQUAREC DOLLAR {: 
                    Symbol idSym = tokenFrom(id, idleft, idright, sym.IDENTIFIER);
                    Symbol eqSym = tokenFrom(eq, eqleft, eqright, sym.EQ);
                    String name = lexeme(id);
                    SymbolInfo info = lookupSymbol(name);
                    if (info == null) {
                        reportSemanticError("Arreglo '" + name + "' no declarado", idSym);
                    } else if (!info.isArray) {
                        reportSemanticError("'" + name + "' no es un arreglo", idSym);
                    } else {
                        ArrayList<ExprAttr> list = (ArrayList<ExprAttr>)vals;
                        initializeArrayValues(info, list, eqSym);
                    }
                :}
          | EQ:eq SQUARES elementos SQUAREC DOLLAR {: Symbol eqSym = tokenFrom(eq, eqleft, eqright, sym.EQ); reportSemanticError("Se requiere identificador para asignar arreglo", eqSym); :};

elementos ::= compAritOp:e COMA elementos:rest {: ArrayList<ExprAttr> tmp = new ArrayList<>(); tmp.add((ExprAttr)e); tmp.addAll((ArrayList<ExprAttr>)rest); RESULT = tmp; :}
           | compAritOp:e {: ArrayList<ExprAttr> tmp = new ArrayList<>(); tmp.add((ExprAttr)e); RESULT = tmp; :};

arrayLiteral ::= INIT_BLOCK arrayLiteralItems:vals END_BLOCK {: RESULT = (ArrayList<ExprAttr>)vals; :}
               | INIT_BLOCK END_BLOCK {: RESULT = new ArrayList<ExprAttr>(); :};

arrayLiteralItems ::= exprP:exp COMA arrayLiteralItems:rest {: ArrayList<ExprAttr> list = new ArrayList<>(); list.add((ExprAttr)exp); list.addAll((ArrayList<ExprAttr>)rest); RESULT = list; :}
                    | exprP:exp {: ArrayList<ExprAttr> list = new ArrayList<>(); list.add((ExprAttr)exp); RESULT = list; :};

arrayInsAsign ::= arrayIns arrayAsig;

arrayInsAsignGl ::= arrayInsGl arrayAsig;

arrayElement ::= IDENTIFIER:id SQUARES compAritOp:expr SQUAREC {: Symbol idSym = tokenFrom(id, idleft, idright, sym.IDENTIFIER); RESULT = arrayAccess(lexeme(id), (ExprAttr)expr, idSym, null); :};

//Declaracion de parametros
paramStruct ::= PARAM INT IDENTIFIER:ID {: String lex = lexeme(ID); String target=(currentHash!=null?currentHash:globalHash); ensureScopeBucket(target); scopePrograma.get(target).add("Instancia PARAM: " + lex + ":" + "INT" + ":line=" + (IDleft+1) + ":col=" + (IDright+1)); :}
    | PARAM CHAR IDENTIFIER:ID {: String lex = lexeme(ID); String target=(currentHash!=null?currentHash:globalHash); ensureScopeBucket(target); scopePrograma.get(target).add("Instancia PARAM: " + lex + ":" + "CHAR" + ":line=" + (IDleft+1) + ":col=" + (IDright+1)); :}
    | PARAM STRING IDENTIFIER:ID {: String lex = lexeme(ID); String target=(currentHash!=null?currentHash:globalHash); ensureScopeBucket(target); scopePrograma.get(target).add("Instancia PARAM: " + lex + ":" + "STRING" + ":line=" + (IDleft+1) + ":col=" + (IDright+1)); :}
    | PARAM FLOAT IDENTIFIER:ID {: String lex = lexeme(ID); String target=(currentHash!=null?currentHash:globalHash); ensureScopeBucket(target); scopePrograma.get(target).add("Instancia PARAM: " + lex + ":" + "FLOAT" + ":line=" + (IDleft+1) + ":col=" + (IDright+1)); :}
    | PARAM BOOL IDENTIFIER:ID  {: String lex = lexeme(ID); String target=(currentHash!=null?currentHash:globalHash); ensureScopeBucket(target); scopePrograma.get(target).add("Instancia PARAM: " + lex + ":" + "BOOL" + ":line=" + (IDleft+1) + ":col=" + (IDright+1)); :};

paramList ::= paramStruct paramList
       | paramStruct;


outPutStruct ::= OUTPUT UKRA exprP:exp RUSS {: ExprAttr value = (ExprAttr)exp; if (value != null && value.isValid()) emit("print " + value.place); :};

// Error recovery - simplified
error ::= error DOLLAR {: System.out.println("Syntax error"); :};